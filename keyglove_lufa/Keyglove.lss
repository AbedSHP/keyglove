
Keyglove.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800100  00001052  000010e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001052  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001a  0080011c  0080011c  00001102  2**0
                  ALLOC
  3 .debug_aranges 000002e0  00000000  00000000  00001102  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000854  00000000  00000000  000013e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004cba  00000000  00000000  00001c36  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001264  00000000  00000000  000068f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003d52  00000000  00000000  00007b54  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000440  00000000  00000000  0000b8a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000021e3  00000000  00000000  0000bce8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000243f  00000000  00000000  0000decb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000368  00000000  00000000  0001030a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
 *  LED report can be sent through either the control endpoint (via a HID SetReport request) or the HID OUT
 *  endpoint, the processing code is placed here to avoid duplicating it and potentially having different
 *  behaviour depending on the method used to sent it.
 */
void Keyboard_ProcessLEDReport(const uint8_t LEDStatus)
{
       0:	be c0       	rjmp	.+380    	; 0x17e <__ctors_end>
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       2:	00 00       	nop
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       4:	d9 c0       	rjmp	.+434    	; 0x1b8 <__bad_interrupt>
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       6:	00 00       	nop
       8:	d7 c0       	rjmp	.+430    	; 0x1b8 <__bad_interrupt>
       a:	00 00       	nop
       c:	d5 c0       	rjmp	.+426    	; 0x1b8 <__bad_interrupt>
       e:	00 00       	nop
      10:	d3 c0       	rjmp	.+422    	; 0x1b8 <__bad_interrupt>
      12:	00 00       	nop
      14:	d1 c0       	rjmp	.+418    	; 0x1b8 <__bad_interrupt>
      16:	00 00       	nop
      18:	cf c0       	rjmp	.+414    	; 0x1b8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	cd c0       	rjmp	.+410    	; 0x1b8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	cb c0       	rjmp	.+406    	; 0x1b8 <__bad_interrupt>
      22:	00 00       	nop
      24:	c9 c0       	rjmp	.+402    	; 0x1b8 <__bad_interrupt>
      26:	00 00       	nop
      28:	cf c3       	rjmp	.+1950   	; 0x7c8 <__vector_10>
      2a:	00 00       	nop
      2c:	c5 c0       	rjmp	.+394    	; 0x1b8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	c3 c0       	rjmp	.+390    	; 0x1b8 <__bad_interrupt>
      32:	00 00       	nop
      34:	c1 c0       	rjmp	.+386    	; 0x1b8 <__bad_interrupt>
      36:	00 00       	nop
      38:	bf c0       	rjmp	.+382    	; 0x1b8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	bd c0       	rjmp	.+378    	; 0x1b8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	bb c0       	rjmp	.+374    	; 0x1b8 <__bad_interrupt>
      42:	00 00       	nop
      44:	b9 c0       	rjmp	.+370    	; 0x1b8 <__bad_interrupt>
      46:	00 00       	nop
      48:	b7 c0       	rjmp	.+366    	; 0x1b8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	b5 c0       	rjmp	.+362    	; 0x1b8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	b3 c0       	rjmp	.+358    	; 0x1b8 <__bad_interrupt>
      52:	00 00       	nop
      54:	b1 c0       	rjmp	.+354    	; 0x1b8 <__bad_interrupt>
      56:	00 00       	nop
      58:	af c0       	rjmp	.+350    	; 0x1b8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ad c0       	rjmp	.+346    	; 0x1b8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	ab c0       	rjmp	.+342    	; 0x1b8 <__bad_interrupt>
      62:	00 00       	nop
      64:	a9 c0       	rjmp	.+338    	; 0x1b8 <__bad_interrupt>
      66:	00 00       	nop
      68:	a7 c0       	rjmp	.+334    	; 0x1b8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	a5 c0       	rjmp	.+330    	; 0x1b8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	a3 c0       	rjmp	.+326    	; 0x1b8 <__bad_interrupt>
      72:	00 00       	nop
      74:	a1 c0       	rjmp	.+322    	; 0x1b8 <__bad_interrupt>
      76:	00 00       	nop
      78:	9f c0       	rjmp	.+318    	; 0x1b8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	9d c0       	rjmp	.+314    	; 0x1b8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	9b c0       	rjmp	.+310    	; 0x1b8 <__bad_interrupt>
      82:	00 00       	nop
      84:	99 c0       	rjmp	.+306    	; 0x1b8 <__bad_interrupt>
      86:	00 00       	nop
      88:	97 c0       	rjmp	.+302    	; 0x1b8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	95 c0       	rjmp	.+298    	; 0x1b8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	93 c0       	rjmp	.+294    	; 0x1b8 <__bad_interrupt>
      92:	00 00       	nop
      94:	91 c0       	rjmp	.+290    	; 0x1b8 <__bad_interrupt>
      96:	00 00       	nop

00000098 <GenericReport>:
      98:	06 00 ff 09 01 a1 01 09 02 15 00 25 ff 75 08 95     ...........%.u..
      a8:	08 81 02 09 03 15 00 25 ff 75 08 95 08 91 02 c0     .......%.u......

000000b8 <DeviceDescriptor>:
      b8:	12 01 10 01 00 00 00 08 eb 03 4e 20 01 00 01 02     ..........N ....
      c8:	dc 01                                               ..

000000ca <ConfigurationDescriptor>:
      ca:	09 02 66 00 03 01 00 c0 fa 08 0b 00 02 02 02 01     ..f.............
      da:	00 09 04 00 00 01 02 02 01 00 05 24 00 10 01 04     ...........$....
      ea:	24 02 06 05 24 06 00 01 07 05 81 03 08 00 ff 09     $...$...........
      fa:	04 01 00 02 0a 00 00 00 07 05 03 02 10 00 01 07     ................
     10a:	05 82 02 10 00 01 09 04 02 00 02 03 00 00 00 09     ................
     11a:	21 11 01 00 01 22 20 00 07 05 81 03 08 00 01 07     !...." .........
     12a:	05 02 03 08 00 01                                   ......

00000130 <LanguageString>:
     130:	04 03 09 04                                         ....

00000134 <ManufacturerString>:
     134:	18 03 4a 00 65 00 66 00 66 00 20 00 52 00 6f 00     ..J.e.f.f. .R.o.
     144:	77 00 62 00 65 00 72 00 67 00 00 00                 w.b.e.r.g...

00000150 <ProductString>:
     150:	3a 03 4b 00 65 00 79 00 67 00 6c 00 6f 00 76 00     :.K.e.y.g.l.o.v.
     160:	65 00 20 00 49 00 6e 00 70 00 75 00 74 00 20 00     e. .I.n.p.u.t. .
     170:	44 00 65 00 76 00 69 00 63 00 65 00 00 00           D.e.v.i.c.e...

0000017e <__ctors_end>:
     17e:	11 24       	eor	r1, r1
     180:	1f be       	out	0x3f, r1	; 63
     182:	cf ef       	ldi	r28, 0xFF	; 255
     184:	d0 e2       	ldi	r29, 0x20	; 32
     186:	de bf       	out	0x3e, r29	; 62
     188:	cd bf       	out	0x3d, r28	; 61

0000018a <__do_copy_data>:
     18a:	11 e0       	ldi	r17, 0x01	; 1
     18c:	a0 e0       	ldi	r26, 0x00	; 0
     18e:	b1 e0       	ldi	r27, 0x01	; 1
     190:	e2 e5       	ldi	r30, 0x52	; 82
     192:	f0 e1       	ldi	r31, 0x10	; 16
     194:	00 e0       	ldi	r16, 0x00	; 0
     196:	0b bf       	out	0x3b, r16	; 59
     198:	02 c0       	rjmp	.+4      	; 0x19e <__do_copy_data+0x14>
     19a:	07 90       	elpm	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	ac 31       	cpi	r26, 0x1C	; 28
     1a0:	b1 07       	cpc	r27, r17
     1a2:	d9 f7       	brne	.-10     	; 0x19a <__do_copy_data+0x10>

000001a4 <__do_clear_bss>:
     1a4:	11 e0       	ldi	r17, 0x01	; 1
     1a6:	ac e1       	ldi	r26, 0x1C	; 28
     1a8:	b1 e0       	ldi	r27, 0x01	; 1
     1aa:	01 c0       	rjmp	.+2      	; 0x1ae <.do_clear_bss_start>

000001ac <.do_clear_bss_loop>:
     1ac:	1d 92       	st	X+, r1

000001ae <.do_clear_bss_start>:
     1ae:	a6 33       	cpi	r26, 0x36	; 54
     1b0:	b1 07       	cpc	r27, r17
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <.do_clear_bss_loop>
     1b4:	c5 d1       	rcall	.+906    	; 0x540 <main>
     1b6:	4b c7       	rjmp	.+3734   	; 0x104e <_exit>

000001b8 <__bad_interrupt>:
     1b8:	23 cf       	rjmp	.-442    	; 0x0 <__vectors>

000001ba <EVENT_USB_Device_Connect>:
				PORTF &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTF = ((PORTF & ~LEDS_ALL_LEDS_F) | LEDMask);
     1ba:	81 b3       	in	r24, 0x11	; 17
     1bc:	8f 71       	andi	r24, 0x1F	; 31
     1be:	80 6c       	ori	r24, 0xC0	; 192
     1c0:	81 bb       	out	0x11, r24	; 17
 */
void EVENT_USB_Device_Connect(void)
{
    /* Indicate USB enumerating */
    LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     1c2:	08 95       	ret

000001c4 <EVENT_USB_Device_Disconnect>:
     1c4:	81 b3       	in	r24, 0x11	; 17
     1c6:	8f 71       	andi	r24, 0x1F	; 31
     1c8:	80 66       	ori	r24, 0x60	; 96
     1ca:	81 bb       	out	0x11, r24	; 17
 */
void EVENT_USB_Device_Disconnect(void)
{
    /* Indicate USB not ready */
    LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     1cc:	08 95       	ret

000001ce <ProcessGenericHIDReport>:
/** Function to process the lest received report from the host.
 *
 *  \param[in] DataArray  Pointer to a buffer where the last report data is stored
 */
void ProcessGenericHIDReport(uint8_t* DataArray)
{
     1ce:	ac 01       	movw	r20, r24
     1d0:	20 e0       	ldi	r18, 0x00	; 0
     1d2:	30 e0       	ldi	r19, 0x00	; 0
        DataArray is an array holding the last report from the host. This function is called
        each time the host has sent a report to the device.
    */

    for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
      LastReceived[i] = DataArray[i];
     1d4:	f9 01       	movw	r30, r18
     1d6:	ef 5d       	subi	r30, 0xDF	; 223
     1d8:	fe 4f       	sbci	r31, 0xFE	; 254
     1da:	da 01       	movw	r26, r20
     1dc:	a2 0f       	add	r26, r18
     1de:	b3 1f       	adc	r27, r19
     1e0:	8c 91       	ld	r24, X
     1e2:	80 83       	st	Z, r24
     1e4:	2f 5f       	subi	r18, 0xFF	; 255
     1e6:	3f 4f       	sbci	r19, 0xFF	; 255
        This is where you need to process the reports being sent from the host to the device.
        DataArray is an array holding the last report from the host. This function is called
        each time the host has sent a report to the device.
    */

    for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
     1e8:	28 30       	cpi	r18, 0x08	; 8
     1ea:	31 05       	cpc	r19, r1
     1ec:	99 f7       	brne	.-26     	; 0x1d4 <ProcessGenericHIDReport+0x6>
      LastReceived[i] = DataArray[i];
}
     1ee:	08 95       	ret

000001f0 <CreateGenericHIDReport>:
/** Function to create the next report to send back to the host at the next reporting interval.
 *
 *  \param[out] DataArray  Pointer to a buffer where the next report data should be stored
 */
void CreateGenericHIDReport(uint8_t* DataArray)
{
     1f0:	ac 01       	movw	r20, r24
     1f2:	20 e0       	ldi	r18, 0x00	; 0
     1f4:	30 e0       	ldi	r19, 0x00	; 0
        function is called each time the host is ready to accept a new report. DataArray is
        an array to hold the report to the host.
    */

    for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
      DataArray[i] = LastReceived[i];
     1f6:	fa 01       	movw	r30, r20
     1f8:	e2 0f       	add	r30, r18
     1fa:	f3 1f       	adc	r31, r19
     1fc:	d9 01       	movw	r26, r18
     1fe:	af 5d       	subi	r26, 0xDF	; 223
     200:	be 4f       	sbci	r27, 0xFE	; 254
     202:	8c 91       	ld	r24, X
     204:	80 83       	st	Z, r24
     206:	2f 5f       	subi	r18, 0xFF	; 255
     208:	3f 4f       	sbci	r19, 0xFF	; 255
        This is where you need to create reports to be sent to the host from the device. This
        function is called each time the host is ready to accept a new report. DataArray is
        an array to hold the report to the host.
    */

    for (uint8_t i = 0; i < GENERIC_REPORT_SIZE; i++)
     20a:	28 30       	cpi	r18, 0x08	; 8
     20c:	31 05       	cpc	r19, r1
     20e:	99 f7       	brne	.-26     	; 0x1f6 <CreateGenericHIDReport+0x6>
      DataArray[i] = LastReceived[i];
}
     210:	08 95       	ret

00000212 <HID_Task>:

void HID_Task(void)
{
     212:	0f 93       	push	r16
     214:	1f 93       	push	r17
     216:	df 93       	push	r29
     218:	cf 93       	push	r28
     21a:	cd b7       	in	r28, 0x3d	; 61
     21c:	de b7       	in	r29, 0x3e	; 62
     21e:	28 97       	sbiw	r28, 0x08	; 8
     220:	0f b6       	in	r0, 0x3f	; 63
     222:	f8 94       	cli
     224:	de bf       	out	0x3e, r29	; 62
     226:	0f be       	out	0x3f, r0	; 63
     228:	cd bf       	out	0x3d, r28	; 61
    /* Device must be connected and configured for the task to run */
    if (USB_DeviceState != DEVICE_STATE_Configured)
     22a:	80 91 2d 01 	lds	r24, 0x012D
     22e:	84 30       	cpi	r24, 0x04	; 4
     230:	91 f5       	brne	.+100    	; 0x296 <HID_Task+0x84>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     232:	82 e0       	ldi	r24, 0x02	; 2
     234:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     238:	80 91 e8 00 	lds	r24, 0x00E8
      return;

    Endpoint_SelectEndpoint(GENERIC_OUT_EPNUM);

    /* Check to see if a packet has been sent from the host */
    if (Endpoint_IsOUTReceived())
     23c:	82 ff       	sbrs	r24, 2
     23e:	14 c0       	rjmp	.+40     	; 0x268 <HID_Task+0x56>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     240:	80 91 e8 00 	lds	r24, 0x00E8
    {
        /* Check to see if the packet contains data */
        if (Endpoint_IsReadWriteAllowed())
     244:	85 ff       	sbrs	r24, 5
     246:	0b c0       	rjmp	.+22     	; 0x25e <HID_Task+0x4c>
        {
            /* Create a temporary buffer to hold the read in report from the host */
            uint8_t GenericData[GENERIC_REPORT_SIZE];

            /* Read Generic Report Data */
            Endpoint_Read_Stream_LE(&GenericData, sizeof(GenericData), NULL);
     248:	8e 01       	movw	r16, r28
     24a:	0f 5f       	subi	r16, 0xFF	; 255
     24c:	1f 4f       	sbci	r17, 0xFF	; 255
     24e:	c8 01       	movw	r24, r16
     250:	68 e0       	ldi	r22, 0x08	; 8
     252:	70 e0       	ldi	r23, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	06 d6       	rcall	.+3084   	; 0xe66 <Endpoint_Read_Stream_LE>

            /* Process Generic Report Data */
            ProcessGenericHIDReport(GenericData);
     25a:	c8 01       	movw	r24, r16
     25c:	b8 df       	rcall	.-144    	; 0x1ce <ProcessGenericHIDReport>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     25e:	80 91 e8 00 	lds	r24, 0x00E8
     262:	8b 77       	andi	r24, 0x7B	; 123
     264:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     268:	81 e0       	ldi	r24, 0x01	; 1
     26a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     26e:	80 91 e8 00 	lds	r24, 0x00E8
    }

    Endpoint_SelectEndpoint(GENERIC_IN_EPNUM);

    /* Check to see if the host is ready to accept another packet */
    if (Endpoint_IsINReady())
     272:	80 ff       	sbrs	r24, 0
     274:	10 c0       	rjmp	.+32     	; 0x296 <HID_Task+0x84>
    {
        /* Create a temporary buffer to hold the report to send to the host */
        uint8_t GenericData[GENERIC_REPORT_SIZE];

        /* Create Generic Report Data */
        CreateGenericHIDReport(GenericData);
     276:	8e 01       	movw	r16, r28
     278:	0f 5f       	subi	r16, 0xFF	; 255
     27a:	1f 4f       	sbci	r17, 0xFF	; 255
     27c:	c8 01       	movw	r24, r16
     27e:	b8 df       	rcall	.-144    	; 0x1f0 <CreateGenericHIDReport>

        /* Write Generic Report Data */
        Endpoint_Write_Stream_LE(&GenericData, sizeof(GenericData), NULL);
     280:	c8 01       	movw	r24, r16
     282:	68 e0       	ldi	r22, 0x08	; 8
     284:	70 e0       	ldi	r23, 0x00	; 0
     286:	40 e0       	ldi	r20, 0x00	; 0
     288:	50 e0       	ldi	r21, 0x00	; 0
     28a:	3f d6       	rcall	.+3198   	; 0xf0a <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     28c:	80 91 e8 00 	lds	r24, 0x00E8
     290:	8e 77       	andi	r24, 0x7E	; 126
     292:	80 93 e8 00 	sts	0x00E8, r24

        /* Finalize the stream transfer to send the last packet */
        Endpoint_ClearIN();
    }
}
     296:	28 96       	adiw	r28, 0x08	; 8
     298:	0f b6       	in	r0, 0x3f	; 63
     29a:	f8 94       	cli
     29c:	de bf       	out	0x3e, r29	; 62
     29e:	0f be       	out	0x3f, r0	; 63
     2a0:	cd bf       	out	0x3d, r28	; 61
     2a2:	cf 91       	pop	r28
     2a4:	df 91       	pop	r29
     2a6:	1f 91       	pop	r17
     2a8:	0f 91       	pop	r16
     2aa:	08 95       	ret

000002ac <CDC_Task>:
{
    char*       ReportString    = NULL;
    static bool ActionSent      = false;
    
    /* Device must be connected and configured for the task to run */
    if (USB_DeviceState != DEVICE_STATE_Configured)
     2ac:	80 91 2d 01 	lds	r24, 0x012D
     2b0:	84 30       	cpi	r24, 0x04	; 4
     2b2:	09 f0       	breq	.+2      	; 0x2b6 <CDC_Task+0xa>
     2b4:	59 c0       	rjmp	.+178    	; 0x368 <CDC_Task+0xbc>
      return;

    if (counter % 10000 == 0)
     2b6:	60 91 1c 01 	lds	r22, 0x011C
     2ba:	70 91 1d 01 	lds	r23, 0x011D
     2be:	80 91 1e 01 	lds	r24, 0x011E
     2c2:	90 91 1f 01 	lds	r25, 0x011F
     2c6:	20 e1       	ldi	r18, 0x10	; 16
     2c8:	37 e2       	ldi	r19, 0x27	; 39
     2ca:	40 e0       	ldi	r20, 0x00	; 0
     2cc:	50 e0       	ldi	r21, 0x00	; 0
     2ce:	82 d6       	rcall	.+3332   	; 0xfd4 <__divmodsi4>
     2d0:	9b 01       	movw	r18, r22
     2d2:	ac 01       	movw	r20, r24
     2d4:	21 15       	cp	r18, r1
     2d6:	31 05       	cpc	r19, r1
     2d8:	41 05       	cpc	r20, r1
     2da:	51 05       	cpc	r21, r1
     2dc:	49 f0       	breq	.+18     	; 0x2f0 <CDC_Task+0x44>
    {
        ReportString = "Test serial output\r\n";
    }
    else
    {
        ActionSent = false;
     2de:	10 92 20 01 	sts	0x0120, r1
        if (counter % 10000 == 1000)
     2e2:	28 5e       	subi	r18, 0xE8	; 232
     2e4:	33 40       	sbci	r19, 0x03	; 3
     2e6:	40 40       	sbci	r20, 0x00	; 0
     2e8:	50 40       	sbci	r21, 0x00	; 0
     2ea:	91 f5       	brne	.+100    	; 0x350 <CDC_Task+0xa4>
        {
            PORTD &= ~(1 << 6);
     2ec:	5e 98       	cbi	0x0b, 6	; 11
     2ee:	30 c0       	rjmp	.+96     	; 0x350 <CDC_Task+0xa4>
        }
    }

    /* Flag management - Only allow one string to be sent per action */
    if ((ReportString != NULL) && (ActionSent == false) && LineEncodingData.BaudRateBPS)
     2f0:	80 91 20 01 	lds	r24, 0x0120
     2f4:	88 23       	and	r24, r24
     2f6:	61 f5       	brne	.+88     	; 0x350 <CDC_Task+0xa4>
     2f8:	80 91 15 01 	lds	r24, 0x0115
     2fc:	90 91 16 01 	lds	r25, 0x0116
     300:	a0 91 17 01 	lds	r26, 0x0117
     304:	b0 91 18 01 	lds	r27, 0x0118
     308:	00 97       	sbiw	r24, 0x00	; 0
     30a:	a1 05       	cpc	r26, r1
     30c:	b1 05       	cpc	r27, r1
     30e:	01 f1       	breq	.+64     	; 0x350 <CDC_Task+0xa4>
    {
        PORTD |= (1 << 6);
     310:	5e 9a       	sbi	0x0b, 6	; 11
        ActionSent = true;
     312:	81 e0       	ldi	r24, 0x01	; 1
     314:	80 93 20 01 	sts	0x0120, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     318:	82 e0       	ldi	r24, 0x02	; 2
     31a:	80 93 e9 00 	sts	0x00E9, r24

        /* Select the Serial Tx Endpoint */
        Endpoint_SelectEndpoint(CDC_TX_EPNUM);

        /* Write the String to the Endpoint */
        Endpoint_Write_Stream_LE(ReportString, strlen(ReportString), NULL);
     31e:	80 e0       	ldi	r24, 0x00	; 0
     320:	91 e0       	ldi	r25, 0x01	; 1
     322:	64 e1       	ldi	r22, 0x14	; 20
     324:	70 e0       	ldi	r23, 0x00	; 0
     326:	40 e0       	ldi	r20, 0x00	; 0
     328:	50 e0       	ldi	r21, 0x00	; 0
     32a:	ef d5       	rcall	.+3038   	; 0xf0a <Endpoint_Write_Stream_LE>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
     32c:	20 91 f2 00 	lds	r18, 0x00F2
     330:	30 91 f3 00 	lds	r19, 0x00F3
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     334:	80 91 e8 00 	lds	r24, 0x00E8
     338:	8e 77       	andi	r24, 0x7E	; 126
     33a:	80 93 e8 00 	sts	0x00E8, r24
        /* Finalize the stream transfer to send the last packet */
        Endpoint_ClearIN();

        /* If the last packet filled the endpoint, send an empty packet to release the buffer on
         * the receiver (otherwise all data will be cached until a non-full packet is received) */
        if (IsFull)
     33e:	20 31       	cpi	r18, 0x10	; 16
     340:	31 05       	cpc	r19, r1
     342:	31 f4       	brne	.+12     	; 0x350 <CDC_Task+0xa4>
        {
            /* Wait until the endpoint is ready for another packet */
            Endpoint_WaitUntilReady();
     344:	b0 d1       	rcall	.+864    	; 0x6a6 <Endpoint_WaitUntilReady>
     346:	80 91 e8 00 	lds	r24, 0x00E8
     34a:	8e 77       	andi	r24, 0x7E	; 126
     34c:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     350:	83 e0       	ldi	r24, 0x03	; 3
     352:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     356:	80 91 e8 00 	lds	r24, 0x00E8

    /* Select the Serial Rx Endpoint */
    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    /* Throw away any received data from the host */
    if (Endpoint_IsOUTReceived())
     35a:	82 ff       	sbrs	r24, 2
     35c:	05 c0       	rjmp	.+10     	; 0x368 <CDC_Task+0xbc>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     35e:	80 91 e8 00 	lds	r24, 0x00E8
     362:	8b 77       	andi	r24, 0x7B	; 123
     364:	80 93 e8 00 	sts	0x00E8, r24
     368:	08 95       	ret

0000036a <EVENT_USB_Device_ControlRequest>:
/** Event handler for the USB_ControlRequest event. This is used to catch and process control requests sent to
 *  the device from the USB host before passing along unhandled control requests to the library for processing
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
     36a:	0f 93       	push	r16
     36c:	1f 93       	push	r17
     36e:	df 93       	push	r29
     370:	cf 93       	push	r28
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	28 97       	sbiw	r28, 0x08	; 8
     378:	0f b6       	in	r0, 0x3f	; 63
     37a:	f8 94       	cli
     37c:	de bf       	out	0x3e, r29	; 62
     37e:	0f be       	out	0x3f, r0	; 63
     380:	cd bf       	out	0x3d, r28	; 61
    switch (USB_ControlRequest.bRequest)
     382:	80 91 2f 01 	lds	r24, 0x012F
     386:	80 32       	cpi	r24, 0x20	; 32
     388:	09 f4       	brne	.+2      	; 0x38c <EVENT_USB_Device_ControlRequest+0x22>
     38a:	4e c0       	rjmp	.+156    	; 0x428 <EVENT_USB_Device_ControlRequest+0xbe>
     38c:	81 32       	cpi	r24, 0x21	; 33
     38e:	30 f4       	brcc	.+12     	; 0x39c <EVENT_USB_Device_ControlRequest+0x32>
     390:	81 30       	cpi	r24, 0x01	; 1
     392:	51 f0       	breq	.+20     	; 0x3a8 <EVENT_USB_Device_ControlRequest+0x3e>
     394:	89 30       	cpi	r24, 0x09	; 9
     396:	09 f0       	breq	.+2      	; 0x39a <EVENT_USB_Device_ControlRequest+0x30>
     398:	63 c0       	rjmp	.+198    	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
     39a:	19 c0       	rjmp	.+50     	; 0x3ce <EVENT_USB_Device_ControlRequest+0x64>
     39c:	81 32       	cpi	r24, 0x21	; 33
     39e:	81 f1       	breq	.+96     	; 0x400 <EVENT_USB_Device_ControlRequest+0x96>
     3a0:	82 32       	cpi	r24, 0x22	; 34
     3a2:	09 f0       	breq	.+2      	; 0x3a6 <EVENT_USB_Device_ControlRequest+0x3c>
     3a4:	5d c0       	rjmp	.+186    	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
     3a6:	52 c0       	rjmp	.+164    	; 0x44c <EVENT_USB_Device_ControlRequest+0xe2>
    {
        case HID_REQ_GetReport:
            if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     3a8:	80 91 2e 01 	lds	r24, 0x012E
     3ac:	81 3a       	cpi	r24, 0xA1	; 161
     3ae:	09 f0       	breq	.+2      	; 0x3b2 <EVENT_USB_Device_ControlRequest+0x48>
     3b0:	57 c0       	rjmp	.+174    	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
            {
                uint8_t GenericData[GENERIC_REPORT_SIZE];
                CreateGenericHIDReport(GenericData);
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5f       	subi	r16, 0xFF	; 255
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	c8 01       	movw	r24, r16
     3ba:	1a df       	rcall	.-460    	; 0x1f0 <CreateGenericHIDReport>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     3bc:	80 91 e8 00 	lds	r24, 0x00E8
     3c0:	87 7f       	andi	r24, 0xF7	; 247
     3c2:	80 93 e8 00 	sts	0x00E8, r24

                Endpoint_ClearSETUP();

                /* Write the report data to the control endpoint */
                Endpoint_Write_Control_Stream_LE(&GenericData, sizeof(GenericData));
     3c6:	c8 01       	movw	r24, r16
     3c8:	68 e0       	ldi	r22, 0x08	; 8
     3ca:	70 e0       	ldi	r23, 0x00	; 0
     3cc:	26 c0       	rjmp	.+76     	; 0x41a <EVENT_USB_Device_ControlRequest+0xb0>
                Endpoint_ClearOUT();
            }

            break;
        case HID_REQ_SetReport:
            if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     3ce:	80 91 2e 01 	lds	r24, 0x012E
     3d2:	81 32       	cpi	r24, 0x21	; 33
     3d4:	09 f0       	breq	.+2      	; 0x3d8 <EVENT_USB_Device_ControlRequest+0x6e>
     3d6:	44 c0       	rjmp	.+136    	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
     3d8:	80 91 e8 00 	lds	r24, 0x00E8
     3dc:	87 7f       	andi	r24, 0xF7	; 247
     3de:	80 93 e8 00 	sts	0x00E8, r24
                uint8_t GenericData[GENERIC_REPORT_SIZE];

                Endpoint_ClearSETUP();

                /* Read the report data from the control endpoint */
                Endpoint_Read_Control_Stream_LE(&GenericData, sizeof(GenericData));
     3e2:	8e 01       	movw	r16, r28
     3e4:	0f 5f       	subi	r16, 0xFF	; 255
     3e6:	1f 4f       	sbci	r17, 0xFF	; 255
     3e8:	c8 01       	movw	r24, r16
     3ea:	68 e0       	ldi	r22, 0x08	; 8
     3ec:	70 e0       	ldi	r23, 0x00	; 0
     3ee:	99 d4       	rcall	.+2354   	; 0xd22 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     3f0:	80 91 e8 00 	lds	r24, 0x00E8
     3f4:	8e 77       	andi	r24, 0x7E	; 126
     3f6:	80 93 e8 00 	sts	0x00E8, r24
                Endpoint_ClearIN();

                ProcessGenericHIDReport(GenericData);
     3fa:	c8 01       	movw	r24, r16
     3fc:	e8 de       	rcall	.-560    	; 0x1ce <ProcessGenericHIDReport>
     3fe:	30 c0       	rjmp	.+96     	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
            }

            break;
        case CDC_REQ_GetLineEncoding:
            if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     400:	80 91 2e 01 	lds	r24, 0x012E
     404:	81 3a       	cpi	r24, 0xA1	; 161
     406:	61 f5       	brne	.+88     	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     408:	80 91 e8 00 	lds	r24, 0x00E8
     40c:	87 7f       	andi	r24, 0xF7	; 247
     40e:	80 93 e8 00 	sts	0x00E8, r24
            {
                Endpoint_ClearSETUP();

                /* Write the line coding data to the control endpoint */
                Endpoint_Write_Control_Stream_LE(&LineEncodingData, sizeof(CDC_LineEncoding_t));
     412:	85 e1       	ldi	r24, 0x15	; 21
     414:	91 e0       	ldi	r25, 0x01	; 1
     416:	67 e0       	ldi	r22, 0x07	; 7
     418:	70 e0       	ldi	r23, 0x00	; 0
     41a:	25 d4       	rcall	.+2122   	; 0xc66 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     41c:	80 91 e8 00 	lds	r24, 0x00E8
     420:	8b 77       	andi	r24, 0x7B	; 123
     422:	80 93 e8 00 	sts	0x00E8, r24
     426:	1c c0       	rjmp	.+56     	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
                Endpoint_ClearOUT();
            }

            break;
        case CDC_REQ_SetLineEncoding:
            if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     428:	80 91 2e 01 	lds	r24, 0x012E
     42c:	81 32       	cpi	r24, 0x21	; 33
     42e:	c1 f4       	brne	.+48     	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     430:	80 91 e8 00 	lds	r24, 0x00E8
     434:	87 7f       	andi	r24, 0xF7	; 247
     436:	80 93 e8 00 	sts	0x00E8, r24
            {
                Endpoint_ClearSETUP();

                /* Read the line coding data in from the host into the global struct */
                Endpoint_Read_Control_Stream_LE(&LineEncodingData, sizeof(CDC_LineEncoding_t));
     43a:	85 e1       	ldi	r24, 0x15	; 21
     43c:	91 e0       	ldi	r25, 0x01	; 1
     43e:	67 e0       	ldi	r22, 0x07	; 7
     440:	70 e0       	ldi	r23, 0x00	; 0
     442:	6f d4       	rcall	.+2270   	; 0xd22 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     444:	80 91 e8 00 	lds	r24, 0x00E8
     448:	8e 77       	andi	r24, 0x7E	; 126
     44a:	eb cf       	rjmp	.-42     	; 0x422 <EVENT_USB_Device_ControlRequest+0xb8>
                Endpoint_ClearIN();
            }

            break;
        case CDC_REQ_SetControlLineState:
            if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     44c:	80 91 2e 01 	lds	r24, 0x012E
     450:	81 32       	cpi	r24, 0x21	; 33
     452:	31 f4       	brne	.+12     	; 0x460 <EVENT_USB_Device_ControlRequest+0xf6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     454:	80 91 e8 00 	lds	r24, 0x00E8
     458:	87 7f       	andi	r24, 0xF7	; 247
     45a:	80 93 e8 00 	sts	0x00E8, r24
            {
                Endpoint_ClearSETUP();
                Endpoint_ClearStatusStage();
     45e:	02 d1       	rcall	.+516    	; 0x664 <Endpoint_ClearStatusStage>
                */
            }

            break;
    }
}
     460:	28 96       	adiw	r28, 0x08	; 8
     462:	0f b6       	in	r0, 0x3f	; 63
     464:	f8 94       	cli
     466:	de bf       	out	0x3e, r29	; 62
     468:	0f be       	out	0x3f, r0	; 63
     46a:	cd bf       	out	0x3d, r28	; 61
     46c:	cf 91       	pop	r28
     46e:	df 91       	pop	r29
     470:	1f 91       	pop	r17
     472:	0f 91       	pop	r16
     474:	08 95       	ret

00000476 <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the keyboard and mouse device endpoints.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     476:	ef 92       	push	r14
     478:	ff 92       	push	r15
     47a:	0f 93       	push	r16
     47c:	1f 93       	push	r17
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	61 ec       	ldi	r22, 0xC1	; 193
     482:	42 e0       	ldi	r20, 0x02	; 2
     484:	ba d0       	rcall	.+372    	; 0x5fa <Endpoint_ConfigureEndpoint_Prv>
     486:	08 2f       	mov	r16, r24
    //* Setup CDC Data Endpoints */
    ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
                                                CDC_NOTIFICATION_EPSIZE, ENDPOINT_BANK_SINGLE);
    ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_TX_EPNUM, EP_TYPE_BULK, ENDPOINT_DIR_IN,
                                                CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
    ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPNUM, EP_TYPE_BULK, ENDPOINT_DIR_OUT,
     488:	82 e0       	ldi	r24, 0x02	; 2
     48a:	61 e8       	ldi	r22, 0x81	; 129
     48c:	42 e1       	ldi	r20, 0x12	; 18
     48e:	b5 d0       	rcall	.+362    	; 0x5fa <Endpoint_ConfigureEndpoint_Prv>
     490:	e8 2e       	mov	r14, r24
     492:	83 e0       	ldi	r24, 0x03	; 3
     494:	60 e8       	ldi	r22, 0x80	; 128
     496:	42 e1       	ldi	r20, 0x12	; 18
     498:	b0 d0       	rcall	.+352    	; 0x5fa <Endpoint_ConfigureEndpoint_Prv>
     49a:	10 e0       	ldi	r17, 0x00	; 0
     49c:	ff 24       	eor	r15, r15
     49e:	0e 21       	and	r16, r14
     4a0:	1f 21       	and	r17, r15
     4a2:	01 70       	andi	r16, 0x01	; 1
     4a4:	10 70       	andi	r17, 0x00	; 0
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	08 23       	and	r16, r24
     4aa:	19 23       	and	r17, r25
                                                CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);

    /* Reset line encoding baud rate so that the host knows to send new values */
    LineEncodingData.BaudRateBPS = 0;
     4ac:	10 92 15 01 	sts	0x0115, r1
     4b0:	10 92 16 01 	sts	0x0116, r1
     4b4:	10 92 17 01 	sts	0x0117, r1
     4b8:	10 92 18 01 	sts	0x0118, r1
     4bc:	81 e0       	ldi	r24, 0x01	; 1
     4be:	61 ec       	ldi	r22, 0xC1	; 193
     4c0:	42 e0       	ldi	r20, 0x02	; 2
     4c2:	9b d0       	rcall	.+310    	; 0x5fa <Endpoint_ConfigureEndpoint_Prv>

    /* Setup HID Report Endpoints */
    ConfigSuccess &= Endpoint_ConfigureEndpoint(GENERIC_IN_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
     4c4:	20 e0       	ldi	r18, 0x00	; 0
     4c6:	30 e0       	ldi	r19, 0x00	; 0
     4c8:	01 2b       	or	r16, r17
     4ca:	11 f0       	breq	.+4      	; 0x4d0 <EVENT_USB_Device_ConfigurationChanged+0x5a>
     4cc:	21 e0       	ldi	r18, 0x01	; 1
     4ce:	30 e0       	ldi	r19, 0x00	; 0
     4d0:	08 2f       	mov	r16, r24
     4d2:	10 e0       	ldi	r17, 0x00	; 0
     4d4:	02 23       	and	r16, r18
     4d6:	13 23       	and	r17, r19
     4d8:	82 e0       	ldi	r24, 0x02	; 2
     4da:	60 ec       	ldi	r22, 0xC0	; 192
     4dc:	42 e0       	ldi	r20, 0x02	; 2
     4de:	8d d0       	rcall	.+282    	; 0x5fa <Endpoint_ConfigureEndpoint_Prv>
                                                GENERIC_EPSIZE, ENDPOINT_BANK_SINGLE);
    ConfigSuccess &= Endpoint_ConfigureEndpoint(GENERIC_OUT_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_OUT,
                                                GENERIC_EPSIZE, ENDPOINT_BANK_SINGLE);

    /* Indicate endpoint configuration success or failure */
    LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     4e0:	20 e0       	ldi	r18, 0x00	; 0
     4e2:	30 e0       	ldi	r19, 0x00	; 0
     4e4:	01 2b       	or	r16, r17
     4e6:	11 f0       	breq	.+4      	; 0x4ec <EVENT_USB_Device_ConfigurationChanged+0x76>
     4e8:	21 e0       	ldi	r18, 0x01	; 1
     4ea:	30 e0       	ldi	r19, 0x00	; 0
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	28 23       	and	r18, r24
     4f0:	39 23       	and	r19, r25
     4f2:	23 2b       	or	r18, r19
     4f4:	11 f4       	brne	.+4      	; 0x4fa <EVENT_USB_Device_ConfigurationChanged+0x84>
     4f6:	90 e2       	ldi	r25, 0x20	; 32
     4f8:	01 c0       	rjmp	.+2      	; 0x4fc <EVENT_USB_Device_ConfigurationChanged+0x86>
     4fa:	90 e4       	ldi	r25, 0x40	; 64
     4fc:	81 b3       	in	r24, 0x11	; 17
     4fe:	8f 71       	andi	r24, 0x1F	; 31
     500:	98 2b       	or	r25, r24
     502:	91 bb       	out	0x11, r25	; 17
}
     504:	1f 91       	pop	r17
     506:	0f 91       	pop	r16
     508:	ff 90       	pop	r15
     50a:	ef 90       	pop	r14
     50c:	08 95       	ret

0000050e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
    /* Disable watchdog if enabled by bootloader/fuses */
    MCUSR &= ~(1 << WDRF);
     50e:	84 b7       	in	r24, 0x34	; 52
     510:	87 7f       	andi	r24, 0xF7	; 247
     512:	84 bf       	out	0x34, r24	; 52
    wdt_disable();
     514:	88 e1       	ldi	r24, 0x18	; 24
     516:	0f b6       	in	r0, 0x3f	; 63
     518:	f8 94       	cli
     51a:	80 93 60 00 	sts	0x0060, r24
     51e:	10 92 60 00 	sts	0x0060, r1
     522:	0f be       	out	0x3f, r0	; 63

    /* Disable clock division */
    //clock_prescale_set(clock_div_1);
        CPU_PRESCALE(CPU_8MHz); // 3.3v AVR shouldn't run faster than 8MHz
     524:	e1 e6       	ldi	r30, 0x61	; 97
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	80 e8       	ldi	r24, 0x80	; 128
     52a:	80 83       	st	Z, r24
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	80 83       	st	Z, r24

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS_D;
     530:	56 9a       	sbi	0x0a, 6	; 10
				DDRF  |=  LEDS_ALL_LEDS_F;
     532:	80 b3       	in	r24, 0x10	; 16
     534:	80 6e       	ori	r24, 0xE0	; 224
     536:	80 bb       	out	0x10, r24	; 16
				PORTF &= ~LEDS_ALL_LEDS_F;
     538:	81 b3       	in	r24, 0x11	; 17
     53a:	8f 71       	andi	r24, 0x1F	; 31
     53c:	81 bb       	out	0x11, r24	; 17

    /* Hardware Initialization */
    LEDs_Init();
    USB_Init();
}
     53e:	2e c1       	rjmp	.+604    	; 0x79c <USB_Init>

00000540 <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
    SetupHardware();
     540:	e6 df       	rcall	.-52     	; 0x50e <SetupHardware>
				PORTF &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTF = ((PORTF & ~LEDS_ALL_LEDS_F) | LEDMask);
     542:	81 b3       	in	r24, 0x11	; 17
     544:	8f 71       	andi	r24, 0x1F	; 31
     546:	80 66       	ori	r24, 0x60	; 96
     548:	81 bb       	out	0x11, r24	; 17

    LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
    sei();
     54a:	78 94       	sei

    for (;;)
    {
        CDC_Task();
     54c:	af de       	rcall	.-674    	; 0x2ac <CDC_Task>
        HID_Task();
     54e:	61 de       	rcall	.-830    	; 0x212 <HID_Task>
        USB_USBTask();
     550:	2e d5       	rcall	.+2652   	; 0xfae <USB_USBTask>
        counter++;
     552:	80 91 1c 01 	lds	r24, 0x011C
     556:	90 91 1d 01 	lds	r25, 0x011D
     55a:	a0 91 1e 01 	lds	r26, 0x011E
     55e:	b0 91 1f 01 	lds	r27, 0x011F
     562:	01 96       	adiw	r24, 0x01	; 1
     564:	a1 1d       	adc	r26, r1
     566:	b1 1d       	adc	r27, r1
     568:	80 93 1c 01 	sts	0x011C, r24
     56c:	90 93 1d 01 	sts	0x011D, r25
     570:	a0 93 1e 01 	sts	0x011E, r26
     574:	b0 93 1f 01 	sts	0x011F, r27
     578:	e9 cf       	rjmp	.-46     	; 0x54c <main+0xc>

0000057a <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     57a:	da 01       	movw	r26, r20
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType)
     57c:	93 30       	cpi	r25, 0x03	; 3
     57e:	b1 f0       	breq	.+44     	; 0x5ac <CALLBACK_USB_GetDescriptor+0x32>
     580:	94 30       	cpi	r25, 0x04	; 4
     582:	28 f4       	brcc	.+10     	; 0x58e <CALLBACK_USB_GetDescriptor+0x14>
     584:	91 30       	cpi	r25, 0x01	; 1
     586:	41 f0       	breq	.+16     	; 0x598 <CALLBACK_USB_GetDescriptor+0x1e>
     588:	92 30       	cpi	r25, 0x02	; 2
     58a:	79 f5       	brne	.+94     	; 0x5ea <CALLBACK_USB_GetDescriptor+0x70>
     58c:	0a c0       	rjmp	.+20     	; 0x5a2 <CALLBACK_USB_GetDescriptor+0x28>
     58e:	91 32       	cpi	r25, 0x21	; 33
     590:	11 f1       	breq	.+68     	; 0x5d6 <CALLBACK_USB_GetDescriptor+0x5c>
     592:	92 32       	cpi	r25, 0x22	; 34
     594:	51 f5       	brne	.+84     	; 0x5ea <CALLBACK_USB_GetDescriptor+0x70>
     596:	24 c0       	rjmp	.+72     	; 0x5e0 <CALLBACK_USB_GetDescriptor+0x66>
     598:	e8 eb       	ldi	r30, 0xB8	; 184
     59a:	f0 e0       	ldi	r31, 0x00	; 0
     59c:	22 e1       	ldi	r18, 0x12	; 18
     59e:	30 e0       	ldi	r19, 0x00	; 0
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <CALLBACK_USB_GetDescriptor+0x78>
     5a2:	ea ec       	ldi	r30, 0xCA	; 202
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
     5a6:	26 e6       	ldi	r18, 0x66	; 102
     5a8:	30 e0       	ldi	r19, 0x00	; 0
     5aa:	23 c0       	rjmp	.+70     	; 0x5f2 <CALLBACK_USB_GetDescriptor+0x78>
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
            Size    = sizeof(USB_Descriptor_Configuration_t);
            break;
        case DTYPE_String:
            switch (DescriptorNumber)
     5ac:	81 30       	cpi	r24, 0x01	; 1
     5ae:	49 f0       	breq	.+18     	; 0x5c2 <CALLBACK_USB_GetDescriptor+0x48>
     5b0:	81 30       	cpi	r24, 0x01	; 1
     5b2:	18 f0       	brcs	.+6      	; 0x5ba <CALLBACK_USB_GetDescriptor+0x40>
     5b4:	82 30       	cpi	r24, 0x02	; 2
     5b6:	c9 f4       	brne	.+50     	; 0x5ea <CALLBACK_USB_GetDescriptor+0x70>
     5b8:	0a c0       	rjmp	.+20     	; 0x5ce <CALLBACK_USB_GetDescriptor+0x54>
            {
                case 0x00:
                    Address = &LanguageString;
                    Size    = pgm_read_byte(&LanguageString.Header.Size);
     5ba:	e0 e3       	ldi	r30, 0x30	; 48
     5bc:	f1 e0       	ldi	r31, 0x01	; 1
     5be:	84 91       	lpm	r24, Z+
     5c0:	03 c0       	rjmp	.+6      	; 0x5c8 <CALLBACK_USB_GetDescriptor+0x4e>
                    break;
                case 0x01:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     5c2:	e4 e3       	ldi	r30, 0x34	; 52
     5c4:	f1 e0       	ldi	r31, 0x01	; 1
     5c6:	84 91       	lpm	r24, Z+
     5c8:	28 2f       	mov	r18, r24
     5ca:	30 e0       	ldi	r19, 0x00	; 0
     5cc:	12 c0       	rjmp	.+36     	; 0x5f2 <CALLBACK_USB_GetDescriptor+0x78>
                    break;
                case 0x02:
                    Address = &ProductString;
                    Size    = pgm_read_byte(&ProductString.Header.Size);
     5ce:	e0 e5       	ldi	r30, 0x50	; 80
     5d0:	f1 e0       	ldi	r31, 0x01	; 1
     5d2:	84 91       	lpm	r24, Z+
     5d4:	f9 cf       	rjmp	.-14     	; 0x5c8 <CALLBACK_USB_GetDescriptor+0x4e>
     5d6:	e9 e1       	ldi	r30, 0x19	; 25
     5d8:	f1 e0       	ldi	r31, 0x01	; 1
     5da:	29 e0       	ldi	r18, 0x09	; 9
     5dc:	30 e0       	ldi	r19, 0x00	; 0
     5de:	09 c0       	rjmp	.+18     	; 0x5f2 <CALLBACK_USB_GetDescriptor+0x78>

            break;
        case HID_DTYPE_HID:
            Address = &ConfigurationDescriptor.HID_GenericHID;
            Size    = sizeof(USB_HID_Descriptor_HID_t);
            break;
     5e0:	e8 e9       	ldi	r30, 0x98	; 152
     5e2:	f0 e0       	ldi	r31, 0x00	; 0
     5e4:	20 e2       	ldi	r18, 0x20	; 32
     5e6:	30 e0       	ldi	r19, 0x00	; 0
     5e8:	04 c0       	rjmp	.+8      	; 0x5f2 <CALLBACK_USB_GetDescriptor+0x78>
     5ea:	e0 e0       	ldi	r30, 0x00	; 0
     5ec:	f0 e0       	ldi	r31, 0x00	; 0
     5ee:	20 e0       	ldi	r18, 0x00	; 0
     5f0:	30 e0       	ldi	r19, 0x00	; 0
            Address = &GenericReport;
            Size    = sizeof(GenericReport);
            break;
    }

    *DescriptorAddress = Address;
     5f2:	ed 93       	st	X+, r30
     5f4:	fc 93       	st	X, r31
    return Size;
}
     5f6:	c9 01       	movw	r24, r18
     5f8:	08 95       	ret

000005fa <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
     5fa:	38 2f       	mov	r19, r24
     5fc:	28 2f       	mov	r18, r24
     5fe:	2c c0       	rjmp	.+88     	; 0x658 <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     600:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
     604:	23 17       	cp	r18, r19
     606:	21 f4       	brne	.+8      	; 0x610 <Endpoint_ConfigureEndpoint_Prv+0x16>
     608:	76 2f       	mov	r23, r22
     60a:	94 2f       	mov	r25, r20
     60c:	50 e0       	ldi	r21, 0x00	; 0
     60e:	06 c0       	rjmp	.+12     	; 0x61c <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
     610:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
     614:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
     618:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
     61c:	91 ff       	sbrs	r25, 1
     61e:	1b c0       	rjmp	.+54     	; 0x656 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
     620:	80 91 eb 00 	lds	r24, 0x00EB
     624:	8e 7f       	andi	r24, 0xFE	; 254
     626:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= (1 << ALLOC);
     62a:	80 91 ed 00 	lds	r24, 0x00ED
     62e:	82 70       	andi	r24, 0x02	; 2
     630:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
     634:	80 91 eb 00 	lds	r24, 0x00EB
     638:	81 60       	ori	r24, 0x01	; 1
     63a:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
     63e:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
     642:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
     646:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
     64a:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
     64e:	87 fd       	sbrc	r24, 7
     650:	02 c0       	rjmp	.+4      	; 0x656 <Endpoint_ConfigureEndpoint_Prv+0x5c>
     652:	80 e0       	ldi	r24, 0x00	; 0
     654:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
     656:	2f 5f       	subi	r18, 0xFF	; 255
     658:	27 30       	cpi	r18, 0x07	; 7
     65a:	90 f2       	brcs	.-92     	; 0x600 <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     65c:	30 93 e9 00 	sts	0x00E9, r19
     660:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
     662:	08 95       	ret

00000664 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
     664:	80 91 2e 01 	lds	r24, 0x012E
     668:	88 23       	and	r24, r24
     66a:	9c f4       	brge	.+38     	; 0x692 <Endpoint_ClearStatusStage+0x2e>
     66c:	04 c0       	rjmp	.+8      	; 0x676 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
     66e:	80 91 2d 01 	lds	r24, 0x012D
     672:	88 23       	and	r24, r24
     674:	b9 f0       	breq	.+46     	; 0x6a4 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     676:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
     67a:	82 ff       	sbrs	r24, 2
     67c:	f8 cf       	rjmp	.-16     	; 0x66e <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     67e:	80 91 e8 00 	lds	r24, 0x00E8
     682:	8b 77       	andi	r24, 0x7B	; 123
     684:	80 93 e8 00 	sts	0x00E8, r24
     688:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
     68a:	80 91 2d 01 	lds	r24, 0x012D
     68e:	88 23       	and	r24, r24
     690:	49 f0       	breq	.+18     	; 0x6a4 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     692:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
     696:	80 ff       	sbrs	r24, 0
     698:	f8 cf       	rjmp	.-16     	; 0x68a <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     69a:	80 91 e8 00 	lds	r24, 0x00E8
     69e:	8e 77       	andi	r24, 0x7E	; 126
     6a0:	80 93 e8 00 	sts	0x00E8, r24
     6a4:	08 95       	ret

000006a6 <Endpoint_WaitUntilReady>:
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
     6a6:	40 91 e4 00 	lds	r20, 0x00E4
     6aa:	50 91 e5 00 	lds	r21, 0x00E5
     6ae:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
     6b0:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
     6b4:	80 ff       	sbrs	r24, 0
     6b6:	05 c0       	rjmp	.+10     	; 0x6c2 <Endpoint_WaitUntilReady+0x1c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     6b8:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
     6bc:	80 ff       	sbrs	r24, 0
     6be:	05 c0       	rjmp	.+10     	; 0x6ca <Endpoint_WaitUntilReady+0x24>
     6c0:	22 c0       	rjmp	.+68     	; 0x706 <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     6c2:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
     6c6:	82 fd       	sbrc	r24, 2
     6c8:	1e c0       	rjmp	.+60     	; 0x706 <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     6ca:	80 91 2d 01 	lds	r24, 0x012D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     6ce:	88 23       	and	r24, r24
     6d0:	11 f4       	brne	.+4      	; 0x6d6 <Endpoint_WaitUntilReady+0x30>
     6d2:	82 e0       	ldi	r24, 0x02	; 2
     6d4:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     6d6:	85 30       	cpi	r24, 0x05	; 5
     6d8:	11 f4       	brne	.+4      	; 0x6de <Endpoint_WaitUntilReady+0x38>
     6da:	83 e0       	ldi	r24, 0x03	; 3
     6dc:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
     6de:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
     6e2:	85 ff       	sbrs	r24, 5
     6e4:	02 c0       	rjmp	.+4      	; 0x6ea <Endpoint_WaitUntilReady+0x44>
     6e6:	81 e0       	ldi	r24, 0x01	; 1
     6e8:	08 95       	ret
     6ea:	80 91 e4 00 	lds	r24, 0x00E4
     6ee:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
     6f2:	84 17       	cp	r24, r20
     6f4:	95 07       	cpc	r25, r21
     6f6:	e1 f2       	breq	.-72     	; 0x6b0 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
     6f8:	22 23       	and	r18, r18
     6fa:	11 f4       	brne	.+4      	; 0x700 <Endpoint_WaitUntilReady+0x5a>
     6fc:	84 e0       	ldi	r24, 0x04	; 4
     6fe:	08 95       	ret
     700:	21 50       	subi	r18, 0x01	; 1
     702:	ac 01       	movw	r20, r24
     704:	d5 cf       	rjmp	.-86     	; 0x6b0 <Endpoint_WaitUntilReady+0xa>
     706:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
     708:	08 95       	ret

0000070a <USB_ResetInterface>:

void USB_ResetInterface(void)
{
     70a:	ef 92       	push	r14
     70c:	ff 92       	push	r15
     70e:	0f 93       	push	r16
     710:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
     712:	4d d0       	rcall	.+154    	; 0x7ae <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
     714:	54 d0       	rcall	.+168    	; 0x7be <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
     716:	08 ed       	ldi	r16, 0xD8	; 216
     718:	10 e0       	ldi	r17, 0x00	; 0
     71a:	f8 01       	movw	r30, r16
     71c:	80 81       	ld	r24, Z

				USBCON = (Temp & ~(1 << USBE));
     71e:	98 2f       	mov	r25, r24
     720:	9f 77       	andi	r25, 0x7F	; 127
     722:	90 83       	st	Z, r25
				USBCON = (Temp |  (1 << USBE));
     724:	80 68       	ori	r24, 0x80	; 128
     726:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
     728:	80 81       	ld	r24, Z
     72a:	8f 7d       	andi	r24, 0xDF	; 223
     72c:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
     72e:	e7 ed       	ldi	r30, 0xD7	; 215
     730:	f0 e0       	ldi	r31, 0x00	; 0
     732:	80 81       	ld	r24, Z
     734:	80 68       	ori	r24, 0x80	; 128
     736:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
     738:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState          = DEVICE_STATE_Unattached;
     73a:	10 92 2d 01 	sts	0x012D, r1
	USB_ConfigurationNumber  = 0;
     73e:	10 92 2b 01 	sts	0x012B, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
     742:	10 92 2a 01 	sts	0x012A, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
     746:	10 92 29 01 	sts	0x0129, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
     74a:	80 ee       	ldi	r24, 0xE0	; 224
     74c:	e8 2e       	mov	r14, r24
     74e:	f1 2c       	mov	r15, r1
     750:	f7 01       	movw	r30, r14
     752:	80 81       	ld	r24, Z
     754:	8b 7f       	andi	r24, 0xFB	; 251
     756:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
     758:	f8 01       	movw	r30, r16
     75a:	80 81       	ld	r24, Z
     75c:	81 60       	ori	r24, 0x01	; 1
     75e:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
     760:	80 e0       	ldi	r24, 0x00	; 0
     762:	60 e0       	ldi	r22, 0x00	; 0
     764:	42 e0       	ldi	r20, 0x02	; 2
     766:	49 df       	rcall	.-366    	; 0x5fa <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
     768:	e1 ee       	ldi	r30, 0xE1	; 225
     76a:	f0 e0       	ldi	r31, 0x00	; 0
     76c:	80 81       	ld	r24, Z
     76e:	8e 7f       	andi	r24, 0xFE	; 254
     770:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
     772:	e2 ee       	ldi	r30, 0xE2	; 226
     774:	f0 e0       	ldi	r31, 0x00	; 0
     776:	80 81       	ld	r24, Z
     778:	81 60       	ori	r24, 0x01	; 1
     77a:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
     77c:	80 81       	ld	r24, Z
     77e:	88 60       	ori	r24, 0x08	; 8
     780:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
     782:	f7 01       	movw	r30, r14
     784:	80 81       	ld	r24, Z
     786:	8e 7f       	andi	r24, 0xFE	; 254
     788:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
     78a:	f8 01       	movw	r30, r16
     78c:	80 81       	ld	r24, Z
     78e:	80 61       	ori	r24, 0x10	; 16
     790:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
     792:	1f 91       	pop	r17
     794:	0f 91       	pop	r16
     796:	ff 90       	pop	r15
     798:	ef 90       	pop	r14
     79a:	08 95       	ret

0000079c <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
     79c:	e7 ed       	ldi	r30, 0xD7	; 215
     79e:	f0 e0       	ldi	r31, 0x00	; 0
     7a0:	80 81       	ld	r24, Z
     7a2:	81 60       	ori	r24, 0x01	; 1
     7a4:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	80 93 2c 01 	sts	0x012C, r24

	USB_ResetInterface();
}
     7ac:	ae cf       	rjmp	.-164    	; 0x70a <USB_ResetInterface>

000007ae <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
     7ae:	e8 ed       	ldi	r30, 0xD8	; 216
     7b0:	f0 e0       	ldi	r31, 0x00	; 0
     7b2:	80 81       	ld	r24, Z
     7b4:	8c 7f       	andi	r24, 0xFC	; 252
     7b6:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
     7b8:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
     7bc:	08 95       	ret

000007be <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
     7be:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
     7c2:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
     7c6:	08 95       	ret

000007c8 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
     7c8:	1f 92       	push	r1
     7ca:	0f 92       	push	r0
     7cc:	0f b6       	in	r0, 0x3f	; 63
     7ce:	0f 92       	push	r0
     7d0:	0b b6       	in	r0, 0x3b	; 59
     7d2:	0f 92       	push	r0
     7d4:	11 24       	eor	r1, r1
     7d6:	2f 93       	push	r18
     7d8:	3f 93       	push	r19
     7da:	4f 93       	push	r20
     7dc:	5f 93       	push	r21
     7de:	6f 93       	push	r22
     7e0:	7f 93       	push	r23
     7e2:	8f 93       	push	r24
     7e4:	9f 93       	push	r25
     7e6:	af 93       	push	r26
     7e8:	bf 93       	push	r27
     7ea:	ef 93       	push	r30
     7ec:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
     7ee:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
     7f2:	82 ff       	sbrs	r24, 2
     7f4:	0a c0       	rjmp	.+20     	; 0x80a <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
     7f6:	80 91 e2 00 	lds	r24, 0x00E2
     7fa:	82 ff       	sbrs	r24, 2
     7fc:	06 c0       	rjmp	.+12     	; 0x80a <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
     7fe:	80 91 e1 00 	lds	r24, 0x00E1
     802:	8b 7f       	andi	r24, 0xFB	; 251
     804:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
     808:	2d d2       	rcall	.+1114   	; 0xc64 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
     80a:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
     80e:	80 ff       	sbrs	r24, 0
     810:	1e c0       	rjmp	.+60     	; 0x84e <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
     812:	80 91 d8 00 	lds	r24, 0x00D8
     816:	80 ff       	sbrs	r24, 0
     818:	1a c0       	rjmp	.+52     	; 0x84e <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
     81a:	80 91 da 00 	lds	r24, 0x00DA
     81e:	8e 7f       	andi	r24, 0xFE	; 254
     820:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
     824:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
     828:	80 ff       	sbrs	r24, 0
     82a:	0d c0       	rjmp	.+26     	; 0x846 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
     82c:	84 e1       	ldi	r24, 0x14	; 20
     82e:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
     830:	89 b5       	in	r24, 0x29	; 41
     832:	82 60       	ori	r24, 0x02	; 2
     834:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
     836:	09 b4       	in	r0, 0x29	; 41
     838:	00 fe       	sbrs	r0, 0
     83a:	fd cf       	rjmp	.-6      	; 0x836 <__vector_10+0x6e>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	80 93 2d 01 	sts	0x012D, r24
			EVENT_USB_Device_Connect();
     842:	bb dc       	rcall	.-1674   	; 0x1ba <EVENT_USB_Device_Connect>
     844:	04 c0       	rjmp	.+8      	; 0x84e <__vector_10+0x86>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
     846:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
     848:	10 92 2d 01 	sts	0x012D, r1
			EVENT_USB_Device_Disconnect();
     84c:	bb dc       	rcall	.-1674   	; 0x1c4 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
     84e:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
     852:	80 ff       	sbrs	r24, 0
     854:	18 c0       	rjmp	.+48     	; 0x886 <__vector_10+0xbe>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
     856:	80 91 e2 00 	lds	r24, 0x00E2
     85a:	80 ff       	sbrs	r24, 0
     85c:	14 c0       	rjmp	.+40     	; 0x886 <__vector_10+0xbe>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
     85e:	80 91 e2 00 	lds	r24, 0x00E2
     862:	8e 7f       	andi	r24, 0xFE	; 254
     864:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
     868:	80 91 e2 00 	lds	r24, 0x00E2
     86c:	80 61       	ori	r24, 0x10	; 16
     86e:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
     872:	80 91 d8 00 	lds	r24, 0x00D8
     876:	80 62       	ori	r24, 0x20	; 32
     878:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
     87c:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
     87e:	85 e0       	ldi	r24, 0x05	; 5
     880:	80 93 2d 01 	sts	0x012D, r24
		EVENT_USB_Device_Suspend();
     884:	ef d1       	rcall	.+990    	; 0xc64 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
     886:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
     88a:	84 ff       	sbrs	r24, 4
     88c:	2e c0       	rjmp	.+92     	; 0x8ea <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
     88e:	80 91 e2 00 	lds	r24, 0x00E2
     892:	84 ff       	sbrs	r24, 4
     894:	2a c0       	rjmp	.+84     	; 0x8ea <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
     896:	84 e1       	ldi	r24, 0x14	; 20
     898:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
     89a:	89 b5       	in	r24, 0x29	; 41
     89c:	82 60       	ori	r24, 0x02	; 2
     89e:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
     8a0:	09 b4       	in	r0, 0x29	; 41
     8a2:	00 fe       	sbrs	r0, 0
     8a4:	fd cf       	rjmp	.-6      	; 0x8a0 <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
     8a6:	80 91 d8 00 	lds	r24, 0x00D8
     8aa:	8f 7d       	andi	r24, 0xDF	; 223
     8ac:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
     8b0:	80 91 e1 00 	lds	r24, 0x00E1
     8b4:	8f 7e       	andi	r24, 0xEF	; 239
     8b6:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
     8ba:	80 91 e2 00 	lds	r24, 0x00E2
     8be:	8f 7e       	andi	r24, 0xEF	; 239
     8c0:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
     8c4:	80 91 e2 00 	lds	r24, 0x00E2
     8c8:	81 60       	ori	r24, 0x01	; 1
     8ca:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_ConfigurationNumber)
     8ce:	80 91 2b 01 	lds	r24, 0x012B
     8d2:	88 23       	and	r24, r24
     8d4:	31 f4       	brne	.+12     	; 0x8e2 <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
     8d6:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
     8da:	87 fd       	sbrc	r24, 7
     8dc:	02 c0       	rjmp	.+4      	; 0x8e2 <__vector_10+0x11a>
     8de:	81 e0       	ldi	r24, 0x01	; 1
     8e0:	01 c0       	rjmp	.+2      	; 0x8e4 <__vector_10+0x11c>
     8e2:	84 e0       	ldi	r24, 0x04	; 4
     8e4:	80 93 2d 01 	sts	0x012D, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
     8e8:	bd d1       	rcall	.+890    	; 0xc64 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
     8ea:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
     8ee:	83 ff       	sbrs	r24, 3
     8f0:	22 c0       	rjmp	.+68     	; 0x936 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
     8f2:	80 91 e2 00 	lds	r24, 0x00E2
     8f6:	83 ff       	sbrs	r24, 3
     8f8:	1e c0       	rjmp	.+60     	; 0x936 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
     8fa:	80 91 e1 00 	lds	r24, 0x00E1
     8fe:	87 7f       	andi	r24, 0xF7	; 247
     900:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState         = DEVICE_STATE_Default;
     904:	82 e0       	ldi	r24, 0x02	; 2
     906:	80 93 2d 01 	sts	0x012D, r24
		USB_ConfigurationNumber = 0;
     90a:	10 92 2b 01 	sts	0x012B, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
     90e:	80 91 e1 00 	lds	r24, 0x00E1
     912:	8e 7f       	andi	r24, 0xFE	; 254
     914:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
     918:	80 91 e2 00 	lds	r24, 0x00E2
     91c:	8e 7f       	andi	r24, 0xFE	; 254
     91e:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
     922:	80 91 e2 00 	lds	r24, 0x00E2
     926:	80 61       	ori	r24, 0x10	; 16
     928:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	42 e0       	ldi	r20, 0x02	; 2
     932:	63 de       	rcall	.-826    	; 0x5fa <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
     934:	97 d1       	rcall	.+814    	; 0xc64 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
     936:	ff 91       	pop	r31
     938:	ef 91       	pop	r30
     93a:	bf 91       	pop	r27
     93c:	af 91       	pop	r26
     93e:	9f 91       	pop	r25
     940:	8f 91       	pop	r24
     942:	7f 91       	pop	r23
     944:	6f 91       	pop	r22
     946:	5f 91       	pop	r21
     948:	4f 91       	pop	r20
     94a:	3f 91       	pop	r19
     94c:	2f 91       	pop	r18
     94e:	0f 90       	pop	r0
     950:	0b be       	out	0x3b, r0	; 59
     952:	0f 90       	pop	r0
     954:	0f be       	out	0x3f, r0	; 63
     956:	0f 90       	pop	r0
     958:	1f 90       	pop	r1
     95a:	18 95       	reti

0000095c <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
     95c:	0f 93       	push	r16
     95e:	1f 93       	push	r17
     960:	df 93       	push	r29
     962:	cf 93       	push	r28
     964:	cd b7       	in	r28, 0x3d	; 61
     966:	de b7       	in	r29, 0x3e	; 62
     968:	ac 97       	sbiw	r28, 0x2c	; 44
     96a:	0f b6       	in	r0, 0x3f	; 63
     96c:	f8 94       	cli
     96e:	de bf       	out	0x3e, r29	; 62
     970:	0f be       	out	0x3f, r0	; 63
     972:	cd bf       	out	0x3d, r28	; 61
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
     974:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bmRequestType = Endpoint_Read_8();
     978:	80 93 2e 01 	sts	0x012E, r24
     97c:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
     980:	80 93 2f 01 	sts	0x012F, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
     984:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
     988:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
     98c:	e0 e3       	ldi	r30, 0x30	; 48
     98e:	f1 e0       	ldi	r31, 0x01	; 1
     990:	80 93 30 01 	sts	0x0130, r24
     994:	90 93 31 01 	sts	0x0131, r25
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
     998:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
     99c:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
     9a0:	80 93 32 01 	sts	0x0132, r24
     9a4:	93 83       	std	Z+3, r25	; 0x03
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
     9a6:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
     9aa:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
     9ae:	80 93 34 01 	sts	0x0134, r24
     9b2:	95 83       	std	Z+5, r25	; 0x05

	EVENT_USB_Device_ControlRequest();
     9b4:	da dc       	rcall	.-1612   	; 0x36a <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
     9b6:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
     9ba:	83 ff       	sbrs	r24, 3
     9bc:	3a c1       	rjmp	.+628    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
     9be:	80 91 2e 01 	lds	r24, 0x012E

		switch (USB_ControlRequest.bRequest)
     9c2:	30 91 2f 01 	lds	r19, 0x012F
     9c6:	35 30       	cpi	r19, 0x05	; 5
     9c8:	09 f4       	brne	.+2      	; 0x9cc <USB_Device_ProcessControlRequest+0x70>
     9ca:	87 c0       	rjmp	.+270    	; 0xada <USB_Device_ProcessControlRequest+0x17e>
     9cc:	36 30       	cpi	r19, 0x06	; 6
     9ce:	40 f4       	brcc	.+16     	; 0x9e0 <USB_Device_ProcessControlRequest+0x84>
     9d0:	31 30       	cpi	r19, 0x01	; 1
     9d2:	c9 f1       	breq	.+114    	; 0xa46 <USB_Device_ProcessControlRequest+0xea>
     9d4:	31 30       	cpi	r19, 0x01	; 1
     9d6:	70 f0       	brcs	.+28     	; 0x9f4 <USB_Device_ProcessControlRequest+0x98>
     9d8:	33 30       	cpi	r19, 0x03	; 3
     9da:	09 f0       	breq	.+2      	; 0x9de <USB_Device_ProcessControlRequest+0x82>
     9dc:	2a c1       	rjmp	.+596    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
     9de:	33 c0       	rjmp	.+102    	; 0xa46 <USB_Device_ProcessControlRequest+0xea>
     9e0:	38 30       	cpi	r19, 0x08	; 8
     9e2:	09 f4       	brne	.+2      	; 0x9e6 <USB_Device_ProcessControlRequest+0x8a>
     9e4:	f8 c0       	rjmp	.+496    	; 0xbd6 <USB_Device_ProcessControlRequest+0x27a>
     9e6:	39 30       	cpi	r19, 0x09	; 9
     9e8:	09 f4       	brne	.+2      	; 0x9ec <USB_Device_ProcessControlRequest+0x90>
     9ea:	07 c1       	rjmp	.+526    	; 0xbfa <USB_Device_ProcessControlRequest+0x29e>
     9ec:	36 30       	cpi	r19, 0x06	; 6
     9ee:	09 f0       	breq	.+2      	; 0x9f2 <USB_Device_ProcessControlRequest+0x96>
     9f0:	20 c1       	rjmp	.+576    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
     9f2:	99 c0       	rjmp	.+306    	; 0xb26 <USB_Device_ProcessControlRequest+0x1ca>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     9f4:	80 38       	cpi	r24, 0x80	; 128
     9f6:	21 f0       	breq	.+8      	; 0xa00 <USB_Device_ProcessControlRequest+0xa4>
     9f8:	82 38       	cpi	r24, 0x82	; 130
     9fa:	09 f0       	breq	.+2      	; 0x9fe <USB_Device_ProcessControlRequest+0xa2>
     9fc:	1a c1       	rjmp	.+564    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
     9fe:	08 c0       	rjmp	.+16     	; 0xa10 <USB_Device_ProcessControlRequest+0xb4>
     a00:	90 91 29 01 	lds	r25, 0x0129
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_RemoteWakeupEnabled)
     a04:	80 91 2a 01 	lds	r24, 0x012A
     a08:	88 23       	and	r24, r24
     a0a:	99 f0       	breq	.+38     	; 0xa32 <USB_Device_ProcessControlRequest+0xd6>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
     a0c:	92 60       	ori	r25, 0x02	; 2
     a0e:	11 c0       	rjmp	.+34     	; 0xa32 <USB_Device_ProcessControlRequest+0xd6>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
     a10:	80 91 32 01 	lds	r24, 0x0132
     a14:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     a16:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
     a1a:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
     a1e:	90 e0       	ldi	r25, 0x00	; 0
     a20:	25 e0       	ldi	r18, 0x05	; 5
     a22:	96 95       	lsr	r25
     a24:	87 95       	ror	r24
     a26:	2a 95       	dec	r18
     a28:	e1 f7       	brne	.-8      	; 0xa22 <USB_Device_ProcessControlRequest+0xc6>
     a2a:	98 2f       	mov	r25, r24
     a2c:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     a2e:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     a32:	80 91 e8 00 	lds	r24, 0x00E8
     a36:	87 7f       	andi	r24, 0xF7	; 247
     a38:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
     a3c:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
     a40:	10 92 f1 00 	sts	0x00F1, r1
     a44:	d3 c0       	rjmp	.+422    	; 0xbec <USB_Device_ProcessControlRequest+0x290>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     a46:	88 23       	and	r24, r24
     a48:	19 f0       	breq	.+6      	; 0xa50 <USB_Device_ProcessControlRequest+0xf4>
     a4a:	82 30       	cpi	r24, 0x02	; 2
     a4c:	09 f0       	breq	.+2      	; 0xa50 <USB_Device_ProcessControlRequest+0xf4>
     a4e:	f1 c0       	rjmp	.+482    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	8f 71       	andi	r24, 0x1F	; 31
     a54:	90 70       	andi	r25, 0x00	; 0
     a56:	00 97       	sbiw	r24, 0x00	; 0
     a58:	21 f0       	breq	.+8      	; 0xa62 <USB_Device_ProcessControlRequest+0x106>
     a5a:	02 97       	sbiw	r24, 0x02	; 2
     a5c:	09 f0       	breq	.+2      	; 0xa60 <USB_Device_ProcessControlRequest+0x104>
     a5e:	e9 c0       	rjmp	.+466    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
     a60:	0c c0       	rjmp	.+24     	; 0xa7a <USB_Device_ProcessControlRequest+0x11e>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
     a62:	80 91 30 01 	lds	r24, 0x0130
     a66:	81 30       	cpi	r24, 0x01	; 1
     a68:	09 f0       	breq	.+2      	; 0xa6c <USB_Device_ProcessControlRequest+0x110>
     a6a:	e3 c0       	rjmp	.+454    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
     a6c:	10 92 2a 01 	sts	0x012A, r1
     a70:	33 30       	cpi	r19, 0x03	; 3
     a72:	69 f5       	brne	.+90     	; 0xace <USB_Device_ProcessControlRequest+0x172>
     a74:	80 93 2a 01 	sts	0x012A, r24
     a78:	2a c0       	rjmp	.+84     	; 0xace <USB_Device_ProcessControlRequest+0x172>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
     a7a:	80 91 30 01 	lds	r24, 0x0130
     a7e:	88 23       	and	r24, r24
     a80:	31 f5       	brne	.+76     	; 0xace <USB_Device_ProcessControlRequest+0x172>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
     a82:	20 91 32 01 	lds	r18, 0x0132
     a86:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
     a88:	09 f4       	brne	.+2      	; 0xa8c <USB_Device_ProcessControlRequest+0x130>
     a8a:	d3 c0       	rjmp	.+422    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     a8c:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
     a90:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
     a94:	80 ff       	sbrs	r24, 0
     a96:	1b c0       	rjmp	.+54     	; 0xace <USB_Device_ProcessControlRequest+0x172>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
     a98:	33 30       	cpi	r19, 0x03	; 3
     a9a:	21 f4       	brne	.+8      	; 0xaa4 <USB_Device_ProcessControlRequest+0x148>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     a9c:	80 91 eb 00 	lds	r24, 0x00EB
     aa0:	80 62       	ori	r24, 0x20	; 32
     aa2:	13 c0       	rjmp	.+38     	; 0xaca <USB_Device_ProcessControlRequest+0x16e>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
     aa4:	80 91 eb 00 	lds	r24, 0x00EB
     aa8:	80 61       	ori	r24, 0x10	; 16
     aaa:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
     aae:	81 e0       	ldi	r24, 0x01	; 1
     ab0:	90 e0       	ldi	r25, 0x00	; 0
     ab2:	02 c0       	rjmp	.+4      	; 0xab8 <USB_Device_ProcessControlRequest+0x15c>
     ab4:	88 0f       	add	r24, r24
     ab6:	99 1f       	adc	r25, r25
     ab8:	2a 95       	dec	r18
     aba:	e2 f7       	brpl	.-8      	; 0xab4 <USB_Device_ProcessControlRequest+0x158>
     abc:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
     ac0:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
     ac4:	80 91 eb 00 	lds	r24, 0x00EB
     ac8:	88 60       	ori	r24, 0x08	; 8
     aca:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     ace:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     ad2:	80 91 e8 00 	lds	r24, 0x00E8
     ad6:	87 7f       	andi	r24, 0xF7	; 247
     ad8:	8c c0       	rjmp	.+280    	; 0xbf2 <USB_Device_ProcessControlRequest+0x296>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     ada:	88 23       	and	r24, r24
     adc:	09 f0       	breq	.+2      	; 0xae0 <USB_Device_ProcessControlRequest+0x184>
     ade:	a9 c0       	rjmp	.+338    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
     ae0:	10 91 30 01 	lds	r17, 0x0130
     ae4:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
     ae6:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
     ae8:	f8 94       	cli
     aea:	80 91 e8 00 	lds	r24, 0x00E8
     aee:	87 7f       	andi	r24, 0xF7	; 247
     af0:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
     af4:	b7 dd       	rcall	.-1170   	; 0x664 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     af6:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
     afa:	80 ff       	sbrs	r24, 0
     afc:	fc cf       	rjmp	.-8      	; 0xaf6 <USB_Device_ProcessControlRequest+0x19a>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR  = ((UDADDR & (1 << ADDEN)) | (Address & 0x7F));
     afe:	80 91 e3 00 	lds	r24, 0x00E3
     b02:	80 78       	andi	r24, 0x80	; 128
     b04:	81 2b       	or	r24, r17
     b06:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR |= (1 << ADDEN);
     b0a:	80 91 e3 00 	lds	r24, 0x00E3
     b0e:	80 68       	ori	r24, 0x80	; 128
     b10:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
     b14:	11 23       	and	r17, r17
     b16:	11 f4       	brne	.+4      	; 0xb1c <USB_Device_ProcessControlRequest+0x1c0>
     b18:	82 e0       	ldi	r24, 0x02	; 2
     b1a:	01 c0       	rjmp	.+2      	; 0xb1e <USB_Device_ProcessControlRequest+0x1c2>
     b1c:	83 e0       	ldi	r24, 0x03	; 3
     b1e:	80 93 2d 01 	sts	0x012D, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
     b22:	0f bf       	out	0x3f, r16	; 63
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#endif
				
				GCC_MEMORY_BARRIER();
     b24:	86 c0       	rjmp	.+268    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     b26:	80 58       	subi	r24, 0x80	; 128
     b28:	82 30       	cpi	r24, 0x02	; 2
     b2a:	08 f0       	brcs	.+2      	; 0xb2e <USB_Device_ProcessControlRequest+0x1d2>
     b2c:	82 c0       	rjmp	.+260    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
     b2e:	80 91 30 01 	lds	r24, 0x0130
     b32:	90 91 31 01 	lds	r25, 0x0131
     b36:	23 e0       	ldi	r18, 0x03	; 3
     b38:	8c 3d       	cpi	r24, 0xDC	; 220
     b3a:	92 07       	cpc	r25, r18
     b3c:	09 f0       	breq	.+2      	; 0xb40 <USB_Device_ProcessControlRequest+0x1e4>
     b3e:	33 c0       	rjmp	.+102    	; 0xba6 <USB_Device_ProcessControlRequest+0x24a>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
     b40:	83 e0       	ldi	r24, 0x03	; 3
     b42:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
     b44:	8a e2       	ldi	r24, 0x2A	; 42
     b46:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
     b48:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
     b4a:	f8 94       	cli
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#endif

				GCC_MEMORY_BARRIER();
     b4c:	de 01       	movw	r26, r28
     b4e:	15 96       	adiw	r26, 0x05	; 5
     b50:	6e e0       	ldi	r22, 0x0E	; 14
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
     b56:	11 e2       	ldi	r17, 0x21	; 33
     b58:	e6 2f       	mov	r30, r22
     b5a:	f0 e0       	ldi	r31, 0x00	; 0
     b5c:	10 93 57 00 	sts	0x0057, r17
     b60:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
     b62:	40 ff       	sbrs	r20, 0
     b64:	03 c0       	rjmp	.+6      	; 0xb6c <USB_Device_ProcessControlRequest+0x210>
					{
						SerialByte >>= 4;
     b66:	82 95       	swap	r24
     b68:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
     b6a:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
     b6c:	8f 70       	andi	r24, 0x0F	; 15
     b6e:	28 2f       	mov	r18, r24
     b70:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
     b72:	8a 30       	cpi	r24, 0x0A	; 10
     b74:	18 f0       	brcs	.+6      	; 0xb7c <USB_Device_ProcessControlRequest+0x220>
     b76:	c9 01       	movw	r24, r18
     b78:	c7 96       	adiw	r24, 0x37	; 55
     b7a:	02 c0       	rjmp	.+4      	; 0xb80 <USB_Device_ProcessControlRequest+0x224>
     b7c:	c9 01       	movw	r24, r18
     b7e:	c0 96       	adiw	r24, 0x30	; 48
     b80:	8d 93       	st	X+, r24
     b82:	9d 93       	st	X+, r25
     b84:	4f 5f       	subi	r20, 0xFF	; 255
     b86:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
     b88:	44 31       	cpi	r20, 0x14	; 20
     b8a:	51 05       	cpc	r21, r1
     b8c:	29 f7       	brne	.-54     	; 0xb58 <USB_Device_ProcessControlRequest+0x1fc>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
     b8e:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     b90:	80 91 e8 00 	lds	r24, 0x00E8
     b94:	87 7f       	andi	r24, 0xF7	; 247
     b96:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
     b9a:	ce 01       	movw	r24, r28
     b9c:	03 96       	adiw	r24, 0x03	; 3
     b9e:	6a e2       	ldi	r22, 0x2A	; 42
     ba0:	70 e0       	ldi	r23, 0x00	; 0
     ba2:	61 d0       	rcall	.+194    	; 0xc66 <Endpoint_Write_Control_Stream_LE>
     ba4:	12 c0       	rjmp	.+36     	; 0xbca <USB_Device_ProcessControlRequest+0x26e>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
     ba6:	60 91 32 01 	lds	r22, 0x0132
     baa:	ae 01       	movw	r20, r28
     bac:	4f 5f       	subi	r20, 0xFF	; 255
     bae:	5f 4f       	sbci	r21, 0xFF	; 255
     bb0:	e4 dc       	rcall	.-1592   	; 0x57a <CALLBACK_USB_GetDescriptor>
     bb2:	bc 01       	movw	r22, r24
     bb4:	00 97       	sbiw	r24, 0x00	; 0
     bb6:	09 f4       	brne	.+2      	; 0xbba <USB_Device_ProcessControlRequest+0x25e>
     bb8:	3c c0       	rjmp	.+120    	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
     bba:	80 91 e8 00 	lds	r24, 0x00E8
     bbe:	87 7f       	andi	r24, 0xF7	; 247
     bc0:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
     bc4:	89 81       	ldd	r24, Y+1	; 0x01
     bc6:	9a 81       	ldd	r25, Y+2	; 0x02
     bc8:	ed d0       	rcall	.+474    	; 0xda4 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     bca:	80 91 e8 00 	lds	r24, 0x00E8
     bce:	8b 77       	andi	r24, 0x7B	; 123
     bd0:	80 93 e8 00 	sts	0x00E8, r24
     bd4:	2e c0       	rjmp	.+92     	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
     bd6:	80 38       	cpi	r24, 0x80	; 128
     bd8:	61 f5       	brne	.+88     	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     bda:	80 91 e8 00 	lds	r24, 0x00E8
     bde:	87 7f       	andi	r24, 0xF7	; 247
     be0:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_ConfigurationNumber);
     be4:	80 91 2b 01 	lds	r24, 0x012B
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     be8:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     bec:	80 91 e8 00 	lds	r24, 0x00E8
     bf0:	8e 77       	andi	r24, 0x7E	; 126
     bf2:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
     bf6:	36 dd       	rcall	.-1428   	; 0x664 <Endpoint_ClearStatusStage>
     bf8:	1c c0       	rjmp	.+56     	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     bfa:	88 23       	and	r24, r24
     bfc:	d1 f4       	brne	.+52     	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
     bfe:	90 91 30 01 	lds	r25, 0x0130
     c02:	92 30       	cpi	r25, 0x02	; 2
     c04:	b0 f4       	brcc	.+44     	; 0xc32 <USB_Device_ProcessControlRequest+0x2d6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     c06:	80 91 e8 00 	lds	r24, 0x00E8
     c0a:	87 7f       	andi	r24, 0xF7	; 247
     c0c:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
     c10:	90 93 2b 01 	sts	0x012B, r25

	Endpoint_ClearStatusStage();
     c14:	27 dd       	rcall	.-1458   	; 0x664 <Endpoint_ClearStatusStage>

	if (USB_ConfigurationNumber)
     c16:	80 91 2b 01 	lds	r24, 0x012B
     c1a:	88 23       	and	r24, r24
     c1c:	31 f4       	brne	.+12     	; 0xc2a <USB_Device_ProcessControlRequest+0x2ce>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
     c1e:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
     c22:	87 fd       	sbrc	r24, 7
     c24:	02 c0       	rjmp	.+4      	; 0xc2a <USB_Device_ProcessControlRequest+0x2ce>
     c26:	81 e0       	ldi	r24, 0x01	; 1
     c28:	01 c0       	rjmp	.+2      	; 0xc2c <USB_Device_ProcessControlRequest+0x2d0>
     c2a:	84 e0       	ldi	r24, 0x04	; 4
     c2c:	80 93 2d 01 	sts	0x012D, r24

	EVENT_USB_Device_ConfigurationChanged();
     c30:	22 dc       	rcall	.-1980   	; 0x476 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
     c32:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
     c36:	83 ff       	sbrs	r24, 3
     c38:	0a c0       	rjmp	.+20     	; 0xc4e <USB_Device_ProcessControlRequest+0x2f2>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     c3a:	80 91 eb 00 	lds	r24, 0x00EB
     c3e:	80 62       	ori	r24, 0x20	; 32
     c40:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     c44:	80 91 e8 00 	lds	r24, 0x00E8
     c48:	87 7f       	andi	r24, 0xF7	; 247
     c4a:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
     c4e:	ac 96       	adiw	r28, 0x2c	; 44
     c50:	0f b6       	in	r0, 0x3f	; 63
     c52:	f8 94       	cli
     c54:	de bf       	out	0x3e, r29	; 62
     c56:	0f be       	out	0x3f, r0	; 63
     c58:	cd bf       	out	0x3d, r28	; 61
     c5a:	cf 91       	pop	r28
     c5c:	df 91       	pop	r29
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	08 95       	ret

00000c64 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
     c64:	08 95       	ret

00000c66 <Endpoint_Write_Control_Stream_LE>:
     c66:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
     c68:	40 91 34 01 	lds	r20, 0x0134
     c6c:	50 91 35 01 	lds	r21, 0x0135
     c70:	46 17       	cp	r20, r22
     c72:	57 07       	cpc	r21, r23
     c74:	18 f4       	brcc	.+6      	; 0xc7c <Endpoint_Write_Control_Stream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
     c76:	f9 01       	movw	r30, r18
     c78:	90 e0       	ldi	r25, 0x00	; 0
     c7a:	3d c0       	rjmp	.+122    	; 0xcf6 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
     c7c:	61 15       	cp	r22, r1
     c7e:	71 05       	cpc	r23, r1
     c80:	11 f0       	breq	.+4      	; 0xc86 <Endpoint_Write_Control_Stream_LE+0x20>
     c82:	ab 01       	movw	r20, r22
     c84:	f8 cf       	rjmp	.-16     	; 0xc76 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     c86:	80 91 e8 00 	lds	r24, 0x00E8
     c8a:	8e 77       	andi	r24, 0x7E	; 126
     c8c:	80 93 e8 00 	sts	0x00E8, r24
     c90:	40 e0       	ldi	r20, 0x00	; 0
     c92:	50 e0       	ldi	r21, 0x00	; 0
     c94:	f0 cf       	rjmp	.-32     	; 0xc76 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     c96:	80 91 2d 01 	lds	r24, 0x012D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     c9a:	88 23       	and	r24, r24
     c9c:	f1 f1       	breq	.+124    	; 0xd1a <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     c9e:	85 30       	cpi	r24, 0x05	; 5
     ca0:	f1 f1       	breq	.+124    	; 0xd1e <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
     ca2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
     ca6:	83 ff       	sbrs	r24, 3
     ca8:	02 c0       	rjmp	.+4      	; 0xcae <Endpoint_Write_Control_Stream_LE+0x48>
     caa:	81 e0       	ldi	r24, 0x01	; 1
     cac:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     cae:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
     cb2:	82 fd       	sbrc	r24, 2
     cb4:	2c c0       	rjmp	.+88     	; 0xd0e <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     cb6:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
     cba:	80 ff       	sbrs	r24, 0
     cbc:	1c c0       	rjmp	.+56     	; 0xcf6 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
     cbe:	20 91 f2 00 	lds	r18, 0x00F2
     cc2:	30 91 f3 00 	lds	r19, 0x00F3
     cc6:	07 c0       	rjmp	.+14     	; 0xcd6 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
     cc8:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     cca:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
     cce:	41 50       	subi	r20, 0x01	; 1
     cd0:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
     cd2:	2f 5f       	subi	r18, 0xFF	; 255
     cd4:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
     cd6:	41 15       	cp	r20, r1
     cd8:	51 05       	cpc	r21, r1
     cda:	19 f0       	breq	.+6      	; 0xce2 <Endpoint_Write_Control_Stream_LE+0x7c>
     cdc:	28 30       	cpi	r18, 0x08	; 8
     cde:	31 05       	cpc	r19, r1
     ce0:	98 f3       	brcs	.-26     	; 0xcc8 <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
     ce2:	90 e0       	ldi	r25, 0x00	; 0
     ce4:	28 30       	cpi	r18, 0x08	; 8
     ce6:	31 05       	cpc	r19, r1
     ce8:	09 f4       	brne	.+2      	; 0xcec <Endpoint_Write_Control_Stream_LE+0x86>
     cea:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     cec:	80 91 e8 00 	lds	r24, 0x00E8
     cf0:	8e 77       	andi	r24, 0x7E	; 126
     cf2:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
     cf6:	41 15       	cp	r20, r1
     cf8:	51 05       	cpc	r21, r1
     cfa:	69 f6       	brne	.-102    	; 0xc96 <Endpoint_Write_Control_Stream_LE+0x30>
     cfc:	99 23       	and	r25, r25
     cfe:	59 f6       	brne	.-106    	; 0xc96 <Endpoint_Write_Control_Stream_LE+0x30>
     d00:	06 c0       	rjmp	.+12     	; 0xd0e <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     d02:	80 91 2d 01 	lds	r24, 0x012D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     d06:	88 23       	and	r24, r24
     d08:	41 f0       	breq	.+16     	; 0xd1a <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     d0a:	85 30       	cpi	r24, 0x05	; 5
     d0c:	41 f0       	breq	.+16     	; 0xd1e <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     d0e:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
     d12:	82 ff       	sbrs	r24, 2
     d14:	f6 cf       	rjmp	.-20     	; 0xd02 <Endpoint_Write_Control_Stream_LE+0x9c>
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	08 95       	ret
     d1a:	82 e0       	ldi	r24, 0x02	; 2
     d1c:	08 95       	ret
     d1e:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
     d20:	08 95       	ret

00000d22 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
     d22:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
     d24:	61 15       	cp	r22, r1
     d26:	71 05       	cpc	r23, r1
     d28:	29 f4       	brne	.+10     	; 0xd34 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     d2a:	80 91 e8 00 	lds	r24, 0x00E8
     d2e:	8b 77       	andi	r24, 0x7B	; 123
     d30:	80 93 e8 00 	sts	0x00E8, r24
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
     d34:	f9 01       	movw	r30, r18
     d36:	22 c0       	rjmp	.+68     	; 0xd7c <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     d38:	80 91 2d 01 	lds	r24, 0x012D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     d3c:	88 23       	and	r24, r24
     d3e:	71 f1       	breq	.+92     	; 0xd9c <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     d40:	85 30       	cpi	r24, 0x05	; 5
     d42:	71 f1       	breq	.+92     	; 0xda0 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
     d44:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
     d48:	83 ff       	sbrs	r24, 3
     d4a:	02 c0       	rjmp	.+4      	; 0xd50 <Endpoint_Read_Control_Stream_LE+0x2e>
     d4c:	81 e0       	ldi	r24, 0x01	; 1
     d4e:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     d50:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
     d54:	82 ff       	sbrs	r24, 2
     d56:	f0 cf       	rjmp	.-32     	; 0xd38 <Endpoint_Read_Control_Stream_LE+0x16>
     d58:	06 c0       	rjmp	.+12     	; 0xd66 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
     d5a:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
     d5e:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
     d60:	61 50       	subi	r22, 0x01	; 1
     d62:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
     d64:	31 f0       	breq	.+12     	; 0xd72 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
     d66:	80 91 f2 00 	lds	r24, 0x00F2
     d6a:	90 91 f3 00 	lds	r25, 0x00F3
     d6e:	89 2b       	or	r24, r25
     d70:	a1 f7       	brne	.-24     	; 0xd5a <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     d72:	80 91 e8 00 	lds	r24, 0x00E8
     d76:	8b 77       	andi	r24, 0x7B	; 123
     d78:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
     d7c:	61 15       	cp	r22, r1
     d7e:	71 05       	cpc	r23, r1
     d80:	d9 f6       	brne	.-74     	; 0xd38 <Endpoint_Read_Control_Stream_LE+0x16>
     d82:	06 c0       	rjmp	.+12     	; 0xd90 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     d84:	80 91 2d 01 	lds	r24, 0x012D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     d88:	88 23       	and	r24, r24
     d8a:	41 f0       	breq	.+16     	; 0xd9c <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     d8c:	85 30       	cpi	r24, 0x05	; 5
     d8e:	41 f0       	breq	.+16     	; 0xda0 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     d90:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
     d94:	80 ff       	sbrs	r24, 0
     d96:	f6 cf       	rjmp	.-20     	; 0xd84 <Endpoint_Read_Control_Stream_LE+0x62>
     d98:	80 e0       	ldi	r24, 0x00	; 0
     d9a:	08 95       	ret
     d9c:	82 e0       	ldi	r24, 0x02	; 2
     d9e:	08 95       	ret
     da0:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
     da2:	08 95       	ret

00000da4 <Endpoint_Write_Control_PStream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
     da4:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
     da6:	40 91 34 01 	lds	r20, 0x0134
     daa:	50 91 35 01 	lds	r21, 0x0135
     dae:	46 17       	cp	r20, r22
     db0:	57 07       	cpc	r21, r23
     db2:	18 f4       	brcc	.+6      	; 0xdba <Endpoint_Write_Control_PStream_LE+0x16>
uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
     db4:	f9 01       	movw	r30, r18
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	40 c0       	rjmp	.+128    	; 0xe3a <Endpoint_Write_Control_PStream_LE+0x96>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
     dba:	61 15       	cp	r22, r1
     dbc:	71 05       	cpc	r23, r1
     dbe:	11 f0       	breq	.+4      	; 0xdc4 <Endpoint_Write_Control_PStream_LE+0x20>
     dc0:	ab 01       	movw	r20, r22
     dc2:	f8 cf       	rjmp	.-16     	; 0xdb4 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     dc4:	80 91 e8 00 	lds	r24, 0x00E8
     dc8:	8e 77       	andi	r24, 0x7E	; 126
     dca:	80 93 e8 00 	sts	0x00E8, r24
     dce:	40 e0       	ldi	r20, 0x00	; 0
     dd0:	50 e0       	ldi	r21, 0x00	; 0
     dd2:	f0 cf       	rjmp	.-32     	; 0xdb4 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     dd4:	80 91 2d 01 	lds	r24, 0x012D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     dd8:	88 23       	and	r24, r24
     dda:	09 f4       	brne	.+2      	; 0xdde <Endpoint_Write_Control_PStream_LE+0x3a>
     ddc:	40 c0       	rjmp	.+128    	; 0xe5e <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     dde:	85 30       	cpi	r24, 0x05	; 5
     de0:	09 f4       	brne	.+2      	; 0xde4 <Endpoint_Write_Control_PStream_LE+0x40>
     de2:	3f c0       	rjmp	.+126    	; 0xe62 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
     de4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
     de8:	83 ff       	sbrs	r24, 3
     dea:	02 c0       	rjmp	.+4      	; 0xdf0 <Endpoint_Write_Control_PStream_LE+0x4c>
     dec:	81 e0       	ldi	r24, 0x01	; 1
     dee:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     df0:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
     df4:	82 fd       	sbrc	r24, 2
     df6:	2d c0       	rjmp	.+90     	; 0xe52 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     df8:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
     dfc:	80 ff       	sbrs	r24, 0
     dfe:	1d c0       	rjmp	.+58     	; 0xe3a <Endpoint_Write_Control_PStream_LE+0x96>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
     e00:	20 91 f2 00 	lds	r18, 0x00F2
     e04:	30 91 f3 00 	lds	r19, 0x00F3
     e08:	08 c0       	rjmp	.+16     	; 0xe1a <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
     e0a:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     e0c:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
     e10:	31 96       	adiw	r30, 0x01	; 1
				Length--;
     e12:	41 50       	subi	r20, 0x01	; 1
     e14:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
     e16:	2f 5f       	subi	r18, 0xFF	; 255
     e18:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
     e1a:	41 15       	cp	r20, r1
     e1c:	51 05       	cpc	r21, r1
     e1e:	19 f0       	breq	.+6      	; 0xe26 <Endpoint_Write_Control_PStream_LE+0x82>
     e20:	28 30       	cpi	r18, 0x08	; 8
     e22:	31 05       	cpc	r19, r1
     e24:	90 f3       	brcs	.-28     	; 0xe0a <Endpoint_Write_Control_PStream_LE+0x66>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	28 30       	cpi	r18, 0x08	; 8
     e2a:	31 05       	cpc	r19, r1
     e2c:	09 f4       	brne	.+2      	; 0xe30 <Endpoint_Write_Control_PStream_LE+0x8c>
     e2e:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     e30:	80 91 e8 00 	lds	r24, 0x00E8
     e34:	8e 77       	andi	r24, 0x7E	; 126
     e36:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
     e3a:	41 15       	cp	r20, r1
     e3c:	51 05       	cpc	r21, r1
     e3e:	51 f6       	brne	.-108    	; 0xdd4 <Endpoint_Write_Control_PStream_LE+0x30>
     e40:	99 23       	and	r25, r25
     e42:	41 f6       	brne	.-112    	; 0xdd4 <Endpoint_Write_Control_PStream_LE+0x30>
     e44:	06 c0       	rjmp	.+12     	; 0xe52 <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
     e46:	80 91 2d 01 	lds	r24, 0x012D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
     e4a:	88 23       	and	r24, r24
     e4c:	41 f0       	breq	.+16     	; 0xe5e <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
     e4e:	85 30       	cpi	r24, 0x05	; 5
     e50:	41 f0       	breq	.+16     	; 0xe62 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     e52:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
     e56:	82 ff       	sbrs	r24, 2
     e58:	f6 cf       	rjmp	.-20     	; 0xe46 <Endpoint_Write_Control_PStream_LE+0xa2>
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	08 95       	ret
     e5e:	82 e0       	ldi	r24, 0x02	; 2
     e60:	08 95       	ret
     e62:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
     e64:	08 95       	ret

00000e66 <Endpoint_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
     e66:	bf 92       	push	r11
     e68:	cf 92       	push	r12
     e6a:	df 92       	push	r13
     e6c:	ef 92       	push	r14
     e6e:	ff 92       	push	r15
     e70:	0f 93       	push	r16
     e72:	1f 93       	push	r17
     e74:	cf 93       	push	r28
     e76:	df 93       	push	r29
     e78:	18 2f       	mov	r17, r24
     e7a:	09 2f       	mov	r16, r25
     e7c:	7b 01       	movw	r14, r22
     e7e:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
     e80:	12 dc       	rcall	.-2012   	; 0x6a6 <Endpoint_WaitUntilReady>
     e82:	b8 2e       	mov	r11, r24
     e84:	88 23       	and	r24, r24
     e86:	b1 f5       	brne	.+108    	; 0xef4 <Endpoint_Read_Stream_LE+0x8e>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
     e88:	81 2f       	mov	r24, r17
     e8a:	90 2f       	mov	r25, r16
     e8c:	9c 01       	movw	r18, r24
     e8e:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
     e90:	c1 14       	cp	r12, r1
     e92:	d1 04       	cpc	r13, r1
     e94:	39 f0       	breq	.+14     	; 0xea4 <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
     e96:	f6 01       	movw	r30, r12
     e98:	80 81       	ld	r24, Z
     e9a:	91 81       	ldd	r25, Z+1	; 0x01
     e9c:	e8 1a       	sub	r14, r24
     e9e:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
     ea0:	c8 0f       	add	r28, r24
     ea2:	d9 1f       	adc	r29, r25
     ea4:	00 e0       	ldi	r16, 0x00	; 0
     ea6:	10 e0       	ldi	r17, 0x00	; 0
     ea8:	22 c0       	rjmp	.+68     	; 0xeee <Endpoint_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     eaa:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
     eae:	85 fd       	sbrc	r24, 5
     eb0:	16 c0       	rjmp	.+44     	; 0xede <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     eb2:	80 91 e8 00 	lds	r24, 0x00E8
     eb6:	8b 77       	andi	r24, 0x7B	; 123
     eb8:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
     ebc:	c1 14       	cp	r12, r1
     ebe:	d1 04       	cpc	r13, r1
     ec0:	49 f0       	breq	.+18     	; 0xed4 <Endpoint_Read_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
     ec2:	f6 01       	movw	r30, r12
     ec4:	80 81       	ld	r24, Z
     ec6:	91 81       	ldd	r25, Z+1	; 0x01
     ec8:	80 0f       	add	r24, r16
     eca:	91 1f       	adc	r25, r17
     ecc:	91 83       	std	Z+1, r25	; 0x01
     ece:	80 83       	st	Z, r24
     ed0:	85 e0       	ldi	r24, 0x05	; 5
     ed2:	11 c0       	rjmp	.+34     	; 0xef6 <Endpoint_Read_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
     ed4:	6c d0       	rcall	.+216    	; 0xfae <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
     ed6:	e7 db       	rcall	.-2098   	; 0x6a6 <Endpoint_WaitUntilReady>
     ed8:	88 23       	and	r24, r24
     eda:	49 f0       	breq	.+18     	; 0xeee <Endpoint_Read_Stream_LE+0x88>
     edc:	0c c0       	rjmp	.+24     	; 0xef6 <Endpoint_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
     ede:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
     ee2:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
     ee4:	08 94       	sec
     ee6:	e1 08       	sbc	r14, r1
     ee8:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
     eea:	0f 5f       	subi	r16, 0xFF	; 255
     eec:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
     eee:	e1 14       	cp	r14, r1
     ef0:	f1 04       	cpc	r15, r1
     ef2:	d9 f6       	brne	.-74     	; 0xeaa <Endpoint_Read_Stream_LE+0x44>
     ef4:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
     ef6:	df 91       	pop	r29
     ef8:	cf 91       	pop	r28
     efa:	1f 91       	pop	r17
     efc:	0f 91       	pop	r16
     efe:	ff 90       	pop	r15
     f00:	ef 90       	pop	r14
     f02:	df 90       	pop	r13
     f04:	cf 90       	pop	r12
     f06:	bf 90       	pop	r11
     f08:	08 95       	ret

00000f0a <Endpoint_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
     f0a:	bf 92       	push	r11
     f0c:	cf 92       	push	r12
     f0e:	df 92       	push	r13
     f10:	ef 92       	push	r14
     f12:	ff 92       	push	r15
     f14:	0f 93       	push	r16
     f16:	1f 93       	push	r17
     f18:	cf 93       	push	r28
     f1a:	df 93       	push	r29
     f1c:	18 2f       	mov	r17, r24
     f1e:	09 2f       	mov	r16, r25
     f20:	7b 01       	movw	r14, r22
     f22:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
     f24:	c0 db       	rcall	.-2176   	; 0x6a6 <Endpoint_WaitUntilReady>
     f26:	b8 2e       	mov	r11, r24
     f28:	88 23       	and	r24, r24
     f2a:	b1 f5       	brne	.+108    	; 0xf98 <Endpoint_Write_Stream_LE+0x8e>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
     f2c:	81 2f       	mov	r24, r17
     f2e:	90 2f       	mov	r25, r16
     f30:	9c 01       	movw	r18, r24
     f32:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
     f34:	c1 14       	cp	r12, r1
     f36:	d1 04       	cpc	r13, r1
     f38:	39 f0       	breq	.+14     	; 0xf48 <Endpoint_Write_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
     f3a:	f6 01       	movw	r30, r12
     f3c:	80 81       	ld	r24, Z
     f3e:	91 81       	ldd	r25, Z+1	; 0x01
     f40:	e8 1a       	sub	r14, r24
     f42:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
     f44:	c8 0f       	add	r28, r24
     f46:	d9 1f       	adc	r29, r25
     f48:	00 e0       	ldi	r16, 0x00	; 0
     f4a:	10 e0       	ldi	r17, 0x00	; 0
     f4c:	22 c0       	rjmp	.+68     	; 0xf92 <Endpoint_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     f4e:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
     f52:	85 fd       	sbrc	r24, 5
     f54:	16 c0       	rjmp	.+44     	; 0xf82 <Endpoint_Write_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     f56:	80 91 e8 00 	lds	r24, 0x00E8
     f5a:	8e 77       	andi	r24, 0x7E	; 126
     f5c:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
     f60:	c1 14       	cp	r12, r1
     f62:	d1 04       	cpc	r13, r1
     f64:	49 f0       	breq	.+18     	; 0xf78 <Endpoint_Write_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
     f66:	f6 01       	movw	r30, r12
     f68:	80 81       	ld	r24, Z
     f6a:	91 81       	ldd	r25, Z+1	; 0x01
     f6c:	80 0f       	add	r24, r16
     f6e:	91 1f       	adc	r25, r17
     f70:	91 83       	std	Z+1, r25	; 0x01
     f72:	80 83       	st	Z, r24
     f74:	85 e0       	ldi	r24, 0x05	; 5
     f76:	11 c0       	rjmp	.+34     	; 0xf9a <Endpoint_Write_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
     f78:	1a d0       	rcall	.+52     	; 0xfae <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
     f7a:	95 db       	rcall	.-2262   	; 0x6a6 <Endpoint_WaitUntilReady>
     f7c:	88 23       	and	r24, r24
     f7e:	49 f0       	breq	.+18     	; 0xf92 <Endpoint_Write_Stream_LE+0x88>
     f80:	0c c0       	rjmp	.+24     	; 0xf9a <Endpoint_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
     f82:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     f84:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
     f88:	08 94       	sec
     f8a:	e1 08       	sbc	r14, r1
     f8c:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
     f8e:	0f 5f       	subi	r16, 0xFF	; 255
     f90:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
     f92:	e1 14       	cp	r14, r1
     f94:	f1 04       	cpc	r15, r1
     f96:	d9 f6       	brne	.-74     	; 0xf4e <Endpoint_Write_Stream_LE+0x44>
     f98:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	1f 91       	pop	r17
     fa0:	0f 91       	pop	r16
     fa2:	ff 90       	pop	r15
     fa4:	ef 90       	pop	r14
     fa6:	df 90       	pop	r13
     fa8:	cf 90       	pop	r12
     faa:	bf 90       	pop	r11
     fac:	08 95       	ret

00000fae <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
     fae:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
     fb0:	80 91 2d 01 	lds	r24, 0x012D
     fb4:	88 23       	and	r24, r24
     fb6:	61 f0       	breq	.+24     	; 0xfd0 <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
     fb8:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     fbc:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
     fc0:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
     fc4:	83 ff       	sbrs	r24, 3
     fc6:	01 c0       	rjmp	.+2      	; 0xfca <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
     fc8:	c9 dc       	rcall	.-1646   	; 0x95c <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
     fca:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     fcc:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
     fd0:	1f 91       	pop	r17
     fd2:	08 95       	ret

00000fd4 <__divmodsi4>:
     fd4:	97 fb       	bst	r25, 7
     fd6:	09 2e       	mov	r0, r25
     fd8:	05 26       	eor	r0, r21
     fda:	0e d0       	rcall	.+28     	; 0xff8 <__divmodsi4_neg1>
     fdc:	57 fd       	sbrc	r21, 7
     fde:	04 d0       	rcall	.+8      	; 0xfe8 <__divmodsi4_neg2>
     fe0:	14 d0       	rcall	.+40     	; 0x100a <__udivmodsi4>
     fe2:	0a d0       	rcall	.+20     	; 0xff8 <__divmodsi4_neg1>
     fe4:	00 1c       	adc	r0, r0
     fe6:	38 f4       	brcc	.+14     	; 0xff6 <__divmodsi4_exit>

00000fe8 <__divmodsi4_neg2>:
     fe8:	50 95       	com	r21
     fea:	40 95       	com	r20
     fec:	30 95       	com	r19
     fee:	21 95       	neg	r18
     ff0:	3f 4f       	sbci	r19, 0xFF	; 255
     ff2:	4f 4f       	sbci	r20, 0xFF	; 255
     ff4:	5f 4f       	sbci	r21, 0xFF	; 255

00000ff6 <__divmodsi4_exit>:
     ff6:	08 95       	ret

00000ff8 <__divmodsi4_neg1>:
     ff8:	f6 f7       	brtc	.-4      	; 0xff6 <__divmodsi4_exit>
     ffa:	90 95       	com	r25
     ffc:	80 95       	com	r24
     ffe:	70 95       	com	r23
    1000:	61 95       	neg	r22
    1002:	7f 4f       	sbci	r23, 0xFF	; 255
    1004:	8f 4f       	sbci	r24, 0xFF	; 255
    1006:	9f 4f       	sbci	r25, 0xFF	; 255
    1008:	08 95       	ret

0000100a <__udivmodsi4>:
    100a:	a1 e2       	ldi	r26, 0x21	; 33
    100c:	1a 2e       	mov	r1, r26
    100e:	aa 1b       	sub	r26, r26
    1010:	bb 1b       	sub	r27, r27
    1012:	fd 01       	movw	r30, r26
    1014:	0d c0       	rjmp	.+26     	; 0x1030 <__udivmodsi4_ep>

00001016 <__udivmodsi4_loop>:
    1016:	aa 1f       	adc	r26, r26
    1018:	bb 1f       	adc	r27, r27
    101a:	ee 1f       	adc	r30, r30
    101c:	ff 1f       	adc	r31, r31
    101e:	a2 17       	cp	r26, r18
    1020:	b3 07       	cpc	r27, r19
    1022:	e4 07       	cpc	r30, r20
    1024:	f5 07       	cpc	r31, r21
    1026:	20 f0       	brcs	.+8      	; 0x1030 <__udivmodsi4_ep>
    1028:	a2 1b       	sub	r26, r18
    102a:	b3 0b       	sbc	r27, r19
    102c:	e4 0b       	sbc	r30, r20
    102e:	f5 0b       	sbc	r31, r21

00001030 <__udivmodsi4_ep>:
    1030:	66 1f       	adc	r22, r22
    1032:	77 1f       	adc	r23, r23
    1034:	88 1f       	adc	r24, r24
    1036:	99 1f       	adc	r25, r25
    1038:	1a 94       	dec	r1
    103a:	69 f7       	brne	.-38     	; 0x1016 <__udivmodsi4_loop>
    103c:	60 95       	com	r22
    103e:	70 95       	com	r23
    1040:	80 95       	com	r24
    1042:	90 95       	com	r25
    1044:	9b 01       	movw	r18, r22
    1046:	ac 01       	movw	r20, r24
    1048:	bd 01       	movw	r22, r26
    104a:	cf 01       	movw	r24, r30
    104c:	08 95       	ret

0000104e <_exit>:
    104e:	f8 94       	cli

00001050 <__stop_program>:
    1050:	ff cf       	rjmp	.-2      	; 0x1050 <__stop_program>
