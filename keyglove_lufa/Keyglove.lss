
Keyglove.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000036c  00800100  000088d4  00008968  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000088d4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004c2  0080046c  0080046c  00008cd4  2**0
                  ALLOC
  3 .debug_aranges 00000470  00000000  00000000  00008cd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00003541  00000000  00000000  00009144  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000118ac  00000000  00000000  0000c685  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002c2e  00000000  00000000  0001df31  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000ab43  00000000  00000000  00020b5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000019a0  00000000  00000000  0002b6a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00005d0f  00000000  00000000  0002d044  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00007efc  00000000  00000000  00032d53  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000430  00000000  00000000  0003ac4f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	}
}

/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
void delayMicroseconds(unsigned int us)
{
       0:	ba c1       	rjmp	.+884    	; 0x376 <__ctors_end>
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       2:	00 00       	nop
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       4:	e2 c1       	rjmp	.+964    	; 0x3ca <__bad_interrupt>

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       6:	00 00       	nop
       8:	e0 c1       	rjmp	.+960    	; 0x3ca <__bad_interrupt>
       a:	00 00       	nop
       c:	de c1       	rjmp	.+956    	; 0x3ca <__bad_interrupt>
       e:	00 00       	nop
      10:	dc c1       	rjmp	.+952    	; 0x3ca <__bad_interrupt>
      12:	00 00       	nop
      14:	da c1       	rjmp	.+948    	; 0x3ca <__bad_interrupt>
      16:	00 00       	nop
      18:	d8 c1       	rjmp	.+944    	; 0x3ca <__bad_interrupt>
      1a:	00 00       	nop
      1c:	d6 c1       	rjmp	.+940    	; 0x3ca <__bad_interrupt>
      1e:	00 00       	nop
      20:	d4 c1       	rjmp	.+936    	; 0x3ca <__bad_interrupt>
      22:	00 00       	nop
      24:	d2 c1       	rjmp	.+932    	; 0x3ca <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 8d 3b 	jmp	0x771a	; 0x771a <__vector_10>
      2c:	ce c1       	rjmp	.+924    	; 0x3ca <__bad_interrupt>
      2e:	00 00       	nop
      30:	cc c1       	rjmp	.+920    	; 0x3ca <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 e6 27 	jmp	0x4fcc	; 0x4fcc <__vector_13>
      38:	c8 c1       	rjmp	.+912    	; 0x3ca <__bad_interrupt>
      3a:	00 00       	nop
      3c:	c6 c1       	rjmp	.+908    	; 0x3ca <__bad_interrupt>
      3e:	00 00       	nop
      40:	c4 c1       	rjmp	.+904    	; 0x3ca <__bad_interrupt>
      42:	00 00       	nop
      44:	c2 c1       	rjmp	.+900    	; 0x3ca <__bad_interrupt>
      46:	00 00       	nop
      48:	c0 c1       	rjmp	.+896    	; 0x3ca <__bad_interrupt>
      4a:	00 00       	nop
      4c:	be c1       	rjmp	.+892    	; 0x3ca <__bad_interrupt>
      4e:	00 00       	nop
      50:	bc c1       	rjmp	.+888    	; 0x3ca <__bad_interrupt>
      52:	00 00       	nop
      54:	ba c1       	rjmp	.+884    	; 0x3ca <__bad_interrupt>
      56:	00 00       	nop
      58:	b8 c1       	rjmp	.+880    	; 0x3ca <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 62 39 	jmp	0x72c4	; 0x72c4 <__vector_23>
      60:	b4 c1       	rjmp	.+872    	; 0x3ca <__bad_interrupt>
      62:	00 00       	nop
      64:	b2 c1       	rjmp	.+868    	; 0x3ca <__bad_interrupt>
      66:	00 00       	nop
      68:	b0 c1       	rjmp	.+864    	; 0x3ca <__bad_interrupt>
      6a:	00 00       	nop
      6c:	ae c1       	rjmp	.+860    	; 0x3ca <__bad_interrupt>
      6e:	00 00       	nop
      70:	ac c1       	rjmp	.+856    	; 0x3ca <__bad_interrupt>
      72:	00 00       	nop
      74:	aa c1       	rjmp	.+852    	; 0x3ca <__bad_interrupt>
      76:	00 00       	nop
      78:	a8 c1       	rjmp	.+848    	; 0x3ca <__bad_interrupt>
      7a:	00 00       	nop
      7c:	a6 c1       	rjmp	.+844    	; 0x3ca <__bad_interrupt>
      7e:	00 00       	nop
      80:	a4 c1       	rjmp	.+840    	; 0x3ca <__bad_interrupt>
      82:	00 00       	nop
      84:	a2 c1       	rjmp	.+836    	; 0x3ca <__bad_interrupt>
      86:	00 00       	nop
      88:	a0 c1       	rjmp	.+832    	; 0x3ca <__bad_interrupt>
      8a:	00 00       	nop
      8c:	9e c1       	rjmp	.+828    	; 0x3ca <__bad_interrupt>
      8e:	00 00       	nop
      90:	9c c1       	rjmp	.+824    	; 0x3ca <__bad_interrupt>
      92:	00 00       	nop
      94:	9a c1       	rjmp	.+820    	; 0x3ca <__bad_interrupt>
      96:	00 00       	nop
      98:	08 4a       	sbci	r16, 0xA8	; 168
      9a:	d7 3b       	cpi	r29, 0xB7	; 183
      9c:	3b ce       	rjmp	.-906    	; 0xfffffd14 <__eeprom_end+0xff7efd14>
      9e:	01 6e       	ori	r16, 0xE1	; 225
      a0:	84 bc       	out	0x24, r8	; 36
      a2:	bf fd       	.word	0xfdbf	; ????
      a4:	c1 2f       	mov	r28, r17
      a6:	3d 6c       	ori	r19, 0xCD	; 205
      a8:	74 31       	cpi	r23, 0x14	; 20
      aa:	9a bd       	out	0x2a, r25	; 42
      ac:	56 83       	std	Z+6, r21	; 0x06
      ae:	3d da       	rcall	.-2950   	; 0xfffff52a <__eeprom_end+0xff7ef52a>
      b0:	3d 00       	.word	0x003d	; ????
      b2:	c7 7f       	andi	r28, 0xF7	; 247
      b4:	11 be       	out	0x31, r1	; 49
      b6:	d9 e4       	ldi	r29, 0x49	; 73
      b8:	bb 4c       	sbci	r27, 0xCB	; 203
      ba:	3e 91       	ld	r19, -X
      bc:	6b aa       	std	Y+51, r6	; 0x33
      be:	aa be       	out	0x3a, r10	; 58
      c0:	00 00       	nop
      c2:	00 80       	ld	r0, Z
      c4:	3f 07       	cpc	r19, r31
      c6:	63 42       	sbci	r22, 0x23	; 35
      c8:	36 b7       	in	r19, 0x36	; 54
      ca:	9b d8       	rcall	.-3786   	; 0xfffff202 <__eeprom_end+0xff7ef202>
      cc:	a7 1a       	sub	r10, r23
      ce:	39 68       	ori	r19, 0x89	; 137
      d0:	56 18       	sub	r5, r6
      d2:	ae ba       	out	0x1e, r10	; 30
      d4:	ab 55       	subi	r26, 0x5B	; 91
      d6:	8c 1d       	adc	r24, r12
      d8:	3c b7       	in	r19, 0x3c	; 60
      da:	cc 57       	subi	r28, 0x7C	; 124
      dc:	63 bd       	out	0x23, r22	; 35
      de:	6d ed       	ldi	r22, 0xDD	; 221
      e0:	fd 75       	andi	r31, 0x5D	; 93
      e2:	3e f6       	brtc	.-114    	; 0x72 <__SREG__+0x33>
      e4:	17 72       	andi	r17, 0x27	; 39
      e6:	31 bf       	out	0x31, r19	; 49
      e8:	00 00       	nop
      ea:	00 80       	ld	r0, Z
      ec:	3f 08       	sbc	r3, r15
      ee:	00 00       	nop
      f0:	00 be       	out	0x30, r0	; 48
      f2:	92 24       	eor	r9, r2
      f4:	49 12       	cpse	r4, r25
      f6:	3e ab       	std	Y+54, r19	; 0x36
      f8:	aa aa       	std	Y+50, r10	; 0x32
      fa:	2a be       	out	0x3a, r2	; 58
      fc:	cd cc       	rjmp	.-1638   	; 0xfffffa98 <__eeprom_end+0xff7efa98>
      fe:	cc 4c       	sbci	r28, 0xCC	; 204
     100:	3e 00       	.word	0x003e	; ????
     102:	00 00       	nop
     104:	80 be       	out	0x30, r8	; 48
     106:	ab aa       	std	Y+51, r10	; 0x33
     108:	aa aa       	std	Y+50, r10	; 0x32
     10a:	3e 00       	.word	0x003e	; ????
     10c:	00 00       	nop
     10e:	00 bf       	out	0x30, r16	; 48
     110:	00 00       	nop
     112:	00 80       	ld	r0, Z
     114:	3f 00       	.word	0x003f	; ????
     116:	00 00       	nop
     118:	00 00       	nop
     11a:	08 41       	sbci	r16, 0x18	; 24
     11c:	78 d3       	rcall	.+1776   	; 0x80e <_Z8mouseoffi+0x8>
     11e:	bb 43       	sbci	r27, 0x3B	; 59
     120:	87 d1       	rcall	.+782    	; 0x430 <_GLOBAL__I_HIDReportInData+0x2>
     122:	13 3d       	cpi	r17, 0xD3	; 211
     124:	19 0e       	add	r1, r25
     126:	3c c3       	rjmp	.+1656   	; 0x7a0 <SetupHardware+0x30>
     128:	bd 42       	sbci	r27, 0x2D	; 45
     12a:	82 ad       	ldd	r24, Z+58	; 0x3a
     12c:	2b 3e       	cpi	r18, 0xEB	; 235
     12e:	68 ec       	ldi	r22, 0xC8	; 200
     130:	82 76       	andi	r24, 0x62	; 98
     132:	be d9       	rcall	.-3204   	; 0xfffff4b0 <__eeprom_end+0xff7ef4b0>
     134:	8f e1       	ldi	r24, 0x1F	; 31
     136:	a9 3e       	cpi	r26, 0xE9	; 233
     138:	4c 80       	ldd	r4, Y+4	; 0x04
     13a:	ef ff       	.word	0xffef	; ????
     13c:	be 01       	movw	r22, r28
     13e:	c4 ff       	sbrs	r28, 4
     140:	7f 3f       	cpi	r23, 0xFF	; 255
     142:	00 00       	nop
     144:	00 00       	nop
     146:	00 00       	nop

00000147 <port_to_mode_PGM>:
     147:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

00000151 <port_to_output_PGM>:
     151:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

0000015b <port_to_input_PGM>:
     15b:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

00000165 <digital_pin_to_port_PGM>:
     165:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
     175:	03 03 03 03                                         ....

00000179 <digital_pin_to_bit_mask_PGM>:
     179:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
     189:	04 08 10 20                                         ... 

0000018d <digital_pin_to_timer_PGM>:
     18d:	00 00 00 07 00 02 01 00 00 03 04 06 00 00 00 00     ................
     19d:	00 00 00 00                                         ....

000001a1 <HIDReport>:
     1a1:	05 01 09 02 a1 01 85 01 09 01 a1 00 05 09 19 01     ................
     1b1:	29 03 15 00 25 01 95 03 75 01 81 02 95 01 75 05     )...%...u.....u.
     1c1:	81 01 05 01 09 30 09 31 09 38 15 f6 25 0a 35 f6     .....0.1.8..%.5.
     1d1:	45 0a 95 03 75 08 81 06 c0 c0 05 01 09 06 a1 01     E...u...........
     1e1:	85 02 05 07 19 e0 29 e7 15 00 25 01 75 01 95 08     ......)...%.u...
     1f1:	81 02 95 01 75 08 81 01 05 08 19 01 29 05 95 05     ....u.......)...
     201:	75 01 91 02 95 01 75 03 91 01 15 00 25 65 05 07     u.....u.....%e..
     211:	19 00 29 65 95 06 75 08 81 00 c0 05 01 09 04 a1     ..)e..u.........
     221:	01 85 03 09 01 a1 00 09 30 09 31 15 9c 25 64 35     ........0.1..%d5
     231:	ff 45 01 95 02 75 08 81 02 c0 05 09 19 01 29 02     .E...u........).
     241:	15 00 25 01 75 01 95 02 81 02 75 06 95 01 81 01     ..%.u.....u.....
     251:	c0                                                  .

00000252 <DeviceDescriptor>:
     252:	12 01 10 01 00 00 00 08 eb 03 4e 20 01 00 01 02     ..........N ....
     262:	dc 01                                               ..

00000264 <ConfigurationDescriptor>:
     264:	09 02 66 00 03 01 02 c0 fa 08 0b 00 02 02 02 01     ..f.............
     274:	02 09 04 00 00 01 02 02 01 03 05 24 00 10 01 04     ...........$....
     284:	24 02 06 05 24 06 00 01 07 05 81 03 08 00 ff 09     $...$...........
     294:	04 01 00 02 0a 00 00 03 07 05 03 02 10 00 01 07     ................
     2a4:	05 82 02 10 00 01 09 04 02 00 02 03 01 01 04 09     ................
     2b4:	21 11 01 00 01 22 b1 00 07 05 84 03 09 00 01 07     !...."..........
     2c4:	05 05 03 09 00 01                                   ......

000002ca <LanguageString>:
     2ca:	04 03 09 04                                         ....

000002ce <ManufacturerString>:
     2ce:	1a 03 4a 00 65 00 66 00 66 00 20 00 52 00 6f 00     ..J.e.f.f. .R.o.
     2de:	77 00 62 00 65 00 72 00 67 00 00 00                 w.b.e.r.g...

000002ea <ProductString>:
     2ea:	2c 03 4b 00 65 00 79 00 67 00 6c 00 6f 00 76 00     ,.K.e.y.g.l.o.v.
     2fa:	65 00 20 00 49 00 6e 00 70 00 75 00 74 00 20 00     e. .I.n.p.u.t. .
     30a:	44 00 65 00 76 00 69 00 63 00 65 00 00 00           D.e.v.i.c.e...

00000318 <ProductStringSerial>:
     318:	2a 03 4b 00 65 00 79 00 67 00 6c 00 6f 00 76 00     *.K.e.y.g.l.o.v.
     328:	65 00 20 00 53 00 65 00 72 00 69 00 61 00 6c 00     e. .S.e.r.i.a.l.
     338:	20 00 50 00 6f 00 72 00 74 00 00 00                  .P.o.r.t...

00000344 <ProductStringHID>:
     344:	2c 03 4b 00 65 00 79 00 67 00 6c 00 6f 00 76 00     ,.K.e.y.g.l.o.v.
     354:	65 00 20 00 49 00 6e 00 70 00 75 00 74 00 20 00     e. .I.n.p.u.t. .
     364:	44 00 65 00 76 00 69 00 63 00 65 00 00 00           D.e.v.i.c.e...

00000372 <_ZL21tone_pin_to_timer_PGM>:
     372:	02 00                                               ..

00000374 <__ctors_start>:
     374:	17 02       	muls	r17, r23

00000376 <__ctors_end>:
     376:	11 24       	eor	r1, r1
     378:	1f be       	out	0x3f, r1	; 63
     37a:	cf ef       	ldi	r28, 0xFF	; 255
     37c:	d0 e2       	ldi	r29, 0x20	; 32
     37e:	de bf       	out	0x3e, r29	; 62
     380:	cd bf       	out	0x3d, r28	; 61

00000382 <__do_copy_data>:
     382:	14 e0       	ldi	r17, 0x04	; 4
     384:	a0 e0       	ldi	r26, 0x00	; 0
     386:	b1 e0       	ldi	r27, 0x01	; 1
     388:	e4 ed       	ldi	r30, 0xD4	; 212
     38a:	f8 e8       	ldi	r31, 0x88	; 136
     38c:	00 e0       	ldi	r16, 0x00	; 0
     38e:	0b bf       	out	0x3b, r16	; 59
     390:	02 c0       	rjmp	.+4      	; 0x396 <__do_copy_data+0x14>
     392:	07 90       	elpm	r0, Z+
     394:	0d 92       	st	X+, r0
     396:	ac 36       	cpi	r26, 0x6C	; 108
     398:	b1 07       	cpc	r27, r17
     39a:	d9 f7       	brne	.-10     	; 0x392 <__do_copy_data+0x10>

0000039c <__do_clear_bss>:
     39c:	19 e0       	ldi	r17, 0x09	; 9
     39e:	ac e6       	ldi	r26, 0x6C	; 108
     3a0:	b4 e0       	ldi	r27, 0x04	; 4
     3a2:	01 c0       	rjmp	.+2      	; 0x3a6 <.do_clear_bss_start>

000003a4 <.do_clear_bss_loop>:
     3a4:	1d 92       	st	X+, r1

000003a6 <.do_clear_bss_start>:
     3a6:	ae 32       	cpi	r26, 0x2E	; 46
     3a8:	b1 07       	cpc	r27, r17
     3aa:	e1 f7       	brne	.-8      	; 0x3a4 <.do_clear_bss_loop>

000003ac <__do_global_ctors>:
     3ac:	13 e0       	ldi	r17, 0x03	; 3
     3ae:	c6 e7       	ldi	r28, 0x76	; 118
     3b0:	d3 e0       	ldi	r29, 0x03	; 3
     3b2:	04 c0       	rjmp	.+8      	; 0x3bc <.do_global_ctors_start>

000003b4 <.do_global_ctors_loop>:
     3b4:	22 97       	sbiw	r28, 0x02	; 2
     3b6:	fe 01       	movw	r30, r28
     3b8:	0e 94 e0 43 	call	0x87c0	; 0x87c0 <__tablejump__>

000003bc <.do_global_ctors_start>:
     3bc:	c4 37       	cpi	r28, 0x74	; 116
     3be:	d1 07       	cpc	r29, r17
     3c0:	c9 f7       	brne	.-14     	; 0x3b4 <.do_global_ctors_loop>
     3c2:	0e 94 47 27 	call	0x4e8e	; 0x4e8e <main>
     3c6:	0c 94 68 44 	jmp	0x88d0	; 0x88d0 <_exit>

000003ca <__bad_interrupt>:
     3ca:	1a ce       	rjmp	.-972    	; 0x0 <__vectors>

000003cc <_Z9modeCheckii>:

    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
     3cc:	ac 01       	movw	r20, r24
        if (modeStackPos < pos) {
     3ce:	e0 91 b3 08 	lds	r30, 0x08B3
     3d2:	f0 91 b4 08 	lds	r31, 0x08B4
     3d6:	e6 17       	cp	r30, r22
     3d8:	f7 07       	cpc	r31, r23
     3da:	14 f4       	brge	.+4      	; 0x3e0 <_Z9modeCheckii+0x14>
     3dc:	20 e0       	ldi	r18, 0x00	; 0
     3de:	0d c0       	rjmp	.+26     	; 0x3fa <_Z9modeCheckii+0x2e>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
     3e0:	20 e0       	ldi	r18, 0x00	; 0
     3e2:	e6 1b       	sub	r30, r22
     3e4:	f7 0b       	sbc	r31, r23
     3e6:	ee 0f       	add	r30, r30
     3e8:	ff 1f       	adc	r31, r31
     3ea:	e1 56       	subi	r30, 0x61	; 97
     3ec:	f7 4f       	sbci	r31, 0xF7	; 247
     3ee:	80 81       	ld	r24, Z
     3f0:	91 81       	ldd	r25, Z+1	; 0x01
     3f2:	84 17       	cp	r24, r20
     3f4:	95 07       	cpc	r25, r21
     3f6:	09 f4       	brne	.+2      	; 0x3fa <_Z9modeCheckii+0x2e>
     3f8:	21 e0       	ldi	r18, 0x01	; 1
    }
     3fa:	82 2f       	mov	r24, r18
     3fc:	08 95       	ret

000003fe <EVENT_USB_Device_Connect>:
				PORTF &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTF = ((PORTF & ~LEDS_ALL_LEDS_F) | LEDMask);
     3fe:	81 b3       	in	r24, 0x11	; 17
     400:	8f 71       	andi	r24, 0x1F	; 31
     402:	80 6c       	ori	r24, 0xC0	; 192
     404:	81 bb       	out	0x11, r24	; 17
 */
void EVENT_USB_Device_Connect(void)
{
    /* Indicate USB enumerating */
    LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     406:	08 95       	ret

00000408 <EVENT_USB_Device_Disconnect>:
     408:	81 b3       	in	r24, 0x11	; 17
     40a:	8f 71       	andi	r24, 0x1F	; 31
     40c:	80 66       	ori	r24, 0x60	; 96
     40e:	81 bb       	out	0x11, r24	; 17
 */
void EVENT_USB_Device_Disconnect(void)
{
    /* Indicate USB not ready */
    LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     410:	08 95       	ret

00000412 <ProcessHIDReport>:
        This is where you need to process the reports being sent from the host to the device.
        DataArray is an array holding the last report from the host. This function is called
        each time the host has sent a report to the device.
    */

}
     412:	08 95       	ret

00000414 <_Z25Keyboard_ProcessLEDReporth>:
 */
void Keyboard_ProcessLEDReport(const uint8_t LEDStatus)
{
    uint8_t LEDMask = LEDS_LED2;

    if (LEDStatus & HID_KEYBOARD_LED_NUMLOCK)
     414:	28 2f       	mov	r18, r24
      LEDMask |= LEDS_LED2;

    if (LEDStatus & HID_KEYBOARD_LED_CAPSLOCK)
     416:	81 fd       	sbrc	r24, 1
     418:	02 c0       	rjmp	.+4      	; 0x41e <_Z25Keyboard_ProcessLEDReporth+0xa>
     41a:	90 e4       	ldi	r25, 0x40	; 64
     41c:	01 c0       	rjmp	.+2      	; 0x420 <_Z25Keyboard_ProcessLEDReporth+0xc>
     41e:	90 ec       	ldi	r25, 0xC0	; 192
      LEDMask |= LEDS_LED3;

    if (LEDStatus & HID_KEYBOARD_LED_SCROLLLOCK)
     420:	22 fd       	sbrc	r18, 2
      LEDMask |= LEDS_LED4;
     422:	90 64       	ori	r25, 0x40	; 64
     424:	81 b3       	in	r24, 0x11	; 17
     426:	8f 71       	andi	r24, 0x1F	; 31
     428:	98 2b       	or	r25, r24
     42a:	91 bb       	out	0x11, r25	; 17

    /* Set the status LEDs to the current Keyboard LED status */
    LEDs_SetAllLEDs(LEDMask);
     42c:	08 95       	ret

0000042e <_GLOBAL__I_HIDReportInData>:
    #ifndef USE_LUFA
        #include <Wire.h>
    #endif
    #include "Adxl345.h"

    Accelerometer accel;
     42e:	83 ed       	ldi	r24, 0xD3	; 211
     430:	96 e0       	ldi	r25, 0x06	; 6
     432:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <_ZN13AccelerometerC1Ev>
    #ifndef USE_LUFA
        #include <Wire.h>
    #endif
    #include "ITG3200.h"

    ITG3200 gyro = ITG3200();
     436:	83 eb       	ldi	r24, 0xB3	; 179
     438:	97 e0       	ldi	r25, 0x07	; 7
     43a:	0c 94 27 34 	jmp	0x684e	; 0x684e <_ZN7ITG3200C1Ev>

0000043e <HID_Task>:
        Endpoint_ClearOUT();
    }

}

void HID_Task(void)
     43e:	0f 93       	push	r16
     440:	1f 93       	push	r17
{
    /* Device must be connected and configured for the task to run */
    if (USB_DeviceState != DEVICE_STATE_Configured)
     442:	80 91 25 09 	lds	r24, 0x0925
     446:	84 30       	cpi	r24, 0x04	; 4
     448:	91 f5       	brne	.+100    	; 0x4ae <HID_Task+0x70>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     44a:	85 e0       	ldi	r24, 0x05	; 5
     44c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     450:	80 91 e8 00 	lds	r24, 0x00E8
      return;

    Endpoint_SelectEndpoint(GENERIC_OUT_EPNUM);

    /* Check to see if a packet has been sent from the host */
    if (Endpoint_IsOUTReceived())
     454:	82 ff       	sbrs	r24, 2
     456:	11 c0       	rjmp	.+34     	; 0x47a <HID_Task+0x3c>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     458:	80 91 e8 00 	lds	r24, 0x00E8
    {
        /* Check to see if the packet contains data */
        if (Endpoint_IsReadWriteAllowed())
     45c:	85 ff       	sbrs	r24, 5
     45e:	08 c0       	rjmp	.+16     	; 0x470 <HID_Task+0x32>
        {
            /* Read Generic Report Data */
            Endpoint_Read_Stream_LE(&HIDReportOutData, sizeof(HIDReportOutData), NULL);
     460:	8e e7       	ldi	r24, 0x7E	; 126
     462:	94 e0       	ldi	r25, 0x04	; 4
     464:	69 e0       	ldi	r22, 0x09	; 9
     466:	70 e0       	ldi	r23, 0x00	; 0
     468:	40 e0       	ldi	r20, 0x00	; 0
     46a:	50 e0       	ldi	r21, 0x00	; 0
     46c:	0e 94 57 3d 	call	0x7aae	; 0x7aae <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     470:	80 91 e8 00 	lds	r24, 0x00E8
     474:	8b 77       	andi	r24, 0x7B	; 123
     476:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     47a:	84 e0       	ldi	r24, 0x04	; 4
     47c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     480:	80 91 e8 00 	lds	r24, 0x00E8
    }

    Endpoint_SelectEndpoint(GENERIC_IN_EPNUM);

    /* Check to see if the host is ready to accept another packet */
    if (Endpoint_IsINReady())
     484:	80 ff       	sbrs	r24, 0
     486:	13 c0       	rjmp	.+38     	; 0x4ae <HID_Task+0x70>
    {
        /* Write Generic Report Data */
        Endpoint_Write_Stream_LE(&HIDReportInData, sizeof(HIDReportInData), NULL);
     488:	05 e7       	ldi	r16, 0x75	; 117
     48a:	14 e0       	ldi	r17, 0x04	; 4
     48c:	c8 01       	movw	r24, r16
     48e:	69 e0       	ldi	r22, 0x09	; 9
     490:	70 e0       	ldi	r23, 0x00	; 0
     492:	40 e0       	ldi	r20, 0x00	; 0
     494:	50 e0       	ldi	r21, 0x00	; 0
     496:	0e 94 a9 3d 	call	0x7b52	; 0x7b52 <Endpoint_Write_Stream_LE>
        
        /* Clean out report data after sending */
        memset(&HIDReportInData, 0, sizeof(HIDReportInData));
     49a:	89 e0       	ldi	r24, 0x09	; 9
     49c:	f8 01       	movw	r30, r16
     49e:	11 92       	st	Z+, r1
     4a0:	8a 95       	dec	r24
     4a2:	e9 f7       	brne	.-6      	; 0x49e <HID_Task+0x60>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     4a4:	80 91 e8 00 	lds	r24, 0x00E8
     4a8:	8e 77       	andi	r24, 0x7E	; 126
     4aa:	80 93 e8 00 	sts	0x00E8, r24

        /* Finalize the stream transfer to send the last packet */
        Endpoint_ClearIN();
    }
}
     4ae:	1f 91       	pop	r17
     4b0:	0f 91       	pop	r16
     4b2:	08 95       	ret

000004b4 <CDC_Task>:
            break;
    }
}

/** Function to manage CDC data transmission and reception to and from the host. */
void CDC_Task(void)
     4b4:	cf 93       	push	r28
     4b6:	df 93       	push	r29
{
    /* Device must be connected and configured for the task to run */
    if (USB_DeviceState != DEVICE_STATE_Configured)
     4b8:	80 91 25 09 	lds	r24, 0x0925
     4bc:	84 30       	cpi	r24, 0x04	; 4
     4be:	09 f0       	breq	.+2      	; 0x4c2 <CDC_Task+0xe>
     4c0:	89 c0       	rjmp	.+274    	; 0x5d4 <CDC_Task+0x120>
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
     4c2:	8f b7       	in	r24, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
     4c4:	f8 94       	cli
			uint16_t Count;

			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
			GlobalInterruptDisable();
			
			Count = Buffer->Count;
     4c6:	20 91 9b 05 	lds	r18, 0x059B
     4ca:	30 91 9c 05 	lds	r19, 0x059C
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
     4ce:	8f bf       	out	0x3f, r24	; 63

    uint16_t BufferCount;

    /* Send data packet if anything is waiting */
    BufferCount = RingBuffer_GetCount(&HostTXSerial_Buffer);
    if (BufferCount && LineEncodingData.BaudRateBPS)
     4d0:	21 15       	cp	r18, r1
     4d2:	31 05       	cpc	r19, r1
     4d4:	09 f4       	brne	.+2      	; 0x4d8 <CDC_Task+0x24>
     4d6:	48 c0       	rjmp	.+144    	; 0x568 <CDC_Task+0xb4>
     4d8:	80 91 ce 02 	lds	r24, 0x02CE
     4dc:	90 91 cf 02 	lds	r25, 0x02CF
     4e0:	a0 91 d0 02 	lds	r26, 0x02D0
     4e4:	b0 91 d1 02 	lds	r27, 0x02D1
     4e8:	00 97       	sbiw	r24, 0x00	; 0
     4ea:	a1 05       	cpc	r26, r1
     4ec:	b1 05       	cpc	r27, r1
     4ee:	09 f4       	brne	.+2      	; 0x4f2 <CDC_Task+0x3e>
     4f0:	3b c0       	rjmp	.+118    	; 0x568 <CDC_Task+0xb4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     4f2:	82 e0       	ldi	r24, 0x02	; 2
     4f4:	80 93 e9 00 	sts	0x00E9, r24
     4f8:	a9 01       	movw	r20, r18
		 *
		 *  \return Next data element stored in the buffer.
		 */
		static inline uint8_t RingBuffer_Remove(RingBuffer_t* Buffer)
		{
			GCC_FORCE_POINTER_ACCESS(Buffer);
     4fa:	a2 e9       	ldi	r26, 0x92	; 146
    {
        /* Select the Serial TX Endpoint */
        Endpoint_SelectEndpoint(CDC_TX_EPNUM);

        /* Write the byte(s) to the Endpoint */
        for (int i = 0; i < CDC_TXRX_EPSIZE && BufferCount; i++, BufferCount--)
     4fc:	b5 e0       	ldi	r27, 0x05	; 5
     4fe:	b9 01       	movw	r22, r18
     500:	6f 50       	subi	r22, 0x0F	; 15
     502:	70 40       	sbci	r23, 0x00	; 0
     504:	ed 01       	movw	r28, r26
		
			uint8_t Data = *Buffer->Out;
     506:	ea 81       	ldd	r30, Y+2	; 0x02
     508:	fb 81       	ldd	r31, Y+3	; 0x03
     50a:	31 91       	ld	r19, Z+

			if (++Buffer->Out == Buffer->End)
     50c:	fb 83       	std	Y+3, r31	; 0x03
     50e:	ea 83       	std	Y+2, r30	; 0x02
     510:	8e 81       	ldd	r24, Y+6	; 0x06
     512:	9f 81       	ldd	r25, Y+7	; 0x07
     514:	e8 17       	cp	r30, r24
     516:	f9 07       	cpc	r31, r25
     518:	21 f4       	brne	.+8      	; 0x522 <CDC_Task+0x6e>
			  Buffer->Out = Buffer->Start;
     51a:	8c 81       	ldd	r24, Y+4	; 0x04
     51c:	9d 81       	ldd	r25, Y+5	; 0x05
     51e:	9b 83       	std	Y+3, r25	; 0x03
     520:	8a 83       	std	Y+2, r24	; 0x02
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
     522:	2f b7       	in	r18, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
     524:	f8 94       	cli

			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
			GlobalInterruptDisable();
			
			Buffer->Count--;
     526:	89 85       	ldd	r24, Y+9	; 0x09
     528:	9a 85       	ldd	r25, Y+10	; 0x0a
     52a:	01 97       	sbiw	r24, 0x01	; 1
     52c:	9a 87       	std	Y+10, r25	; 0x0a
     52e:	89 87       	std	Y+9, r24	; 0x09
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
     530:	2f bf       	out	0x3f, r18	; 63
        {
            UEDATX = RingBuffer_Remove(&HostTXSerial_Buffer); // write one byte
     532:	30 93 f1 00 	sts	0x00F1, r19
    {
        /* Select the Serial TX Endpoint */
        Endpoint_SelectEndpoint(CDC_TX_EPNUM);

        /* Write the byte(s) to the Endpoint */
        for (int i = 0; i < CDC_TXRX_EPSIZE && BufferCount; i++, BufferCount--)
     536:	46 17       	cp	r20, r22
     538:	57 07       	cpc	r21, r23
     53a:	19 f0       	breq	.+6      	; 0x542 <CDC_Task+0x8e>
     53c:	41 50       	subi	r20, 0x01	; 1
     53e:	50 40       	sbci	r21, 0x00	; 0
     540:	09 f7       	brne	.-62     	; 0x504 <CDC_Task+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
     542:	20 91 f2 00 	lds	r18, 0x00F2
     546:	30 91 f3 00 	lds	r19, 0x00F3
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     54a:	80 91 e8 00 	lds	r24, 0x00E8
     54e:	8e 77       	andi	r24, 0x7E	; 126
     550:	80 93 e8 00 	sts	0x00E8, r24
        /* Finalize the stream transfer to send the last packet */
        Endpoint_ClearIN();

        /* If the last packet filled the endpoint, send an empty packet to release the buffer on
         * the receiver (otherwise all data will be cached until a non-full packet is received) */
        if (IsFull)
     554:	20 31       	cpi	r18, 0x10	; 16
     556:	31 05       	cpc	r19, r1
     558:	39 f4       	brne	.+14     	; 0x568 <CDC_Task+0xb4>
        {
            /* Wait until the endpoint is ready for another packet */
            Endpoint_WaitUntilReady();
     55a:	0e 94 fc 3a 	call	0x75f8	; 0x75f8 <Endpoint_WaitUntilReady>
     55e:	80 91 e8 00 	lds	r24, 0x00E8
     562:	8e 77       	andi	r24, 0x7E	; 126
     564:	80 93 e8 00 	sts	0x00E8, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     568:	83 e0       	ldi	r24, 0x03	; 3
     56a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     56e:	80 91 e8 00 	lds	r24, 0x00E8

    /* Select the Serial RX Endpoint */
    Endpoint_SelectEndpoint(CDC_RX_EPNUM);

    /* Store any received data from the host */
    if (Endpoint_IsOUTReceived())
     572:	82 ff       	sbrs	r24, 2
     574:	2f c0       	rjmp	.+94     	; 0x5d4 <CDC_Task+0x120>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
     576:	60 91 f2 00 	lds	r22, 0x00F2
     57a:	70 91 f3 00 	lds	r23, 0x00F3
     57e:	40 e0       	ldi	r20, 0x00	; 0
		 *  \param[in]     Data    Data element to insert into the buffer.
		 */
		static inline void RingBuffer_Insert(RingBuffer_t* Buffer,
		                                     const uint8_t Data)
		{
			GCC_FORCE_POINTER_ACCESS(Buffer);
     580:	a7 e8       	ldi	r26, 0x87	; 135
    {
        BufferCount = Endpoint_BytesInEndpoint();
        for (uint8_t i = 0; i < BufferCount; i++)
        {
            uint8_t b = UEDATX;
     582:	b4 e0       	ldi	r27, 0x04	; 4
     584:	1d c0       	rjmp	.+58     	; 0x5c0 <CDC_Task+0x10c>
     586:	80 91 f1 00 	lds	r24, 0x00F1
     58a:	ed 01       	movw	r28, r26

			*Buffer->In = Data;
     58c:	e8 81       	ld	r30, Y
     58e:	f9 81       	ldd	r31, Y+1	; 0x01
     590:	80 83       	st	Z, r24

			if (++Buffer->In == Buffer->End)
     592:	88 81       	ld	r24, Y
     594:	99 81       	ldd	r25, Y+1	; 0x01
     596:	01 96       	adiw	r24, 0x01	; 1
     598:	99 83       	std	Y+1, r25	; 0x01
     59a:	88 83       	st	Y, r24
     59c:	2e 81       	ldd	r18, Y+6	; 0x06
     59e:	3f 81       	ldd	r19, Y+7	; 0x07
     5a0:	82 17       	cp	r24, r18
     5a2:	93 07       	cpc	r25, r19
     5a4:	21 f4       	brne	.+8      	; 0x5ae <CDC_Task+0xfa>
			  Buffer->In = Buffer->Start;
     5a6:	8c 81       	ldd	r24, Y+4	; 0x04
     5a8:	9d 81       	ldd	r25, Y+5	; 0x05
     5aa:	99 83       	std	Y+1, r25	; 0x01
     5ac:	88 83       	st	Y, r24
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
     5ae:	2f b7       	in	r18, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
     5b0:	f8 94       	cli

			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
			GlobalInterruptDisable();
			
			Buffer->Count++;
     5b2:	89 85       	ldd	r24, Y+9	; 0x09
     5b4:	9a 85       	ldd	r25, Y+10	; 0x0a
     5b6:	01 96       	adiw	r24, 0x01	; 1
     5b8:	9a 87       	std	Y+10, r25	; 0x0a
     5ba:	89 87       	std	Y+9, r24	; 0x09
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
     5bc:	2f bf       	out	0x3f, r18	; 63

    /* Store any received data from the host */
    if (Endpoint_IsOUTReceived())
    {
        BufferCount = Endpoint_BytesInEndpoint();
        for (uint8_t i = 0; i < BufferCount; i++)
     5be:	4f 5f       	subi	r20, 0xFF	; 255
     5c0:	84 2f       	mov	r24, r20
     5c2:	90 e0       	ldi	r25, 0x00	; 0
     5c4:	86 17       	cp	r24, r22
     5c6:	97 07       	cpc	r25, r23
     5c8:	f0 f2       	brcs	.-68     	; 0x586 <CDC_Task+0xd2>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     5ca:	80 91 e8 00 	lds	r24, 0x00E8
     5ce:	8b 77       	andi	r24, 0x7B	; 123
     5d0:	80 93 e8 00 	sts	0x00E8, r24

        /* Finalize the stream transfer to receive the last packet */
        Endpoint_ClearOUT();
    }

}
     5d4:	df 91       	pop	r29
     5d6:	cf 91       	pop	r28
     5d8:	08 95       	ret

000005da <EVENT_USB_Device_ControlRequest>:

/** Event handler for the USB_ControlRequest event. This is used to catch and process control requests sent to
 *  the device from the USB host before passing along unhandled control requests to the library for processing
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
     5da:	0f 93       	push	r16
     5dc:	1f 93       	push	r17
{
    switch (USB_ControlRequest.bRequest)
     5de:	80 91 27 09 	lds	r24, 0x0927
     5e2:	80 32       	cpi	r24, 0x20	; 32
     5e4:	09 f4       	brne	.+2      	; 0x5e8 <EVENT_USB_Device_ControlRequest+0xe>
     5e6:	4d c0       	rjmp	.+154    	; 0x682 <EVENT_USB_Device_ControlRequest+0xa8>
     5e8:	81 32       	cpi	r24, 0x21	; 33
     5ea:	30 f4       	brcc	.+12     	; 0x5f8 <EVENT_USB_Device_ControlRequest+0x1e>
     5ec:	81 30       	cpi	r24, 0x01	; 1
     5ee:	51 f0       	breq	.+20     	; 0x604 <EVENT_USB_Device_ControlRequest+0x2a>
     5f0:	89 30       	cpi	r24, 0x09	; 9
     5f2:	09 f0       	breq	.+2      	; 0x5f6 <EVENT_USB_Device_ControlRequest+0x1c>
     5f4:	5f c0       	rjmp	.+190    	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
     5f6:	1d c0       	rjmp	.+58     	; 0x632 <EVENT_USB_Device_ControlRequest+0x58>
     5f8:	81 32       	cpi	r24, 0x21	; 33
     5fa:	81 f1       	breq	.+96     	; 0x65c <EVENT_USB_Device_ControlRequest+0x82>
     5fc:	82 32       	cpi	r24, 0x22	; 34
     5fe:	09 f0       	breq	.+2      	; 0x602 <EVENT_USB_Device_ControlRequest+0x28>
     600:	59 c0       	rjmp	.+178    	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
     602:	4d c0       	rjmp	.+154    	; 0x69e <EVENT_USB_Device_ControlRequest+0xc4>
    {
        case HID_REQ_GetReport:
            if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     604:	80 91 26 09 	lds	r24, 0x0926
     608:	81 3a       	cpi	r24, 0xA1	; 161
     60a:	09 f0       	breq	.+2      	; 0x60e <EVENT_USB_Device_ControlRequest+0x34>
     60c:	53 c0       	rjmp	.+166    	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     60e:	80 91 e8 00 	lds	r24, 0x00E8
     612:	87 7f       	andi	r24, 0xF7	; 247
     614:	80 93 e8 00 	sts	0x00E8, r24
                //CreateHIDReport(HIDReportInData);

                Endpoint_ClearSETUP();

                /* Write the report data to the control endpoint */
                Endpoint_Write_Control_Stream_LE(&HIDReportInData, sizeof(HIDReportInData));
     618:	05 e7       	ldi	r16, 0x75	; 117
     61a:	14 e0       	ldi	r17, 0x04	; 4
     61c:	c8 01       	movw	r24, r16
     61e:	69 e0       	ldi	r22, 0x09	; 9
     620:	70 e0       	ldi	r23, 0x00	; 0
     622:	0e 94 57 3c 	call	0x78ae	; 0x78ae <Endpoint_Write_Control_Stream_LE>

                /* Clean out report data after sending */
                memset(&HIDReportInData, 0, sizeof(HIDReportInData));
     626:	89 e0       	ldi	r24, 0x09	; 9
     628:	f8 01       	movw	r30, r16
     62a:	11 92       	st	Z+, r1
     62c:	8a 95       	dec	r24
     62e:	e9 f7       	brne	.-6      	; 0x62a <EVENT_USB_Device_ControlRequest+0x50>
     630:	24 c0       	rjmp	.+72     	; 0x67a <EVENT_USB_Device_ControlRequest+0xa0>
                Endpoint_ClearOUT();
            }

            break;
        case HID_REQ_SetReport:
            if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     632:	80 91 26 09 	lds	r24, 0x0926
     636:	81 32       	cpi	r24, 0x21	; 33
     638:	e9 f5       	brne	.+122    	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
     63a:	80 91 e8 00 	lds	r24, 0x00E8
     63e:	87 7f       	andi	r24, 0xF7	; 247
     640:	80 93 e8 00 	sts	0x00E8, r24
            {
                Endpoint_ClearSETUP();

                /* Read the report data from the control endpoint */
                Endpoint_Read_Control_Stream_LE(&HIDReportOutData, sizeof(HIDReportOutData));
     644:	8e e7       	ldi	r24, 0x7E	; 126
     646:	94 e0       	ldi	r25, 0x04	; 4
     648:	69 e0       	ldi	r22, 0x09	; 9
     64a:	70 e0       	ldi	r23, 0x00	; 0
     64c:	0e 94 b5 3c 	call	0x796a	; 0x796a <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     650:	80 91 e8 00 	lds	r24, 0x00E8
     654:	8e 77       	andi	r24, 0x7E	; 126
     656:	80 93 e8 00 	sts	0x00E8, r24
     65a:	2c c0       	rjmp	.+88     	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
                ProcessHIDReport(HIDReportOutData);
            }

            break;
        case CDC_REQ_GetLineEncoding:
            if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     65c:	80 91 26 09 	lds	r24, 0x0926
     660:	81 3a       	cpi	r24, 0xA1	; 161
     662:	41 f5       	brne	.+80     	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     664:	80 91 e8 00 	lds	r24, 0x00E8
     668:	87 7f       	andi	r24, 0xF7	; 247
     66a:	80 93 e8 00 	sts	0x00E8, r24
            {
                Endpoint_ClearSETUP();

                /* Write the line coding data to the control endpoint */
                Endpoint_Write_Control_Stream_LE(&LineEncodingData, sizeof(CDC_LineEncoding_t));
     66e:	8e ec       	ldi	r24, 0xCE	; 206
     670:	92 e0       	ldi	r25, 0x02	; 2
     672:	67 e0       	ldi	r22, 0x07	; 7
     674:	70 e0       	ldi	r23, 0x00	; 0
     676:	0e 94 57 3c 	call	0x78ae	; 0x78ae <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     67a:	80 91 e8 00 	lds	r24, 0x00E8
     67e:	8b 77       	andi	r24, 0x7B	; 123
     680:	ea cf       	rjmp	.-44     	; 0x656 <EVENT_USB_Device_ControlRequest+0x7c>
                Endpoint_ClearOUT();
            }

            break;
        case CDC_REQ_SetLineEncoding:
            if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     682:	80 91 26 09 	lds	r24, 0x0926
     686:	81 32       	cpi	r24, 0x21	; 33
     688:	a9 f4       	brne	.+42     	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     68a:	80 91 e8 00 	lds	r24, 0x00E8
     68e:	87 7f       	andi	r24, 0xF7	; 247
     690:	80 93 e8 00 	sts	0x00E8, r24
            {
                Endpoint_ClearSETUP();

                /* Read the line coding data in from the host into the global struct */
                Endpoint_Read_Control_Stream_LE(&LineEncodingData, sizeof(CDC_LineEncoding_t));
     694:	8e ec       	ldi	r24, 0xCE	; 206
     696:	92 e0       	ldi	r25, 0x02	; 2
     698:	67 e0       	ldi	r22, 0x07	; 7
     69a:	70 e0       	ldi	r23, 0x00	; 0
     69c:	d7 cf       	rjmp	.-82     	; 0x64c <EVENT_USB_Device_ControlRequest+0x72>
                Endpoint_ClearIN();
            }

            break;
        case CDC_REQ_SetControlLineState:
            if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     69e:	80 91 26 09 	lds	r24, 0x0926
     6a2:	81 32       	cpi	r24, 0x21	; 33
     6a4:	39 f4       	brne	.+14     	; 0x6b4 <EVENT_USB_Device_ControlRequest+0xda>
     6a6:	80 91 e8 00 	lds	r24, 0x00E8
     6aa:	87 7f       	andi	r24, 0xF7	; 247
     6ac:	80 93 e8 00 	sts	0x00E8, r24
            {
                Endpoint_ClearSETUP();
                Endpoint_ClearStatusStage();
     6b0:	0e 94 db 3a 	call	0x75b6	; 0x75b6 <Endpoint_ClearStatusStage>
                */
            }

            break;
    }
}
     6b4:	1f 91       	pop	r17
     6b6:	0f 91       	pop	r16
     6b8:	08 95       	ret

000006ba <EVENT_USB_Device_ConfigurationChanged>:
}

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the keyboard and mouse device endpoints.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
     6ba:	bf 92       	push	r11
     6bc:	cf 92       	push	r12
     6be:	df 92       	push	r13
     6c0:	ef 92       	push	r14
     6c2:	ff 92       	push	r15
     6c4:	0f 93       	push	r16
     6c6:	1f 93       	push	r17
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size)));
     6c8:	81 e0       	ldi	r24, 0x01	; 1
     6ca:	61 ec       	ldi	r22, 0xC1	; 193
     6cc:	42 e0       	ldi	r20, 0x02	; 2
     6ce:	0e 94 a6 3a 	call	0x754c	; 0x754c <Endpoint_ConfigureEndpoint_Prv>
     6d2:	08 2f       	mov	r16, r24
                                                CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
    ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPNUM, EP_TYPE_BULK, ENDPOINT_DIR_OUT,
                                                CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);

    /* Reset line encoding baud rate so that the host knows to send new values */
    LineEncodingData.BaudRateBPS = 0;
     6d4:	82 e0       	ldi	r24, 0x02	; 2
     6d6:	61 e8       	ldi	r22, 0x81	; 129
     6d8:	42 e1       	ldi	r20, 0x12	; 18
     6da:	0e 94 a6 3a 	call	0x754c	; 0x754c <Endpoint_ConfigureEndpoint_Prv>
     6de:	c8 2e       	mov	r12, r24
     6e0:	83 e0       	ldi	r24, 0x03	; 3
     6e2:	60 e8       	ldi	r22, 0x80	; 128
     6e4:	42 e1       	ldi	r20, 0x12	; 18
     6e6:	0e 94 a6 3a 	call	0x754c	; 0x754c <Endpoint_ConfigureEndpoint_Prv>
     6ea:	e8 2e       	mov	r14, r24
     6ec:	10 92 ce 02 	sts	0x02CE, r1
     6f0:	10 92 cf 02 	sts	0x02CF, r1
     6f4:	10 92 d0 02 	sts	0x02D0, r1
     6f8:	10 92 d1 02 	sts	0x02D1, r1
     6fc:	84 e0       	ldi	r24, 0x04	; 4
     6fe:	61 ec       	ldi	r22, 0xC1	; 193
     700:	42 e1       	ldi	r20, 0x12	; 18
     702:	0e 94 a6 3a 	call	0x754c	; 0x754c <Endpoint_ConfigureEndpoint_Prv>
     706:	b8 2e       	mov	r11, r24
    ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
                                                CDC_NOTIFICATION_EPSIZE, ENDPOINT_BANK_SINGLE);
    ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_TX_EPNUM, EP_TYPE_BULK, ENDPOINT_DIR_IN,
                                                CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
    ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_RX_EPNUM, EP_TYPE_BULK, ENDPOINT_DIR_OUT,
                                                CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
     708:	85 e0       	ldi	r24, 0x05	; 5
     70a:	60 ec       	ldi	r22, 0xC0	; 192
     70c:	42 e1       	ldi	r20, 0x12	; 18
     70e:	0e 94 a6 3a 	call	0x754c	; 0x754c <Endpoint_ConfigureEndpoint_Prv>
     712:	68 2f       	mov	r22, r24
     714:	10 e0       	ldi	r17, 0x00	; 0
     716:	dd 24       	eor	r13, r13
     718:	0c 21       	and	r16, r12
     71a:	1d 21       	and	r17, r13
     71c:	01 70       	andi	r16, 0x01	; 1
     71e:	10 70       	andi	r17, 0x00	; 0
     720:	ff 24       	eor	r15, r15
     722:	0e 21       	and	r16, r14
     724:	1f 21       	and	r17, r15
    /* Reset line encoding baud rate so that the host knows to send new values */
    LineEncodingData.BaudRateBPS = 0;

    /* Setup HID Report Endpoints */
    ConfigSuccess &= Endpoint_ConfigureEndpoint(GENERIC_IN_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
                                                GENERIC_EPSIZE, ENDPOINT_BANK_SINGLE);
     726:	40 e0       	ldi	r20, 0x00	; 0
     728:	50 e0       	ldi	r21, 0x00	; 0
     72a:	01 2b       	or	r16, r17
     72c:	11 f0       	breq	.+4      	; 0x732 <EVENT_USB_Device_ConfigurationChanged+0x78>
     72e:	41 e0       	ldi	r20, 0x01	; 1
     730:	50 e0       	ldi	r21, 0x00	; 0
     732:	8b 2d       	mov	r24, r11
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	48 23       	and	r20, r24
     738:	59 23       	and	r21, r25
    ConfigSuccess &= Endpoint_ConfigureEndpoint(GENERIC_OUT_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_OUT,
                                                GENERIC_EPSIZE, ENDPOINT_BANK_SINGLE);

    /* Indicate endpoint configuration success or failure */
    LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     73a:	20 e0       	ldi	r18, 0x00	; 0
     73c:	30 e0       	ldi	r19, 0x00	; 0
     73e:	45 2b       	or	r20, r21
     740:	11 f0       	breq	.+4      	; 0x746 <EVENT_USB_Device_ConfigurationChanged+0x8c>
     742:	21 e0       	ldi	r18, 0x01	; 1
     744:	30 e0       	ldi	r19, 0x00	; 0
     746:	86 2f       	mov	r24, r22
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	28 23       	and	r18, r24
     74c:	39 23       	and	r19, r25
     74e:	23 2b       	or	r18, r19
     750:	11 f4       	brne	.+4      	; 0x756 <EVENT_USB_Device_ConfigurationChanged+0x9c>
     752:	90 e2       	ldi	r25, 0x20	; 32
     754:	01 c0       	rjmp	.+2      	; 0x758 <EVENT_USB_Device_ConfigurationChanged+0x9e>
     756:	90 e4       	ldi	r25, 0x40	; 64
     758:	81 b3       	in	r24, 0x11	; 17
     75a:	8f 71       	andi	r24, 0x1F	; 31
     75c:	98 2b       	or	r25, r24
     75e:	91 bb       	out	0x11, r25	; 17
}
     760:	1f 91       	pop	r17
     762:	0f 91       	pop	r16
     764:	ff 90       	pop	r15
     766:	ef 90       	pop	r14
     768:	df 90       	pop	r13
     76a:	cf 90       	pop	r12
     76c:	bf 90       	pop	r11
     76e:	08 95       	ret

00000770 <SetupHardware>:
            defined(__AVR_ATmega16U4__)  || defined(__AVR_ATmega32U4__) ||  \
            defined(__AVR_ATmega32U6__)))
        // note the JTD bit must be written twice within 4 clock cycles to disable JTAG
        // you must also set the IVSEL bit at the same time, which requires IVCE to be set first
        // port pull-up resistors are enabled - PUD(Pull Up Disable) = 0
        MCUCR = (1 << JTD) | (1 << IVCE) | (0 << PUD);
     770:	81 e8       	ldi	r24, 0x81	; 129
     772:	85 bf       	out	0x35, r24	; 53
        MCUCR = (1 << JTD) | (0 << IVSEL) | (0 << IVCE) | (0 << PUD);
     774:	20 e8       	ldi	r18, 0x80	; 128
     776:	25 bf       	out	0x35, r18	; 53
    #endif

    /* Disable watchdog if enabled by bootloader/fuses */
    MCUSR &= ~(1 << WDRF);
     778:	84 b7       	in	r24, 0x34	; 52
     77a:	87 7f       	andi	r24, 0xF7	; 247
     77c:	84 bf       	out	0x34, r24	; 52
    wdt_disable();
     77e:	88 e1       	ldi	r24, 0x18	; 24
     780:	0f b6       	in	r0, 0x3f	; 63
     782:	f8 94       	cli
     784:	80 93 60 00 	sts	0x0060, r24
     788:	10 92 60 00 	sts	0x0060, r1
     78c:	0f be       	out	0x3f, r0	; 63

	//cli();
	//CLKPR = 0x80;
	//CLKPR = CPU_PRESCALER;
	// timer 0, fast pwm mode
	TCCR0A = (1<<WGM01) | (1<<WGM00);
     78e:	83 e0       	ldi	r24, 0x03	; 3
     790:	84 bd       	out	0x24, r24	; 36
	TCCR0B = (1<<CS01) | (1<<CS00);		// div 64 prescaler
     792:	85 bd       	out	0x25, r24	; 37
//	sbi(TIMSK0, TOIE0);
	// timer 1, 8 bit phase correct pwm
	TCCR1A = (1<<WGM10);
     794:	91 e0       	ldi	r25, 0x01	; 1
     796:	90 93 80 00 	sts	0x0080, r25
	TCCR1B = (1<<CS11);			// div 8 prescaler
     79a:	82 e0       	ldi	r24, 0x02	; 2
     79c:	80 93 81 00 	sts	0x0081, r24
	DIDR0 = 0;
	DIDR2 = 0;
#endif
#if defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__)
	// timer 2, 8 bit phase correct pwm
	TCCR2A = (1<<WGM20);
     7a0:	90 93 b0 00 	sts	0x00B0, r25
	TCCR2B = (1<<CS21);			// div 8 prescaler
     7a4:	80 93 b1 00 	sts	0x00B1, r24
	// timer 3, 8 bit phase correct pwm
	TCCR3A = (1<<WGM30);
     7a8:	90 93 90 00 	sts	0x0090, r25
	TCCR3B = (1<<CS31);			// div 8 prescaler
     7ac:	80 93 91 00 	sts	0x0091, r24
	// ADC
//	ADCSRA = (1<<ADEN) | (ADC_PRESCALER + ADC_PRESCALE_ADJUST);
//	ADCSRB = DEFAULT_ADCSRB;
	DIDR0 = 0;
     7b0:	10 92 7e 00 	sts	0x007E, r1
#endif

    /* Disable clock division */
    //clock_prescale_set(clock_div_1);
        CPU_PRESCALE(CPU_8MHz); // 3.3v AVR shouldn't run faster than 8MHz
     7b4:	e1 e6       	ldi	r30, 0x61	; 97
     7b6:	f0 e0       	ldi	r31, 0x00	; 0
     7b8:	20 83       	st	Z, r18
     7ba:	90 83       	st	Z, r25

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS_D;
     7bc:	56 9a       	sbi	0x0a, 6	; 10
				DDRF  |=  LEDS_ALL_LEDS_F;
     7be:	80 b3       	in	r24, 0x10	; 16
     7c0:	80 6e       	ori	r24, 0xE0	; 224
     7c2:	80 bb       	out	0x10, r24	; 16
				PORTF &= ~LEDS_ALL_LEDS_F;
     7c4:	81 b3       	in	r24, 0x11	; 17
     7c6:	8f 71       	andi	r24, 0x1F	; 31
     7c8:	81 bb       	out	0x11, r24	; 17

    /* Hardware Initialization */
    LEDs_Init();
    USB_Init();
     7ca:	0e 94 77 3b 	call	0x76ee	; 0x76ee <USB_Init>
	sei();
     7ce:	78 94       	sei
}
     7d0:	08 95       	ret

000007d2 <_Z8tricolorhhh>:
=============================================== */
#ifdef ENABLE_TRICOLOR
    int tricolorBlinkRed;
    int tricolorBlinkGreen;
    int tricolorBlinkBlue;
    void tricolor(byte r, byte g, byte b) {
     7d2:	0f 93       	push	r16
     7d4:	1f 93       	push	r17
     7d6:	98 2f       	mov	r25, r24
     7d8:	16 2f       	mov	r17, r22
     7da:	04 2f       	mov	r16, r20
        if (r != 255) digitalWrite(TRICOLOR_RED_PIN, r);
     7dc:	8f 3f       	cpi	r24, 0xFF	; 255
     7de:	21 f0       	breq	.+8      	; 0x7e8 <_Z8tricolorhhh+0x16>
     7e0:	8b e2       	ldi	r24, 0x2B	; 43
     7e2:	69 2f       	mov	r22, r25
     7e4:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <digitalWrite>
        if (g != 255) digitalWrite(TRICOLOR_GREEN_PIN, g);
     7e8:	1f 3f       	cpi	r17, 0xFF	; 255
     7ea:	21 f0       	breq	.+8      	; 0x7f4 <_Z8tricolorhhh+0x22>
     7ec:	8c e2       	ldi	r24, 0x2C	; 44
     7ee:	61 2f       	mov	r22, r17
     7f0:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <digitalWrite>
        if (b != 255) digitalWrite(TRICOLOR_BLUE_PIN, b);
     7f4:	0f 3f       	cpi	r16, 0xFF	; 255
     7f6:	21 f0       	breq	.+8      	; 0x800 <_Z8tricolorhhh+0x2e>
     7f8:	8d e2       	ldi	r24, 0x2D	; 45
     7fa:	60 2f       	mov	r22, r16
     7fc:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <digitalWrite>
    }
     800:	1f 91       	pop	r17
     802:	0f 91       	pop	r16
     804:	08 95       	ret

00000806 <_Z8mouseoffi>:
        } else if (mode == KMOUSE_SCROLL) {
            opt_scroll_mode = SCROLL_MODE_TILT_POSITION;
        }
    }
    
    void mouseoff(int mode) {
     806:	cf 93       	push	r28
     808:	df 93       	push	r29
     80a:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset mouseoff ");
     80c:	80 ef       	ldi	r24, 0xF0	; 240
     80e:	98 e0       	ldi	r25, 0x08	; 8
     810:	60 e0       	ldi	r22, 0x00	; 0
     812:	71 e0       	ldi	r23, 0x01	; 1
     814:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(mode);
     818:	80 ef       	ldi	r24, 0xF0	; 240
     81a:	98 e0       	ldi	r25, 0x08	; 8
     81c:	be 01       	movw	r22, r28
     81e:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        if (mode == KMOUSE_MOVE) {
     822:	20 97       	sbiw	r28, 0x00	; 0
     824:	19 f4       	brne	.+6      	; 0x82c <_Z8mouseoffi+0x26>
            opt_mouse_mode = 0;
     826:	10 92 d1 06 	sts	0x06D1, r1
     82a:	04 c0       	rjmp	.+8      	; 0x834 <_Z8mouseoffi+0x2e>
        } else if (mode == KMOUSE_SCROLL) {
     82c:	21 97       	sbiw	r28, 0x01	; 1
     82e:	11 f4       	brne	.+4      	; 0x834 <_Z8mouseoffi+0x2e>
            opt_scroll_mode = 0;
     830:	10 92 d2 06 	sts	0x06D2, r1
        }
    }
     834:	df 91       	pop	r29
     836:	cf 91       	pop	r28
     838:	08 95       	ret

0000083a <_Z7mouseoni>:
            // not enabled, so turn it on
            pushmode(mode);
        }
    }
    
    void mouseon(int mode) {
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset mouseon ");
     840:	80 ef       	ldi	r24, 0xF0	; 240
     842:	98 e0       	ldi	r25, 0x08	; 8
     844:	63 e1       	ldi	r22, 0x13	; 19
     846:	71 e0       	ldi	r23, 0x01	; 1
     848:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(mode);
     84c:	80 ef       	ldi	r24, 0xF0	; 240
     84e:	98 e0       	ldi	r25, 0x08	; 8
     850:	be 01       	movw	r22, r28
     852:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        if (mode == KMOUSE_MOVE) {
     856:	20 97       	sbiw	r28, 0x00	; 0
     858:	21 f4       	brne	.+8      	; 0x862 <_Z7mouseoni+0x28>
            opt_mouse_mode = MOUSE_MODE_TILT_POSITION;
     85a:	82 e0       	ldi	r24, 0x02	; 2
     85c:	80 93 d1 06 	sts	0x06D1, r24
     860:	05 c0       	rjmp	.+10     	; 0x86c <_Z7mouseoni+0x32>
        } else if (mode == KMOUSE_SCROLL) {
     862:	21 97       	sbiw	r28, 0x01	; 1
     864:	19 f4       	brne	.+6      	; 0x86c <_Z7mouseoni+0x32>
            opt_scroll_mode = SCROLL_MODE_TILT_POSITION;
     866:	82 e0       	ldi	r24, 0x02	; 2
     868:	80 93 d2 06 	sts	0x06D2, r24
        }
    }
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	08 95       	ret

00000872 <_Z7vibrateii>:
                tone(SOUND_PIN, pitch, duration_ms);
            }
        #endif /* ENABLE_BEEP */
    }
    
    void vibrate(int mode, int duration) {
     872:	cf 92       	push	r12
     874:	df 92       	push	r13
     876:	ef 92       	push	r14
     878:	ff 92       	push	r15
     87a:	0f 93       	push	r16
     87c:	1f 93       	push	r17
     87e:	8c 01       	movw	r16, r24
     880:	6b 01       	movw	r12, r22
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset vibrate ");
     882:	90 ef       	ldi	r25, 0xF0	; 240
     884:	e9 2e       	mov	r14, r25
     886:	98 e0       	ldi	r25, 0x08	; 8
     888:	f9 2e       	mov	r15, r25
     88a:	c7 01       	movw	r24, r14
     88c:	65 e2       	ldi	r22, 0x25	; 37
     88e:	71 e0       	ldi	r23, 0x01	; 1
     890:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.print(mode);
     894:	c7 01       	movw	r24, r14
     896:	b8 01       	movw	r22, r16
     898:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <_ZN16USBVirtualSerial5printEi>
            Serial.print(" ");
     89c:	c7 01       	movw	r24, r14
     89e:	67 e3       	ldi	r22, 0x37	; 55
     8a0:	71 e0       	ldi	r23, 0x01	; 1
     8a2:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(duration);
     8a6:	c7 01       	movw	r24, r14
     8a8:	b6 01       	movw	r22, r12
     8aa:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
    }
     8ae:	1f 91       	pop	r17
     8b0:	0f 91       	pop	r16
     8b2:	ff 90       	pop	r15
     8b4:	ef 90       	pop	r14
     8b6:	df 90       	pop	r13
     8b8:	cf 90       	pop	r12
     8ba:	08 95       	ret

000008bc <_Z7blueledii>:
                case KLED_SOLID: tricolorBlinkGreen = 0; tricolor(-1, 1, -1); break;
            }
        #endif /* ENABLE_TRICOLOR */
    }
    
    void blueled(int mode, int duration) {
     8bc:	0f 93       	push	r16
     8be:	1f 93       	push	r17
     8c0:	cf 93       	push	r28
     8c2:	df 93       	push	r29
     8c4:	ec 01       	movw	r28, r24
     8c6:	8b 01       	movw	r16, r22
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset blueled ");
     8c8:	80 ef       	ldi	r24, 0xF0	; 240
     8ca:	98 e0       	ldi	r25, 0x08	; 8
     8cc:	69 e3       	ldi	r22, 0x39	; 57
     8ce:	71 e0       	ldi	r23, 0x01	; 1
     8d0:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.print(mode);
     8d4:	80 ef       	ldi	r24, 0xF0	; 240
     8d6:	98 e0       	ldi	r25, 0x08	; 8
     8d8:	be 01       	movw	r22, r28
     8da:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <_ZN16USBVirtualSerial5printEi>
            Serial.print(" ");
     8de:	80 ef       	ldi	r24, 0xF0	; 240
     8e0:	98 e0       	ldi	r25, 0x08	; 8
     8e2:	67 e3       	ldi	r22, 0x37	; 55
     8e4:	71 e0       	ldi	r23, 0x01	; 1
     8e6:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(duration);
     8ea:	80 ef       	ldi	r24, 0xF0	; 240
     8ec:	98 e0       	ldi	r25, 0x08	; 8
     8ee:	b8 01       	movw	r22, r16
     8f0:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        #ifdef ENABLE_TRICOLOR
            switch (mode) {
     8f4:	c2 30       	cpi	r28, 0x02	; 2
     8f6:	d1 05       	cpc	r29, r1
     8f8:	09 f1       	breq	.+66     	; 0x93c <_Z7blueledii+0x80>
     8fa:	c3 30       	cpi	r28, 0x03	; 3
     8fc:	d1 05       	cpc	r29, r1
     8fe:	34 f4       	brge	.+12     	; 0x90c <_Z7blueledii+0x50>
     900:	20 97       	sbiw	r28, 0x00	; 0
     902:	69 f0       	breq	.+26     	; 0x91e <_Z7blueledii+0x62>
     904:	c1 30       	cpi	r28, 0x01	; 1
     906:	d1 05       	cpc	r29, r1
     908:	31 f5       	brne	.+76     	; 0x956 <_Z7blueledii+0x9a>
     90a:	18 c0       	rjmp	.+48     	; 0x93c <_Z7blueledii+0x80>
     90c:	c4 30       	cpi	r28, 0x04	; 4
     90e:	d1 05       	cpc	r29, r1
     910:	a9 f0       	breq	.+42     	; 0x93c <_Z7blueledii+0x80>
     912:	c4 30       	cpi	r28, 0x04	; 4
     914:	d1 05       	cpc	r29, r1
     916:	5c f0       	brlt	.+22     	; 0x92e <_Z7blueledii+0x72>
     918:	25 97       	sbiw	r28, 0x05	; 5
     91a:	e9 f4       	brne	.+58     	; 0x956 <_Z7blueledii+0x9a>
     91c:	14 c0       	rjmp	.+40     	; 0x946 <_Z7blueledii+0x8a>
                case KLED_OFF: tricolorBlinkBlue = 0; tricolor(-1, -1, 0); break;
     91e:	10 92 8d 08 	sts	0x088D, r1
     922:	10 92 8c 08 	sts	0x088C, r1
     926:	8f ef       	ldi	r24, 0xFF	; 255
     928:	6f ef       	ldi	r22, 0xFF	; 255
     92a:	40 e0       	ldi	r20, 0x00	; 0
     92c:	13 c0       	rjmp	.+38     	; 0x954 <_Z7blueledii+0x98>
                case KLED_LONGBLINK: tricolorBlinkBlue = 1; tricolor(-1, -1, 1); break;
                case KLED_LONGPULSE: tricolorBlinkBlue = 2; tricolor(-1, -1, 1); break;
                case KLED_SHORTBLINK: tricolorBlinkBlue = 3; tricolor(-1, -1, 1); break;
     92e:	83 e0       	ldi	r24, 0x03	; 3
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	90 93 8d 08 	sts	0x088D, r25
     936:	80 93 8c 08 	sts	0x088C, r24
     93a:	09 c0       	rjmp	.+18     	; 0x94e <_Z7blueledii+0x92>
                case KLED_SHORTPULSE: tricolorBlinkBlue = 4; tricolor(-1, -1, 1); break;
     93c:	d0 93 8d 08 	sts	0x088D, r29
     940:	c0 93 8c 08 	sts	0x088C, r28
     944:	04 c0       	rjmp	.+8      	; 0x94e <_Z7blueledii+0x92>
                case KLED_SOLID: tricolorBlinkBlue = 0; tricolor(-1, -1, 1); break;
     946:	10 92 8d 08 	sts	0x088D, r1
     94a:	10 92 8c 08 	sts	0x088C, r1
     94e:	8f ef       	ldi	r24, 0xFF	; 255
     950:	6f ef       	ldi	r22, 0xFF	; 255
     952:	41 e0       	ldi	r20, 0x01	; 1
     954:	3e df       	rcall	.-388    	; 0x7d2 <_Z8tricolorhhh>
            }
        #endif /* ENABLE_TRICOLOR */
    }
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	1f 91       	pop	r17
     95c:	0f 91       	pop	r16
     95e:	08 95       	ret

00000960 <_Z8greenledii>:
                case KLED_SOLID: tricolorBlinkRed = 0; tricolor(1, -1, -1); break;
            }
        #endif /* ENABLE_TRICOLOR */
    }
    
    void greenled(int mode, int duration) {
     960:	0f 93       	push	r16
     962:	1f 93       	push	r17
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	ec 01       	movw	r28, r24
     96a:	8b 01       	movw	r16, r22
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset greenled ");
     96c:	80 ef       	ldi	r24, 0xF0	; 240
     96e:	98 e0       	ldi	r25, 0x08	; 8
     970:	6b e4       	ldi	r22, 0x4B	; 75
     972:	71 e0       	ldi	r23, 0x01	; 1
     974:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.print(mode);
     978:	80 ef       	ldi	r24, 0xF0	; 240
     97a:	98 e0       	ldi	r25, 0x08	; 8
     97c:	be 01       	movw	r22, r28
     97e:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <_ZN16USBVirtualSerial5printEi>
            Serial.print(" ");
     982:	80 ef       	ldi	r24, 0xF0	; 240
     984:	98 e0       	ldi	r25, 0x08	; 8
     986:	67 e3       	ldi	r22, 0x37	; 55
     988:	71 e0       	ldi	r23, 0x01	; 1
     98a:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(duration);
     98e:	80 ef       	ldi	r24, 0xF0	; 240
     990:	98 e0       	ldi	r25, 0x08	; 8
     992:	b8 01       	movw	r22, r16
     994:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        #ifdef ENABLE_TRICOLOR
            switch (mode) {
     998:	c2 30       	cpi	r28, 0x02	; 2
     99a:	d1 05       	cpc	r29, r1
     99c:	01 f1       	breq	.+64     	; 0x9de <_Z8greenledii+0x7e>
     99e:	c3 30       	cpi	r28, 0x03	; 3
     9a0:	d1 05       	cpc	r29, r1
     9a2:	34 f4       	brge	.+12     	; 0x9b0 <_Z8greenledii+0x50>
     9a4:	20 97       	sbiw	r28, 0x00	; 0
     9a6:	69 f0       	breq	.+26     	; 0x9c2 <_Z8greenledii+0x62>
     9a8:	c1 30       	cpi	r28, 0x01	; 1
     9aa:	d1 05       	cpc	r29, r1
     9ac:	29 f5       	brne	.+74     	; 0x9f8 <_Z8greenledii+0x98>
     9ae:	17 c0       	rjmp	.+46     	; 0x9de <_Z8greenledii+0x7e>
     9b0:	c4 30       	cpi	r28, 0x04	; 4
     9b2:	d1 05       	cpc	r29, r1
     9b4:	a1 f0       	breq	.+40     	; 0x9de <_Z8greenledii+0x7e>
     9b6:	c4 30       	cpi	r28, 0x04	; 4
     9b8:	d1 05       	cpc	r29, r1
     9ba:	54 f0       	brlt	.+20     	; 0x9d0 <_Z8greenledii+0x70>
     9bc:	25 97       	sbiw	r28, 0x05	; 5
     9be:	e1 f4       	brne	.+56     	; 0x9f8 <_Z8greenledii+0x98>
     9c0:	13 c0       	rjmp	.+38     	; 0x9e8 <_Z8greenledii+0x88>
                case KLED_OFF: tricolorBlinkGreen = 0; tricolor(-1, 0, -1); break;
     9c2:	10 92 8b 08 	sts	0x088B, r1
     9c6:	10 92 8a 08 	sts	0x088A, r1
     9ca:	8f ef       	ldi	r24, 0xFF	; 255
     9cc:	60 e0       	ldi	r22, 0x00	; 0
     9ce:	12 c0       	rjmp	.+36     	; 0x9f4 <_Z8greenledii+0x94>
                case KLED_LONGBLINK: tricolorBlinkGreen = 1; tricolor(-1, 1, -1); break;
                case KLED_LONGPULSE: tricolorBlinkGreen = 2; tricolor(-1, 1, -1); break;
                case KLED_SHORTBLINK: tricolorBlinkGreen = 3; tricolor(-1, 1, -1); break;
     9d0:	83 e0       	ldi	r24, 0x03	; 3
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	90 93 8b 08 	sts	0x088B, r25
     9d8:	80 93 8a 08 	sts	0x088A, r24
     9dc:	09 c0       	rjmp	.+18     	; 0x9f0 <_Z8greenledii+0x90>
                case KLED_SHORTPULSE: tricolorBlinkGreen = 4; tricolor(-1, 1, -1); break;
     9de:	d0 93 8b 08 	sts	0x088B, r29
     9e2:	c0 93 8a 08 	sts	0x088A, r28
     9e6:	04 c0       	rjmp	.+8      	; 0x9f0 <_Z8greenledii+0x90>
                case KLED_SOLID: tricolorBlinkGreen = 0; tricolor(-1, 1, -1); break;
     9e8:	10 92 8b 08 	sts	0x088B, r1
     9ec:	10 92 8a 08 	sts	0x088A, r1
     9f0:	8f ef       	ldi	r24, 0xFF	; 255
     9f2:	61 e0       	ldi	r22, 0x01	; 1
     9f4:	4f ef       	ldi	r20, 0xFF	; 255
     9f6:	ed de       	rcall	.-550    	; 0x7d2 <_Z8tricolorhhh>
            }
        #endif /* ENABLE_TRICOLOR */
    }
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	1f 91       	pop	r17
     9fe:	0f 91       	pop	r16
     a00:	08 95       	ret

00000a02 <_Z6redledii>:
        modifierdown(code);
        delay(5);
        modifierup(code);
    }
    
    void redled(int mode, int duration) {
     a02:	0f 93       	push	r16
     a04:	1f 93       	push	r17
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	ec 01       	movw	r28, r24
     a0c:	8b 01       	movw	r16, r22
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset redled ");
     a0e:	80 ef       	ldi	r24, 0xF0	; 240
     a10:	98 e0       	ldi	r25, 0x08	; 8
     a12:	6e e5       	ldi	r22, 0x5E	; 94
     a14:	71 e0       	ldi	r23, 0x01	; 1
     a16:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.print(mode);
     a1a:	80 ef       	ldi	r24, 0xF0	; 240
     a1c:	98 e0       	ldi	r25, 0x08	; 8
     a1e:	be 01       	movw	r22, r28
     a20:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <_ZN16USBVirtualSerial5printEi>
            Serial.print(" ");
     a24:	80 ef       	ldi	r24, 0xF0	; 240
     a26:	98 e0       	ldi	r25, 0x08	; 8
     a28:	67 e3       	ldi	r22, 0x37	; 55
     a2a:	71 e0       	ldi	r23, 0x01	; 1
     a2c:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(duration);
     a30:	80 ef       	ldi	r24, 0xF0	; 240
     a32:	98 e0       	ldi	r25, 0x08	; 8
     a34:	b8 01       	movw	r22, r16
     a36:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        #ifdef ENABLE_TRICOLOR
            switch (mode) {
     a3a:	c2 30       	cpi	r28, 0x02	; 2
     a3c:	d1 05       	cpc	r29, r1
     a3e:	f9 f0       	breq	.+62     	; 0xa7e <_Z6redledii+0x7c>
     a40:	c3 30       	cpi	r28, 0x03	; 3
     a42:	d1 05       	cpc	r29, r1
     a44:	34 f4       	brge	.+12     	; 0xa52 <_Z6redledii+0x50>
     a46:	20 97       	sbiw	r28, 0x00	; 0
     a48:	69 f0       	breq	.+26     	; 0xa64 <_Z6redledii+0x62>
     a4a:	c1 30       	cpi	r28, 0x01	; 1
     a4c:	d1 05       	cpc	r29, r1
     a4e:	21 f5       	brne	.+72     	; 0xa98 <_Z6redledii+0x96>
     a50:	16 c0       	rjmp	.+44     	; 0xa7e <_Z6redledii+0x7c>
     a52:	c4 30       	cpi	r28, 0x04	; 4
     a54:	d1 05       	cpc	r29, r1
     a56:	99 f0       	breq	.+38     	; 0xa7e <_Z6redledii+0x7c>
     a58:	c4 30       	cpi	r28, 0x04	; 4
     a5a:	d1 05       	cpc	r29, r1
     a5c:	4c f0       	brlt	.+18     	; 0xa70 <_Z6redledii+0x6e>
     a5e:	25 97       	sbiw	r28, 0x05	; 5
     a60:	d9 f4       	brne	.+54     	; 0xa98 <_Z6redledii+0x96>
     a62:	12 c0       	rjmp	.+36     	; 0xa88 <_Z6redledii+0x86>
                case KLED_OFF: tricolorBlinkRed = 0; tricolor(0, -1, -1); break;
     a64:	10 92 89 08 	sts	0x0889, r1
     a68:	10 92 88 08 	sts	0x0888, r1
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	11 c0       	rjmp	.+34     	; 0xa92 <_Z6redledii+0x90>
                case KLED_LONGBLINK: tricolorBlinkRed = 1; tricolor(1, -1, -1); break;
                case KLED_LONGPULSE: tricolorBlinkRed = 2; tricolor(1, -1, -1); break;
                case KLED_SHORTBLINK: tricolorBlinkRed = 3; tricolor(1, -1, -1); break;
     a70:	83 e0       	ldi	r24, 0x03	; 3
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	90 93 89 08 	sts	0x0889, r25
     a78:	80 93 88 08 	sts	0x0888, r24
     a7c:	09 c0       	rjmp	.+18     	; 0xa90 <_Z6redledii+0x8e>
                case KLED_SHORTPULSE: tricolorBlinkRed = 4; tricolor(1, -1, -1); break;
     a7e:	d0 93 89 08 	sts	0x0889, r29
     a82:	c0 93 88 08 	sts	0x0888, r28
     a86:	04 c0       	rjmp	.+8      	; 0xa90 <_Z6redledii+0x8e>
                case KLED_SOLID: tricolorBlinkRed = 0; tricolor(1, -1, -1); break;
     a88:	10 92 89 08 	sts	0x0889, r1
     a8c:	10 92 88 08 	sts	0x0888, r1
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	6f ef       	ldi	r22, 0xFF	; 255
     a94:	4f ef       	ldi	r20, 0xFF	; 255
     a96:	9d de       	rcall	.-710    	; 0x7d2 <_Z8tricolorhhh>
            }
        #endif /* ENABLE_TRICOLOR */
    }
     a98:	df 91       	pop	r29
     a9a:	cf 91       	pop	r28
     a9c:	1f 91       	pop	r17
     a9e:	0f 91       	pop	r16
     aa0:	08 95       	ret

00000aa2 <_Z4beepiii>:
                case KLED_SOLID: tricolorBlinkBlue = 0; tricolor(-1, -1, 1); break;
            }
        #endif /* ENABLE_TRICOLOR */
    }
    
    void beep(int pitch, int mode, int duration) {
     aa2:	af 92       	push	r10
     aa4:	bf 92       	push	r11
     aa6:	cf 92       	push	r12
     aa8:	df 92       	push	r13
     aaa:	ef 92       	push	r14
     aac:	ff 92       	push	r15
     aae:	0f 93       	push	r16
     ab0:	1f 93       	push	r17
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	5c 01       	movw	r10, r24
     ab8:	eb 01       	movw	r28, r22
     aba:	6a 01       	movw	r12, r20
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset beep ");
     abc:	80 ef       	ldi	r24, 0xF0	; 240
     abe:	98 e0       	ldi	r25, 0x08	; 8
     ac0:	6f e6       	ldi	r22, 0x6F	; 111
     ac2:	71 e0       	ldi	r23, 0x01	; 1
     ac4:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.print(pitch);
     ac8:	80 ef       	ldi	r24, 0xF0	; 240
     aca:	98 e0       	ldi	r25, 0x08	; 8
     acc:	b5 01       	movw	r22, r10
     ace:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <_ZN16USBVirtualSerial5printEi>
            Serial.print(" ");
     ad2:	80 ef       	ldi	r24, 0xF0	; 240
     ad4:	98 e0       	ldi	r25, 0x08	; 8
     ad6:	67 e3       	ldi	r22, 0x37	; 55
     ad8:	71 e0       	ldi	r23, 0x01	; 1
     ada:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.print(mode);
     ade:	80 ef       	ldi	r24, 0xF0	; 240
     ae0:	98 e0       	ldi	r25, 0x08	; 8
     ae2:	be 01       	movw	r22, r28
     ae4:	0e 94 c2 2e 	call	0x5d84	; 0x5d84 <_ZN16USBVirtualSerial5printEi>
            Serial.print(" ");
     ae8:	80 ef       	ldi	r24, 0xF0	; 240
     aea:	98 e0       	ldi	r25, 0x08	; 8
     aec:	67 e3       	ldi	r22, 0x37	; 55
     aee:	71 e0       	ldi	r23, 0x01	; 1
     af0:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(duration);
     af4:	80 ef       	ldi	r24, 0xF0	; 240
     af6:	98 e0       	ldi	r25, 0x08	; 8
     af8:	b6 01       	movw	r22, r12
     afa:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        #ifdef ENABLE_BEEP
            if (mode == KBEEP_OFF) {
     afe:	20 97       	sbiw	r28, 0x00	; 0
     b00:	21 f4       	brne	.+8      	; 0xb0a <_Z4beepiii+0x68>
                noTone(SOUND_PIN);
     b02:	8a e2       	ldi	r24, 0x2A	; 42
     b04:	0e 94 d1 27 	call	0x4fa2	; 0x4fa2 <_Z6noToneh>
     b08:	28 c0       	rjmp	.+80     	; 0xb5a <_Z4beepiii+0xb8>
                return;
            } 
            
            int duration_ms = 1000;
            if (mode == KBEEP_SHORTPULSE) {
     b0a:	c4 30       	cpi	r28, 0x04	; 4
     b0c:	d1 05       	cpc	r29, r1
     b0e:	19 f4       	brne	.+6      	; 0xb16 <_Z4beepiii+0x74>
     b10:	84 e6       	ldi	r24, 0x64	; 100
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	07 c0       	rjmp	.+14     	; 0xb24 <_Z4beepiii+0x82>
                duration_ms = 100;
            } else if (mode == KBEEP_SHORTBEEP) {
     b16:	23 97       	sbiw	r28, 0x03	; 3
     b18:	19 f4       	brne	.+6      	; 0xb20 <_Z4beepiii+0x7e>
     b1a:	89 e1       	ldi	r24, 0x19	; 25
     b1c:	90 e0       	ldi	r25, 0x00	; 0
     b1e:	02 c0       	rjmp	.+4      	; 0xb24 <_Z4beepiii+0x82>
     b20:	88 ee       	ldi	r24, 0xE8	; 232
     b22:	93 e0       	ldi	r25, 0x03	; 3
     b24:	c0 e0       	ldi	r28, 0x00	; 0
     b26:	d0 e0       	ldi	r29, 0x00	; 0
            
            for (int i = 0; i < duration; i++) {
                if (i > 0) {
                    delay(80);
                }
                tone(SOUND_PIN, pitch, duration_ms);
     b28:	7c 01       	movw	r14, r24
     b2a:	00 27       	eor	r16, r16
     b2c:	f7 fc       	sbrc	r15, 7
     b2e:	00 95       	com	r16
     b30:	10 2f       	mov	r17, r16
     b32:	10 c0       	rjmp	.+32     	; 0xb54 <_Z4beepiii+0xb2>
            } else if (mode == KBEEP_SHORTBEEP) {
                duration_ms = 25;
            }
            
            for (int i = 0; i < duration; i++) {
                if (i > 0) {
     b34:	1c 16       	cp	r1, r28
     b36:	1d 06       	cpc	r1, r29
     b38:	34 f4       	brge	.+12     	; 0xb46 <_Z4beepiii+0xa4>
                    delay(80);
     b3a:	60 e5       	ldi	r22, 0x50	; 80
     b3c:	70 e0       	ldi	r23, 0x00	; 0
     b3e:	80 e0       	ldi	r24, 0x00	; 0
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
                }
                tone(SOUND_PIN, pitch, duration_ms);
     b46:	8a e2       	ldi	r24, 0x2A	; 42
     b48:	b5 01       	movw	r22, r10
     b4a:	a8 01       	movw	r20, r16
     b4c:	97 01       	movw	r18, r14
     b4e:	0e 94 45 28 	call	0x508a	; 0x508a <_Z4tonehjm>
                duration_ms = 100;
            } else if (mode == KBEEP_SHORTBEEP) {
                duration_ms = 25;
            }
            
            for (int i = 0; i < duration; i++) {
     b52:	21 96       	adiw	r28, 0x01	; 1
     b54:	cc 15       	cp	r28, r12
     b56:	dd 05       	cpc	r29, r13
     b58:	6c f3       	brlt	.-38     	; 0xb34 <_Z4beepiii+0x92>
                    delay(80);
                }
                tone(SOUND_PIN, pitch, duration_ms);
            }
        #endif /* ENABLE_BEEP */
    }
     b5a:	df 91       	pop	r29
     b5c:	cf 91       	pop	r28
     b5e:	1f 91       	pop	r17
     b60:	0f 91       	pop	r16
     b62:	ff 90       	pop	r15
     b64:	ef 90       	pop	r14
     b66:	df 90       	pop	r13
     b68:	cf 90       	pop	r12
     b6a:	bf 90       	pop	r11
     b6c:	af 90       	pop	r10
     b6e:	08 95       	ret

00000b70 <_Z10modifierupi>:
            RX400.set_modifier(modifiersDown);
            RX400.send_now();
        #endif /* ENABLE_RX400 */
    }
    
    void modifierup(int code) {
     b70:	cf 93       	push	r28
     b72:	df 93       	push	r29
     b74:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset modifierup ");
     b76:	80 ef       	ldi	r24, 0xF0	; 240
     b78:	98 e0       	ldi	r25, 0x08	; 8
     b7a:	6e e7       	ldi	r22, 0x7E	; 126
     b7c:	71 e0       	ldi	r23, 0x01	; 1
     b7e:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(code);
     b82:	80 ef       	ldi	r24, 0xF0	; 240
     b84:	98 e0       	ldi	r25, 0x08	; 8
     b86:	be 01       	movw	r22, r28
     b88:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        if ((modifiersDown & code) > 0) {
     b8c:	60 91 8f 08 	lds	r22, 0x088F
     b90:	70 91 90 08 	lds	r23, 0x0890
     b94:	ce 01       	movw	r24, r28
     b96:	86 23       	and	r24, r22
     b98:	97 23       	and	r25, r23
     b9a:	18 16       	cp	r1, r24
     b9c:	19 06       	cpc	r1, r25
     b9e:	74 f4       	brge	.+28     	; 0xbbc <_Z10modifierupi+0x4c>
            modifiersDown -= code;
     ba0:	6c 1b       	sub	r22, r28
     ba2:	7d 0b       	sbc	r23, r29
     ba4:	70 93 90 08 	sts	0x0890, r23
     ba8:	60 93 8f 08 	sts	0x088F, r22
            #ifdef ENABLE_USB
                Keyboard.set_modifier(modifiersDown);
     bac:	88 e1       	ldi	r24, 0x18	; 24
     bae:	99 e0       	ldi	r25, 0x09	; 9
     bb0:	0e 94 df 2a 	call	0x55be	; 0x55be <_ZN11USBKeyboard12set_modifierEh>
                Keyboard.send_now();
     bb4:	88 e1       	ldi	r24, 0x18	; 24
     bb6:	99 e0       	ldi	r25, 0x09	; 9
     bb8:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <_ZN11USBKeyboard8send_nowEv>
            #ifdef ENABLE_RX400
                RX400.set_modifier(modifiersDown);
                RX400.send_now();
            #endif /* ENABLE_RX400 */
        }
    }
     bbc:	df 91       	pop	r29
     bbe:	cf 91       	pop	r28
     bc0:	08 95       	ret

00000bc2 <_Z15deactivate_modei>:
            break;
    }
}
 
void deactivate_mode(int mode) {
    switch (mode) {
     bc2:	04 97       	sbiw	r24, 0x04	; 4
     bc4:	19 f4       	brne	.+6      	; 0xbcc <_Z15deactivate_modei+0xa>
        case KMODE_GUI:
            modifierup(MODIFIERKEY_GUI);
     bc6:	88 e0       	ldi	r24, 0x08	; 8
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	d2 cf       	rjmp	.-92     	; 0xb70 <_Z10modifierupi>
     bcc:	08 95       	ret

00000bce <_Z12modifierdowni>:
        keydown(code);
        delay(5);
        keyup(code);
    }
    
    void modifierdown(int code) {
     bce:	ef 92       	push	r14
     bd0:	ff 92       	push	r15
     bd2:	0f 93       	push	r16
     bd4:	1f 93       	push	r17
     bd6:	7c 01       	movw	r14, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset modifierdown ");
     bd8:	00 ef       	ldi	r16, 0xF0	; 240
     bda:	18 e0       	ldi	r17, 0x08	; 8
     bdc:	c8 01       	movw	r24, r16
     bde:	63 e9       	ldi	r22, 0x93	; 147
     be0:	71 e0       	ldi	r23, 0x01	; 1
     be2:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(code);
     be6:	c8 01       	movw	r24, r16
     be8:	b7 01       	movw	r22, r14
     bea:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        modifiersDown = modifiersDown | code;
     bee:	60 91 8f 08 	lds	r22, 0x088F
     bf2:	70 91 90 08 	lds	r23, 0x0890
     bf6:	6e 29       	or	r22, r14
     bf8:	7f 29       	or	r23, r15
     bfa:	70 93 90 08 	sts	0x0890, r23
     bfe:	60 93 8f 08 	sts	0x088F, r22
        #ifdef ENABLE_USB
            Keyboard.set_modifier(modifiersDown);
     c02:	08 e1       	ldi	r16, 0x18	; 24
     c04:	19 e0       	ldi	r17, 0x09	; 9
     c06:	c8 01       	movw	r24, r16
     c08:	0e 94 df 2a 	call	0x55be	; 0x55be <_ZN11USBKeyboard12set_modifierEh>
            Keyboard.send_now();
     c0c:	c8 01       	movw	r24, r16
     c0e:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <_ZN11USBKeyboard8send_nowEv>
        #endif /* ENABLE_USB */
        #ifdef ENABLE_RX400       
            RX400.set_modifier(modifiersDown);
            RX400.send_now();
        #endif /* ENABLE_RX400 */
    }
     c12:	1f 91       	pop	r17
     c14:	0f 91       	pop	r16
     c16:	ff 90       	pop	r15
     c18:	ef 90       	pop	r14
     c1a:	08 95       	ret

00000c1c <_Z13activate_modei>:
#define KMODE_SYMBOLS 2
#define KMODE_FUNCTIONS 3
#define KMODE_GUI 4
 
void activate_mode(int mode) {
    switch (mode) {
     c1c:	82 30       	cpi	r24, 0x02	; 2
     c1e:	91 05       	cpc	r25, r1
     c20:	71 f1       	breq	.+92     	; 0xc7e <_Z13activate_modei+0x62>
     c22:	83 30       	cpi	r24, 0x03	; 3
     c24:	91 05       	cpc	r25, r1
     c26:	34 f4       	brge	.+12     	; 0xc34 <_Z13activate_modei+0x18>
     c28:	00 97       	sbiw	r24, 0x00	; 0
     c2a:	59 f0       	breq	.+22     	; 0xc42 <_Z13activate_modei+0x26>
     c2c:	01 97       	sbiw	r24, 0x01	; 1
     c2e:	09 f0       	breq	.+2      	; 0xc32 <_Z13activate_modei+0x16>
     c30:	5f c0       	rjmp	.+190    	; 0xcf0 <_Z13activate_modei+0xd4>
     c32:	16 c0       	rjmp	.+44     	; 0xc60 <_Z13activate_modei+0x44>
     c34:	83 30       	cpi	r24, 0x03	; 3
     c36:	91 05       	cpc	r25, r1
     c38:	b1 f1       	breq	.+108    	; 0xca6 <_Z13activate_modei+0x8a>
     c3a:	04 97       	sbiw	r24, 0x04	; 4
     c3c:	09 f0       	breq	.+2      	; 0xc40 <_Z13activate_modei+0x24>
     c3e:	58 c0       	rjmp	.+176    	; 0xcf0 <_Z13activate_modei+0xd4>
     c40:	48 c0       	rjmp	.+144    	; 0xcd2 <_Z13activate_modei+0xb6>
        case KMODE_DEFAULT:
            beep(2000, KBEEP_SHORTBEEP, 1);
     c42:	80 ed       	ldi	r24, 0xD0	; 208
     c44:	97 e0       	ldi	r25, 0x07	; 7
     c46:	63 e0       	ldi	r22, 0x03	; 3
     c48:	70 e0       	ldi	r23, 0x00	; 0
     c4a:	41 e0       	ldi	r20, 0x01	; 1
     c4c:	50 e0       	ldi	r21, 0x00	; 0
     c4e:	29 df       	rcall	.-430    	; 0xaa2 <_Z4beepiii>
            redled(KLED_OFF, 0);
     c50:	80 e0       	ldi	r24, 0x00	; 0
     c52:	90 e0       	ldi	r25, 0x00	; 0
     c54:	60 e0       	ldi	r22, 0x00	; 0
     c56:	70 e0       	ldi	r23, 0x00	; 0
     c58:	d4 de       	rcall	.-600    	; 0xa02 <_Z6redledii>
            greenled(KLED_SOLID, 0);
     c5a:	85 e0       	ldi	r24, 0x05	; 5
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	31 c0       	rjmp	.+98     	; 0xcc2 <_Z13activate_modei+0xa6>
            blueled(KLED_OFF, 0);
            return;
            break;
        case KMODE_NUMBERS:
            beep(2000, KBEEP_SHORTBEEP, 2);
     c60:	80 ed       	ldi	r24, 0xD0	; 208
     c62:	97 e0       	ldi	r25, 0x07	; 7
     c64:	63 e0       	ldi	r22, 0x03	; 3
     c66:	70 e0       	ldi	r23, 0x00	; 0
     c68:	42 e0       	ldi	r20, 0x02	; 2
     c6a:	50 e0       	ldi	r21, 0x00	; 0
     c6c:	1a df       	rcall	.-460    	; 0xaa2 <_Z4beepiii>
            redled(KLED_OFF, 0);
     c6e:	80 e0       	ldi	r24, 0x00	; 0
     c70:	90 e0       	ldi	r25, 0x00	; 0
     c72:	60 e0       	ldi	r22, 0x00	; 0
     c74:	70 e0       	ldi	r23, 0x00	; 0
     c76:	c5 de       	rcall	.-630    	; 0xa02 <_Z6redledii>
            greenled(KLED_OFF, 0);
     c78:	80 e0       	ldi	r24, 0x00	; 0
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	0e c0       	rjmp	.+28     	; 0xc9a <_Z13activate_modei+0x7e>
            blueled(KLED_SOLID, 0);
            return;
            break;
        case KMODE_SYMBOLS:
            beep(2000, KBEEP_SHORTBEEP, 3);
     c7e:	80 ed       	ldi	r24, 0xD0	; 208
     c80:	97 e0       	ldi	r25, 0x07	; 7
     c82:	63 e0       	ldi	r22, 0x03	; 3
     c84:	70 e0       	ldi	r23, 0x00	; 0
     c86:	43 e0       	ldi	r20, 0x03	; 3
     c88:	50 e0       	ldi	r21, 0x00	; 0
     c8a:	0b df       	rcall	.-490    	; 0xaa2 <_Z4beepiii>
            redled(KLED_OFF, 0);
     c8c:	80 e0       	ldi	r24, 0x00	; 0
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	60 e0       	ldi	r22, 0x00	; 0
     c92:	70 e0       	ldi	r23, 0x00	; 0
     c94:	b6 de       	rcall	.-660    	; 0xa02 <_Z6redledii>
            greenled(KLED_SOLID, 0);
     c96:	85 e0       	ldi	r24, 0x05	; 5
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	60 e0       	ldi	r22, 0x00	; 0
     c9c:	70 e0       	ldi	r23, 0x00	; 0
     c9e:	60 de       	rcall	.-832    	; 0x960 <_Z8greenledii>
            blueled(KLED_SOLID, 0);
     ca0:	85 e0       	ldi	r24, 0x05	; 5
     ca2:	90 e0       	ldi	r25, 0x00	; 0
     ca4:	13 c0       	rjmp	.+38     	; 0xccc <_Z13activate_modei+0xb0>
            return;
            break;
        case KMODE_FUNCTIONS:
            beep(2000, KBEEP_SHORTBEEP, 4);
     ca6:	80 ed       	ldi	r24, 0xD0	; 208
     ca8:	97 e0       	ldi	r25, 0x07	; 7
     caa:	63 e0       	ldi	r22, 0x03	; 3
     cac:	70 e0       	ldi	r23, 0x00	; 0
     cae:	44 e0       	ldi	r20, 0x04	; 4
     cb0:	50 e0       	ldi	r21, 0x00	; 0
     cb2:	f7 de       	rcall	.-530    	; 0xaa2 <_Z4beepiii>
            redled(KLED_SOLID, 0);
     cb4:	85 e0       	ldi	r24, 0x05	; 5
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	60 e0       	ldi	r22, 0x00	; 0
     cba:	70 e0       	ldi	r23, 0x00	; 0
     cbc:	a2 de       	rcall	.-700    	; 0xa02 <_Z6redledii>
            greenled(KLED_OFF, 0);
     cbe:	80 e0       	ldi	r24, 0x00	; 0
     cc0:	90 e0       	ldi	r25, 0x00	; 0
     cc2:	60 e0       	ldi	r22, 0x00	; 0
     cc4:	70 e0       	ldi	r23, 0x00	; 0
     cc6:	4c de       	rcall	.-872    	; 0x960 <_Z8greenledii>
            blueled(KLED_OFF, 0);
     cc8:	80 e0       	ldi	r24, 0x00	; 0
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	60 e0       	ldi	r22, 0x00	; 0
     cce:	70 e0       	ldi	r23, 0x00	; 0
     cd0:	f5 cd       	rjmp	.-1046   	; 0x8bc <_Z7blueledii>
            return;
            break;
        case KMODE_GUI:
            beep(1600, KBEEP_SHORTPULSE, 1);
     cd2:	80 e4       	ldi	r24, 0x40	; 64
     cd4:	96 e0       	ldi	r25, 0x06	; 6
     cd6:	64 e0       	ldi	r22, 0x04	; 4
     cd8:	70 e0       	ldi	r23, 0x00	; 0
     cda:	41 e0       	ldi	r20, 0x01	; 1
     cdc:	50 e0       	ldi	r21, 0x00	; 0
     cde:	e1 de       	rcall	.-574    	; 0xaa2 <_Z4beepiii>
            greenled(KLED_SHORTBLINK, 0);
     ce0:	83 e0       	ldi	r24, 0x03	; 3
     ce2:	90 e0       	ldi	r25, 0x00	; 0
     ce4:	60 e0       	ldi	r22, 0x00	; 0
     ce6:	70 e0       	ldi	r23, 0x00	; 0
     ce8:	3b de       	rcall	.-906    	; 0x960 <_Z8greenledii>
            modifierdown(MODIFIERKEY_GUI);
     cea:	88 e0       	ldi	r24, 0x08	; 8
     cec:	90 e0       	ldi	r25, 0x00	; 0
     cee:	6f cf       	rjmp	.-290    	; 0xbce <_Z12modifierdowni>
     cf0:	08 95       	ret

00000cf2 <_Z7popmodev>:
        }
    }
    
    void popmode() {
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.println("touchset popmode");
     cf2:	80 ef       	ldi	r24, 0xF0	; 240
     cf4:	98 e0       	ldi	r25, 0x08	; 8
     cf6:	6a ea       	ldi	r22, 0xAA	; 170
     cf8:	71 e0       	ldi	r23, 0x01	; 1
     cfa:	0e 94 c6 2d 	call	0x5b8c	; 0x5b8c <_ZN16USBVirtualSerial7printlnEPKc>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        if (modeStackPos > 0) deactivate_mode(modeStack[--modeStackPos]);
     cfe:	e0 91 b3 08 	lds	r30, 0x08B3
     d02:	f0 91 b4 08 	lds	r31, 0x08B4
     d06:	1e 16       	cp	r1, r30
     d08:	1f 06       	cpc	r1, r31
     d0a:	64 f4       	brge	.+24     	; 0xd24 <_Z7popmodev+0x32>
     d0c:	31 97       	sbiw	r30, 0x01	; 1
     d0e:	f0 93 b4 08 	sts	0x08B4, r31
     d12:	e0 93 b3 08 	sts	0x08B3, r30
     d16:	ee 0f       	add	r30, r30
     d18:	ff 1f       	adc	r31, r31
     d1a:	e1 56       	subi	r30, 0x61	; 97
     d1c:	f7 4f       	sbci	r31, 0xF7	; 247
     d1e:	80 81       	ld	r24, Z
     d20:	91 81       	ldd	r25, Z+1	; 0x01
     d22:	4f df       	rcall	.-354    	; 0xbc2 <_Z15deactivate_modei>
        if (modeStackPos == 0) modeStack[modeStackPos++] = 0;
     d24:	80 91 b3 08 	lds	r24, 0x08B3
     d28:	90 91 b4 08 	lds	r25, 0x08B4
     d2c:	89 2b       	or	r24, r25
     d2e:	51 f4       	brne	.+20     	; 0xd44 <_Z7popmodev+0x52>
     d30:	10 92 a0 08 	sts	0x08A0, r1
     d34:	10 92 9f 08 	sts	0x089F, r1
     d38:	81 e0       	ldi	r24, 0x01	; 1
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	90 93 b4 08 	sts	0x08B4, r25
     d40:	80 93 b3 08 	sts	0x08B3, r24
        activate_mode(modeStack[modeStackPos - 1]);
     d44:	e0 91 b3 08 	lds	r30, 0x08B3
     d48:	f0 91 b4 08 	lds	r31, 0x08B4
     d4c:	ee 0f       	add	r30, r30
     d4e:	ff 1f       	adc	r31, r31
     d50:	e3 56       	subi	r30, 0x63	; 99
     d52:	f7 4f       	sbci	r31, 0xF7	; 247
     d54:	80 81       	ld	r24, Z
     d56:	91 81       	ldd	r25, Z+1	; 0x01
    }
     d58:	61 cf       	rjmp	.-318    	; 0xc1c <_Z13activate_modei>

00000d5a <_Z8pushmodei>:
        modeStackPos = 1;
        modeStack[0] = mode;
        activate_mode(mode);
    }
    
    void pushmode(int mode) {
     d5a:	cf 93       	push	r28
     d5c:	df 93       	push	r29
     d5e:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset pushmode ");
     d60:	80 ef       	ldi	r24, 0xF0	; 240
     d62:	98 e0       	ldi	r25, 0x08	; 8
     d64:	6b eb       	ldi	r22, 0xBB	; 187
     d66:	71 e0       	ldi	r23, 0x01	; 1
     d68:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(mode);
     d6c:	80 ef       	ldi	r24, 0xF0	; 240
     d6e:	98 e0       	ldi	r25, 0x08	; 8
     d70:	be 01       	movw	r22, r28
     d72:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        if (modeStackPos < 10) {
     d76:	80 91 b3 08 	lds	r24, 0x08B3
     d7a:	90 91 b4 08 	lds	r25, 0x08B4
     d7e:	8a 30       	cpi	r24, 0x0A	; 10
     d80:	91 05       	cpc	r25, r1
     d82:	74 f4       	brge	.+28     	; 0xda0 <_Z8pushmodei+0x46>
            modeStack[modeStackPos] = mode;
     d84:	fc 01       	movw	r30, r24
     d86:	ee 0f       	add	r30, r30
     d88:	ff 1f       	adc	r31, r31
     d8a:	e1 56       	subi	r30, 0x61	; 97
     d8c:	f7 4f       	sbci	r31, 0xF7	; 247
     d8e:	d1 83       	std	Z+1, r29	; 0x01
     d90:	c0 83       	st	Z, r28
            modeStackPos++;
     d92:	01 96       	adiw	r24, 0x01	; 1
     d94:	90 93 b4 08 	sts	0x08B4, r25
     d98:	80 93 b3 08 	sts	0x08B3, r24
            activate_mode(mode);
     d9c:	ce 01       	movw	r24, r28
     d9e:	3e df       	rcall	.-388    	; 0xc1c <_Z13activate_modei>
        }
    }
     da0:	df 91       	pop	r29
     da2:	cf 91       	pop	r28
     da4:	08 95       	ret

00000da6 <_Z10togglemodei>:
        if (modeStackPos > 0) deactivate_mode(modeStack[--modeStackPos]);
        if (modeStackPos == 0) modeStack[modeStackPos++] = 0;
        activate_mode(modeStack[modeStackPos - 1]);
    }
    
    void togglemode(int mode) {
     da6:	0f 93       	push	r16
     da8:	1f 93       	push	r17
     daa:	cf 93       	push	r28
     dac:	df 93       	push	r29
     dae:	8c 01       	movw	r16, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset togglemode ");
     db0:	80 ef       	ldi	r24, 0xF0	; 240
     db2:	98 e0       	ldi	r25, 0x08	; 8
     db4:	6e ec       	ldi	r22, 0xCE	; 206
     db6:	71 e0       	ldi	r23, 0x01	; 1
     db8:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(mode);
     dbc:	80 ef       	ldi	r24, 0xF0	; 240
     dbe:	98 e0       	ldi	r25, 0x08	; 8
     dc0:	b8 01       	movw	r22, r16
     dc2:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        // find the mode and disable it if it's in the stack
        int i = 0;
        for (i = 0; i < modeStackPos && modeStack[i] != mode; i++);
     dc6:	20 91 b3 08 	lds	r18, 0x08B3
     dca:	30 91 b4 08 	lds	r19, 0x08B4
     dce:	ef e9       	ldi	r30, 0x9F	; 159
     dd0:	f8 e0       	ldi	r31, 0x08	; 8
     dd2:	c0 e0       	ldi	r28, 0x00	; 0
     dd4:	d0 e0       	ldi	r29, 0x00	; 0
     dd6:	01 c0       	rjmp	.+2      	; 0xdda <_Z10togglemodei+0x34>
     dd8:	21 96       	adiw	r28, 0x01	; 1
     dda:	c2 17       	cp	r28, r18
     ddc:	d3 07       	cpc	r29, r19
     dde:	34 f4       	brge	.+12     	; 0xdec <_Z10togglemodei+0x46>
     de0:	81 91       	ld	r24, Z+
     de2:	91 91       	ld	r25, Z+
     de4:	80 17       	cp	r24, r16
     de6:	91 07       	cpc	r25, r17
     de8:	b9 f7       	brne	.-18     	; 0xdd8 <_Z10togglemodei+0x32>
     dea:	13 c0       	rjmp	.+38     	; 0xe12 <_Z10togglemodei+0x6c>
            deactivate_mode(mode);
            for (i++; i < modeStackPos; i++) modeStack[i - 1] = modeStack[i];
            modeStackPos--;
        } else {
            // not enabled, so turn it on
            pushmode(mode);
     dec:	c8 01       	movw	r24, r16
     dee:	b5 df       	rcall	.-150    	; 0xd5a <_Z8pushmodei>
     df0:	1d c0       	rjmp	.+58     	; 0xe2c <_Z10togglemodei+0x86>
        int i = 0;
        for (i = 0; i < modeStackPos && modeStack[i] != mode; i++);
        if (i < modeStackPos) {
            // enabled, so turn it off
            deactivate_mode(mode);
            for (i++; i < modeStackPos; i++) modeStack[i - 1] = modeStack[i];
     df2:	82 81       	ldd	r24, Z+2	; 0x02
     df4:	93 81       	ldd	r25, Z+3	; 0x03
     df6:	81 93       	st	Z+, r24
     df8:	91 93       	st	Z+, r25
     dfa:	2f 5f       	subi	r18, 0xFF	; 255
     dfc:	3f 4f       	sbci	r19, 0xFF	; 255
     dfe:	24 17       	cp	r18, r20
     e00:	35 07       	cpc	r19, r21
     e02:	bc f3       	brlt	.-18     	; 0xdf2 <_Z10togglemodei+0x4c>
            modeStackPos--;
     e04:	41 50       	subi	r20, 0x01	; 1
     e06:	50 40       	sbci	r21, 0x00	; 0
     e08:	50 93 b4 08 	sts	0x08B4, r21
     e0c:	40 93 b3 08 	sts	0x08B3, r20
     e10:	0d c0       	rjmp	.+26     	; 0xe2c <_Z10togglemodei+0x86>
        // find the mode and disable it if it's in the stack
        int i = 0;
        for (i = 0; i < modeStackPos && modeStack[i] != mode; i++);
        if (i < modeStackPos) {
            // enabled, so turn it off
            deactivate_mode(mode);
     e12:	c8 01       	movw	r24, r16
     e14:	d6 de       	rcall	.-596    	; 0xbc2 <_Z15deactivate_modei>
            for (i++; i < modeStackPos; i++) modeStack[i - 1] = modeStack[i];
     e16:	40 91 b3 08 	lds	r20, 0x08B3
     e1a:	50 91 b4 08 	lds	r21, 0x08B4
     e1e:	9e 01       	movw	r18, r28
     e20:	fe 01       	movw	r30, r28
     e22:	ee 0f       	add	r30, r30
     e24:	ff 1f       	adc	r31, r31
     e26:	e1 56       	subi	r30, 0x61	; 97
     e28:	f7 4f       	sbci	r31, 0xF7	; 247
     e2a:	e7 cf       	rjmp	.-50     	; 0xdfa <_Z10togglemodei+0x54>
            modeStackPos--;
        } else {
            // not enabled, so turn it on
            pushmode(mode);
        }
    }
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <_Z7setmodei>:
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    }
    
    void setmode(int mode) {
     e36:	cf 93       	push	r28
     e38:	df 93       	push	r29
     e3a:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset setmode ");
     e3c:	80 ef       	ldi	r24, 0xF0	; 240
     e3e:	98 e0       	ldi	r25, 0x08	; 8
     e40:	63 ee       	ldi	r22, 0xE3	; 227
     e42:	71 e0       	ldi	r23, 0x01	; 1
     e44:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(mode);
     e48:	80 ef       	ldi	r24, 0xF0	; 240
     e4a:	98 e0       	ldi	r25, 0x08	; 8
     e4c:	be 01       	movw	r22, r28
     e4e:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
     e52:	10 c0       	rjmp	.+32     	; 0xe74 <_Z7setmodei+0x3e>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        for (; modeStackPos > 0; modeStackPos--) deactivate_mode(modeStack[modeStackPos - 1]);
     e54:	ee 0f       	add	r30, r30
     e56:	ff 1f       	adc	r31, r31
     e58:	e3 56       	subi	r30, 0x63	; 99
     e5a:	f7 4f       	sbci	r31, 0xF7	; 247
     e5c:	80 81       	ld	r24, Z
     e5e:	91 81       	ldd	r25, Z+1	; 0x01
     e60:	b0 de       	rcall	.-672    	; 0xbc2 <_Z15deactivate_modei>
     e62:	80 91 b3 08 	lds	r24, 0x08B3
     e66:	90 91 b4 08 	lds	r25, 0x08B4
     e6a:	01 97       	sbiw	r24, 0x01	; 1
     e6c:	90 93 b4 08 	sts	0x08B4, r25
     e70:	80 93 b3 08 	sts	0x08B3, r24
     e74:	e0 91 b3 08 	lds	r30, 0x08B3
     e78:	f0 91 b4 08 	lds	r31, 0x08B4
     e7c:	1e 16       	cp	r1, r30
     e7e:	1f 06       	cpc	r1, r31
     e80:	4c f3       	brlt	.-46     	; 0xe54 <_Z7setmodei+0x1e>
        modeStackPos = 1;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	90 93 b4 08 	sts	0x08B4, r25
     e8a:	80 93 b3 08 	sts	0x08B3, r24
        modeStack[0] = mode;
     e8e:	d0 93 a0 08 	sts	0x08A0, r29
     e92:	c0 93 9f 08 	sts	0x089F, r28
        activate_mode(mode);
     e96:	ce 01       	movw	r24, r28
     e98:	c1 de       	rcall	.-638    	; 0xc1c <_Z13activate_modei>
    }
     e9a:	df 91       	pop	r29
     e9c:	cf 91       	pop	r28
     e9e:	08 95       	ret

00000ea0 <setup>:
void setup() {
    /* ===============================================
     * INITIALIZE SERIAL DEBUGGING
    =============================================== */
    #ifdef SERIAL_DEBUG
        Serial.begin(38400);
     ea0:	80 ef       	ldi	r24, 0xF0	; 240
     ea2:	98 e0       	ldi	r25, 0x08	; 8
     ea4:	40 e0       	ldi	r20, 0x00	; 0
     ea6:	56 e9       	ldi	r21, 0x96	; 150
     ea8:	60 e0       	ldi	r22, 0x00	; 0
     eaa:	70 e0       	ldi	r23, 0x00	; 0
     eac:	0e 94 c9 2a 	call	0x5592	; 0x5592 <_ZN16USBVirtualSerial5beginEm>
        Serial.println("info Keyglove device activated");
     eb0:	80 ef       	ldi	r24, 0xF0	; 240
     eb2:	98 e0       	ldi	r25, 0x08	; 8
     eb4:	65 ef       	ldi	r22, 0xF5	; 245
     eb6:	71 e0       	ldi	r23, 0x01	; 1
     eb8:	0e 94 c6 2d 	call	0x5b8c	; 0x5b8c <_ZN16USBVirtualSerial7printlnEPKc>

    /* ===============================================
     * INITIALIZE TRICOLOR STATUS LED CONTROL
    =============================================== */
    #ifdef ENABLE_TRICOLOR
        pinMode(TRICOLOR_RED_PIN, OUTPUT);
     ebc:	8b e2       	ldi	r24, 0x2B	; 43
     ebe:	61 e0       	ldi	r22, 0x01	; 1
     ec0:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
        pinMode(TRICOLOR_GREEN_PIN, OUTPUT);
     ec4:	8c e2       	ldi	r24, 0x2C	; 44
     ec6:	61 e0       	ldi	r22, 0x01	; 1
     ec8:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
        pinMode(TRICOLOR_BLUE_PIN, OUTPUT);
     ecc:	8d e2       	ldi	r24, 0x2D	; 45
     ece:	61 e0       	ldi	r22, 0x01	; 1
     ed0:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
        tricolor(1, 1, 1); // turn everything on and wait 1/10 sec
     ed4:	81 e0       	ldi	r24, 0x01	; 1
     ed6:	61 e0       	ldi	r22, 0x01	; 1
     ed8:	41 e0       	ldi	r20, 0x01	; 1
     eda:	7b dc       	rcall	.-1802   	; 0x7d2 <_Z8tricolorhhh>
        delay(100);
     edc:	64 e6       	ldi	r22, 0x64	; 100
     ede:	70 e0       	ldi	r23, 0x00	; 0
     ee0:	80 e0       	ldi	r24, 0x00	; 0
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
        tricolor(0, 0, 0); // turn everything off again
     ee8:	80 e0       	ldi	r24, 0x00	; 0
     eea:	60 e0       	ldi	r22, 0x00	; 0
     eec:	40 e0       	ldi	r20, 0x00	; 0
     eee:	71 dc       	rcall	.-1822   	; 0x7d2 <_Z8tricolorhhh>

    /* ===============================================
     * INITIALIZE BLINK LED STATE
    =============================================== */
    #ifdef ENABLE_BLINK
        pinMode(BLINK_LED_PIN, OUTPUT);
     ef0:	86 e0       	ldi	r24, 0x06	; 6
     ef2:	61 e0       	ldi	r22, 0x01	; 1
     ef4:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
        digitalWrite(BLINK_LED_PIN, LOW);
     ef8:	86 e0       	ldi	r24, 0x06	; 6
     efa:	60 e0       	ldi	r22, 0x00	; 0
     efc:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <digitalWrite>
        blink_led = false;
     f00:	10 92 8e 08 	sts	0x088E, r1
    /* ===============================================
     * INITIALIZE TOUCH SENSOR DIGITAL I/O PINS
    =============================================== */
    #ifdef ENABLE_TOUCH
        // make sure we enable internal pullup resistors
        for (i = 0; i < KG_TOTAL_SENSORS; i++) {
     f04:	10 92 a8 06 	sts	0x06A8, r1
     f08:	10 92 a9 06 	sts	0x06A9, r1
     f0c:	10 92 aa 06 	sts	0x06AA, r1
     f10:	10 92 ab 06 	sts	0x06AB, r1
     f14:	28 c0       	rjmp	.+80     	; 0xf66 <setup+0xc6>
            pinMode(pins[i], INPUT);
     f16:	fc 01       	movw	r30, r24
     f18:	ee 0f       	add	r30, r30
     f1a:	ff 1f       	adc	r31, r31
     f1c:	eb 52       	subi	r30, 0x2B	; 43
     f1e:	fd 4f       	sbci	r31, 0xFD	; 253
     f20:	80 81       	ld	r24, Z
     f22:	60 e0       	ldi	r22, 0x00	; 0
     f24:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
            digitalWrite(pins[i], HIGH);
     f28:	e0 91 a8 06 	lds	r30, 0x06A8
     f2c:	f0 91 a9 06 	lds	r31, 0x06A9
     f30:	ee 0f       	add	r30, r30
     f32:	ff 1f       	adc	r31, r31
     f34:	eb 52       	subi	r30, 0x2B	; 43
     f36:	fd 4f       	sbci	r31, 0xFD	; 253
     f38:	80 81       	ld	r24, Z
     f3a:	61 e0       	ldi	r22, 0x01	; 1
     f3c:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <digitalWrite>
    /* ===============================================
     * INITIALIZE TOUCH SENSOR DIGITAL I/O PINS
    =============================================== */
    #ifdef ENABLE_TOUCH
        // make sure we enable internal pullup resistors
        for (i = 0; i < KG_TOTAL_SENSORS; i++) {
     f40:	80 91 a8 06 	lds	r24, 0x06A8
     f44:	90 91 a9 06 	lds	r25, 0x06A9
     f48:	a0 91 aa 06 	lds	r26, 0x06AA
     f4c:	b0 91 ab 06 	lds	r27, 0x06AB
     f50:	01 96       	adiw	r24, 0x01	; 1
     f52:	a1 1d       	adc	r26, r1
     f54:	b1 1d       	adc	r27, r1
     f56:	80 93 a8 06 	sts	0x06A8, r24
     f5a:	90 93 a9 06 	sts	0x06A9, r25
     f5e:	a0 93 aa 06 	sts	0x06AA, r26
     f62:	b0 93 ab 06 	sts	0x06AB, r27
     f66:	80 91 a8 06 	lds	r24, 0x06A8
     f6a:	90 91 a9 06 	lds	r25, 0x06A9
     f6e:	a0 91 aa 06 	lds	r26, 0x06AA
     f72:	b0 91 ab 06 	lds	r27, 0x06AB
     f76:	82 32       	cpi	r24, 0x22	; 34
     f78:	91 05       	cpc	r25, r1
     f7a:	a1 05       	cpc	r26, r1
     f7c:	b1 05       	cpc	r27, r1
     f7e:	5c f2       	brlt	.-106    	; 0xf16 <setup+0x76>
            pinMode(pins[i], INPUT);
            digitalWrite(pins[i], HIGH);
        }
        mode = 0; // set to base mode, no alt/shift/mouse/prog
     f80:	10 92 d3 08 	sts	0x08D3, r1
    /* ===============================================
     * INITIALIZE ACCELEROMETER INTERFACE
    =============================================== */
    #ifdef ENABLE_ACCEL
        // initialize accelerometer
        accel.powerOn();
     f84:	83 ed       	ldi	r24, 0xD3	; 211
     f86:	96 e0       	ldi	r25, 0x06	; 6
     f88:	0e 94 92 33 	call	0x6724	; 0x6724 <_ZN13Accelerometer7powerOnEv>
        accel.setRate(100);
     f8c:	83 ed       	ldi	r24, 0xD3	; 211
     f8e:	96 e0       	ldi	r25, 0x06	; 6
     f90:	40 e0       	ldi	r20, 0x00	; 0
     f92:	50 e0       	ldi	r21, 0x00	; 0
     f94:	68 ec       	ldi	r22, 0xC8	; 200
     f96:	72 e4       	ldi	r23, 0x42	; 66
     f98:	0e 94 63 31 	call	0x62c6	; 0x62c6 <_ZN13Accelerometer7setRateEf>
        x = y = z = 0;
     f9c:	10 92 ee 06 	sts	0x06EE, r1
     fa0:	10 92 ed 06 	sts	0x06ED, r1
     fa4:	10 92 ec 06 	sts	0x06EC, r1
     fa8:	10 92 eb 06 	sts	0x06EB, r1
     fac:	10 92 ea 06 	sts	0x06EA, r1
     fb0:	10 92 e9 06 	sts	0x06E9, r1
        cx = cy = cz = 0;
     fb4:	10 92 09 07 	sts	0x0709, r1
     fb8:	10 92 0a 07 	sts	0x070A, r1
     fbc:	10 92 0b 07 	sts	0x070B, r1
     fc0:	10 92 0c 07 	sts	0x070C, r1
     fc4:	10 92 05 07 	sts	0x0705, r1
     fc8:	10 92 06 07 	sts	0x0706, r1
     fcc:	10 92 07 07 	sts	0x0707, r1
     fd0:	10 92 08 07 	sts	0x0708, r1
     fd4:	10 92 01 07 	sts	0x0701, r1
     fd8:	10 92 02 07 	sts	0x0702, r1
     fdc:	10 92 03 07 	sts	0x0703, r1
     fe0:	10 92 04 07 	sts	0x0704, r1
        ax = ay = az = 0;
     fe4:	10 92 9c 07 	sts	0x079C, r1
     fe8:	10 92 9b 07 	sts	0x079B, r1
     fec:	10 92 9a 07 	sts	0x079A, r1
     ff0:	10 92 99 07 	sts	0x0799, r1
     ff4:	10 92 98 07 	sts	0x0798, r1
     ff8:	10 92 97 07 	sts	0x0797, r1
        accelMicros = 0;
     ffc:	10 92 d9 06 	sts	0x06D9, r1
    1000:	10 92 da 06 	sts	0x06DA, r1
    1004:	10 92 db 06 	sts	0x06DB, r1
    1008:	10 92 dc 06 	sts	0x06DC, r1
        accelTick = 0;
    100c:	10 92 e2 06 	sts	0x06E2, r1
    1010:	10 92 e1 06 	sts	0x06E1, r1
        accelCalibrated = false;
    1014:	10 92 b2 07 	sts	0x07B2, r1
        xMin = yMin = zMin = 0;
    1018:	10 92 90 07 	sts	0x0790, r1
    101c:	10 92 8f 07 	sts	0x078F, r1
    1020:	10 92 8e 07 	sts	0x078E, r1
    1024:	10 92 8d 07 	sts	0x078D, r1
    1028:	10 92 8c 07 	sts	0x078C, r1
    102c:	10 92 8b 07 	sts	0x078B, r1
        xMax = yMax = zMax = 0;
    1030:	10 92 96 07 	sts	0x0796, r1
    1034:	10 92 95 07 	sts	0x0795, r1
    1038:	10 92 94 07 	sts	0x0794, r1
    103c:	10 92 93 07 	sts	0x0793, r1
    1040:	10 92 92 07 	sts	0x0792, r1
    1044:	10 92 91 07 	sts	0x0791, r1
    /* ===============================================
     * INITIALIZE GYROSCOPE INTERFACE
    =============================================== */
    #ifdef ENABLE_GYRO
        // initialize gyroscope
        gyro.init(ITG3200_ADDR_AD0_LOW); 
    1048:	83 eb       	ldi	r24, 0xB3	; 179
    104a:	97 e0       	ldi	r25, 0x07	; 7
    104c:	68 e6       	ldi	r22, 0x68	; 104
    104e:	70 e0       	ldi	r23, 0x00	; 0
    1050:	0e 94 4f 39 	call	0x729e	; 0x729e <_ZN7ITG32004initEj>
        gx = gy = gz = 0;
    1054:	10 92 e1 07 	sts	0x07E1, r1
    1058:	10 92 e0 07 	sts	0x07E0, r1
    105c:	10 92 df 07 	sts	0x07DF, r1
    1060:	10 92 de 07 	sts	0x07DE, r1
    1064:	10 92 dd 07 	sts	0x07DD, r1
    1068:	10 92 dc 07 	sts	0x07DC, r1
        gyroMicros = 0;
    106c:	10 92 cc 07 	sts	0x07CC, r1
    1070:	10 92 cd 07 	sts	0x07CD, r1
    1074:	10 92 ce 07 	sts	0x07CE, r1
    1078:	10 92 cf 07 	sts	0x07CF, r1
        gyroTick = 0;
    107c:	10 92 d5 07 	sts	0x07D5, r1
    1080:	10 92 d4 07 	sts	0x07D4, r1
        gyroCalibrated = false;
    1084:	10 92 87 08 	sts	0x0887, r1
        gxMin = gyMin = gzMin = 0;
    1088:	10 92 7d 08 	sts	0x087D, r1
    108c:	10 92 7c 08 	sts	0x087C, r1
    1090:	10 92 7b 08 	sts	0x087B, r1
    1094:	10 92 7a 08 	sts	0x087A, r1
    1098:	10 92 79 08 	sts	0x0879, r1
    109c:	10 92 78 08 	sts	0x0878, r1
        gxMax = gyMax = gzMax = 0;
    10a0:	10 92 83 08 	sts	0x0883, r1
    10a4:	10 92 82 08 	sts	0x0882, r1
    10a8:	10 92 81 08 	sts	0x0881, r1
    10ac:	10 92 80 08 	sts	0x0880, r1
    10b0:	10 92 7f 08 	sts	0x087F, r1
    10b4:	10 92 7e 08 	sts	0x087E, r1
    #endif /* ENABLE_GYRO */

    mx = my = mz = mx0 = my0 = mz0 = 0;
    10b8:	10 92 bb 06 	sts	0x06BB, r1
    10bc:	10 92 ba 06 	sts	0x06BA, r1
    10c0:	10 92 b9 06 	sts	0x06B9, r1
    10c4:	10 92 b8 06 	sts	0x06B8, r1
    10c8:	10 92 b7 06 	sts	0x06B7, r1
    10cc:	10 92 b6 06 	sts	0x06B6, r1
    10d0:	10 92 b3 06 	sts	0x06B3, r1
    10d4:	10 92 b2 06 	sts	0x06B2, r1
    10d8:	10 92 b1 06 	sts	0x06B1, r1
    10dc:	10 92 b0 06 	sts	0x06B0, r1
    10e0:	10 92 af 06 	sts	0x06AF, r1
    10e4:	10 92 ae 06 	sts	0x06AE, r1
    sy = sy0 = 0;
    10e8:	10 92 bd 06 	sts	0x06BD, r1
    10ec:	10 92 bc 06 	sts	0x06BC, r1
    10f0:	10 92 b5 06 	sts	0x06B5, r1
    10f4:	10 92 b4 06 	sts	0x06B4, r1

    /* ===============================================
     * INITIALIZE VIBRATION FEEDBACK
    =============================================== */
    #ifdef ENABLE_VIBRATE
        pinMode(VIBRATE_PIN, OUTPUT);
    10f8:	89 e2       	ldi	r24, 0x29	; 41
    10fa:	61 e0       	ldi	r22, 0x01	; 1
    10fc:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
        digitalWrite(VIBRATE_PIN, LOW);
    1100:	89 e2       	ldi	r24, 0x29	; 41
    1102:	60 e0       	ldi	r22, 0x00	; 0
    1104:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <digitalWrite>
        delay(100);
    1108:	64 e6       	ldi	r22, 0x64	; 100
    110a:	70 e0       	ldi	r23, 0x00	; 0
    110c:	80 e0       	ldi	r24, 0x00	; 0
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
        digitalWrite(VIBRATE_PIN, HIGH);
    1114:	89 e2       	ldi	r24, 0x29	; 41
    1116:	61 e0       	ldi	r22, 0x01	; 1
    1118:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <digitalWrite>
    
    /* ===============================================
     * INITIALIZE AUDIO FEEDBACK
    =============================================== */
    #ifdef ENABLE_BEEP
        tone(SOUND_PIN, 1760, 100);
    111c:	8a e2       	ldi	r24, 0x2A	; 42
    111e:	60 ee       	ldi	r22, 0xE0	; 224
    1120:	76 e0       	ldi	r23, 0x06	; 6
    1122:	24 e6       	ldi	r18, 0x64	; 100
    1124:	30 e0       	ldi	r19, 0x00	; 0
    1126:	40 e0       	ldi	r20, 0x00	; 0
    1128:	50 e0       	ldi	r21, 0x00	; 0
    112a:	0e 94 45 28 	call	0x508a	; 0x508a <_Z4tonehjm>
        delay(100);
    112e:	64 e6       	ldi	r22, 0x64	; 100
    1130:	70 e0       	ldi	r23, 0x00	; 0
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	90 e0       	ldi	r25, 0x00	; 0
    1136:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
        tone(SOUND_PIN, 1760, 100);
    113a:	8a e2       	ldi	r24, 0x2A	; 42
    113c:	60 ee       	ldi	r22, 0xE0	; 224
    113e:	76 e0       	ldi	r23, 0x06	; 6
    1140:	24 e6       	ldi	r18, 0x64	; 100
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	40 e0       	ldi	r20, 0x00	; 0
    1146:	50 e0       	ldi	r21, 0x00	; 0
    1148:	0e 94 45 28 	call	0x508a	; 0x508a <_Z4tonehjm>
        delay(100);
    114c:	64 e6       	ldi	r22, 0x64	; 100
    114e:	70 e0       	ldi	r23, 0x00	; 0
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
    #endif /* ENABLE_BEEP */

    #ifdef ENABLE_TOUCH
        setmode(0); // default touchset mode is always 0
    1158:	80 e0       	ldi	r24, 0x00	; 0
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	6c de       	rcall	.-808    	; 0xe36 <_Z7setmodei>
    #endif /* ENABLE_TOUCH */

    // initialize benchmark
    t = millis();
    115e:	0e 94 b6 39 	call	0x736c	; 0x736c <millis>
    1162:	60 93 a4 06 	sts	0x06A4, r22
    1166:	70 93 a5 06 	sts	0x06A5, r23
    116a:	80 93 a6 06 	sts	0x06A6, r24
    116e:	90 93 a7 06 	sts	0x06A7, r25
}
    1172:	08 95       	ret

00001174 <_Z13modifierpressi>:
        } else {
            modifierdown(code);
        }
    }
    
    void modifierpress(int code) {
    1174:	ef 92       	push	r14
    1176:	ff 92       	push	r15
    1178:	0f 93       	push	r16
    117a:	1f 93       	push	r17
    117c:	7c 01       	movw	r14, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset modifierpress ");
    117e:	00 ef       	ldi	r16, 0xF0	; 240
    1180:	18 e0       	ldi	r17, 0x08	; 8
    1182:	c8 01       	movw	r24, r16
    1184:	64 e1       	ldi	r22, 0x14	; 20
    1186:	72 e0       	ldi	r23, 0x02	; 2
    1188:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(code);
    118c:	c8 01       	movw	r24, r16
    118e:	b7 01       	movw	r22, r14
    1190:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        modifierdown(code);
    1194:	c7 01       	movw	r24, r14
    1196:	1b dd       	rcall	.-1482   	; 0xbce <_Z12modifierdowni>
        delay(5);
    1198:	65 e0       	ldi	r22, 0x05	; 5
    119a:	70 e0       	ldi	r23, 0x00	; 0
    119c:	80 e0       	ldi	r24, 0x00	; 0
    119e:	90 e0       	ldi	r25, 0x00	; 0
    11a0:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
        modifierup(code);
    11a4:	c7 01       	movw	r24, r14
    11a6:	e4 dc       	rcall	.-1592   	; 0xb70 <_Z10modifierupi>
    }
    11a8:	1f 91       	pop	r17
    11aa:	0f 91       	pop	r16
    11ac:	ff 90       	pop	r15
    11ae:	ef 90       	pop	r14
    11b0:	08 95       	ret

000011b2 <_Z14togglemodifieri>:
                RX400.send_now();
            #endif /* ENABLE_RX400 */
        }
    }
    
    void togglemodifier(int code) {
    11b2:	cf 93       	push	r28
    11b4:	df 93       	push	r29
    11b6:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset modifiertoggle ");
    11b8:	80 ef       	ldi	r24, 0xF0	; 240
    11ba:	98 e0       	ldi	r25, 0x08	; 8
    11bc:	6c e2       	ldi	r22, 0x2C	; 44
    11be:	72 e0       	ldi	r23, 0x02	; 2
    11c0:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(code);
    11c4:	80 ef       	ldi	r24, 0xF0	; 240
    11c6:	98 e0       	ldi	r25, 0x08	; 8
    11c8:	be 01       	movw	r22, r28
    11ca:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        if ((modifiersDown & code) > 0) {
    11ce:	80 91 8f 08 	lds	r24, 0x088F
    11d2:	90 91 90 08 	lds	r25, 0x0890
    11d6:	8c 23       	and	r24, r28
    11d8:	9d 23       	and	r25, r29
    11da:	18 16       	cp	r1, r24
    11dc:	19 06       	cpc	r1, r25
    11de:	1c f4       	brge	.+6      	; 0x11e6 <_Z14togglemodifieri+0x34>
            modifierup(code);
    11e0:	ce 01       	movw	r24, r28
    11e2:	c6 dc       	rcall	.-1652   	; 0xb70 <_Z10modifierupi>
    11e4:	02 c0       	rjmp	.+4      	; 0x11ea <_Z14togglemodifieri+0x38>
        } else {
            modifierdown(code);
    11e6:	ce 01       	movw	r24, r28
    11e8:	f2 dc       	rcall	.-1564   	; 0xbce <_Z12modifierdowni>
        }
    }
    11ea:	df 91       	pop	r29
    11ec:	cf 91       	pop	r28
    11ee:	08 95       	ret

000011f0 <_Z5keyupi>:
        #ifdef ENABLE_RX400
            RX400.send_now();
        #endif /* ENABLE_RX400 */
    }
    
    void keyup(int code) {
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset keyup ");
    11f6:	80 ef       	ldi	r24, 0xF0	; 240
    11f8:	98 e0       	ldi	r25, 0x08	; 8
    11fa:	65 e4       	ldi	r22, 0x45	; 69
    11fc:	72 e0       	ldi	r23, 0x02	; 2
    11fe:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(code);
    1202:	80 ef       	ldi	r24, 0xF0	; 240
    1204:	98 e0       	ldi	r25, 0x08	; 8
    1206:	be 01       	movw	r22, r28
    1208:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
    120c:	e1 e9       	ldi	r30, 0x91	; 145
    120e:	f8 e0       	ldi	r31, 0x08	; 8
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	07 c0       	rjmp	.+14     	; 0x1224 <_Z5keyupi+0x34>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        int usePos = 0;
        for (usePos = 0; usePos < 6 && keysDown[usePos] != code; usePos++);
    1216:	2f 5f       	subi	r18, 0xFF	; 255
    1218:	3f 4f       	sbci	r19, 0xFF	; 255
    121a:	32 96       	adiw	r30, 0x02	; 2
    121c:	26 30       	cpi	r18, 0x06	; 6
    121e:	31 05       	cpc	r19, r1
    1220:	09 f4       	brne	.+2      	; 0x1224 <_Z5keyupi+0x34>
    1222:	4a c0       	rjmp	.+148    	; 0x12b8 <_Z5keyupi+0xc8>
    1224:	80 81       	ld	r24, Z
    1226:	91 81       	ldd	r25, Z+1	; 0x01
    1228:	8c 17       	cp	r24, r28
    122a:	9d 07       	cpc	r25, r29
    122c:	a1 f7       	brne	.-24     	; 0x1216 <_Z5keyupi+0x26>
        if (usePos == 6) return; // key not currently down...oops.
        keysDown[usePos] = 0;
    122e:	f9 01       	movw	r30, r18
    1230:	ee 0f       	add	r30, r30
    1232:	ff 1f       	adc	r31, r31
    1234:	ef 56       	subi	r30, 0x6F	; 111
    1236:	f7 4f       	sbci	r31, 0xF7	; 247
    1238:	11 82       	std	Z+1, r1	; 0x01
    123a:	10 82       	st	Z, r1
        switch (usePos) {
    123c:	22 30       	cpi	r18, 0x02	; 2
    123e:	31 05       	cpc	r19, r1
    1240:	01 f1       	breq	.+64     	; 0x1282 <_Z5keyupi+0x92>
    1242:	23 30       	cpi	r18, 0x03	; 3
    1244:	31 05       	cpc	r19, r1
    1246:	3c f4       	brge	.+14     	; 0x1256 <_Z5keyupi+0x66>
    1248:	21 15       	cp	r18, r1
    124a:	31 05       	cpc	r19, r1
    124c:	71 f0       	breq	.+28     	; 0x126a <_Z5keyupi+0x7a>
    124e:	21 30       	cpi	r18, 0x01	; 1
    1250:	31 05       	cpc	r19, r1
    1252:	71 f5       	brne	.+92     	; 0x12b0 <_Z5keyupi+0xc0>
    1254:	10 c0       	rjmp	.+32     	; 0x1276 <_Z5keyupi+0x86>
    1256:	24 30       	cpi	r18, 0x04	; 4
    1258:	31 05       	cpc	r19, r1
    125a:	f9 f0       	breq	.+62     	; 0x129a <_Z5keyupi+0xaa>
    125c:	24 30       	cpi	r18, 0x04	; 4
    125e:	31 05       	cpc	r19, r1
    1260:	b4 f0       	brlt	.+44     	; 0x128e <_Z5keyupi+0x9e>
    1262:	25 30       	cpi	r18, 0x05	; 5
    1264:	31 05       	cpc	r19, r1
    1266:	21 f5       	brne	.+72     	; 0x12b0 <_Z5keyupi+0xc0>
    1268:	1e c0       	rjmp	.+60     	; 0x12a6 <_Z5keyupi+0xb6>
            case 0:
                #ifdef ENABLE_USB
                    Keyboard.set_key1(0);
    126a:	88 e1       	ldi	r24, 0x18	; 24
    126c:	99 e0       	ldi	r25, 0x09	; 9
    126e:	60 e0       	ldi	r22, 0x00	; 0
    1270:	0e 94 e2 2a 	call	0x55c4	; 0x55c4 <_ZN11USBKeyboard8set_key1Eh>
    1274:	1d c0       	rjmp	.+58     	; 0x12b0 <_Z5keyupi+0xc0>
                    RX400.set_key1(0);
                #endif /* ENABLE_RX400 */
                break;
            case 1:
                #ifdef ENABLE_USB
                    Keyboard.set_key2(0);
    1276:	88 e1       	ldi	r24, 0x18	; 24
    1278:	99 e0       	ldi	r25, 0x09	; 9
    127a:	60 e0       	ldi	r22, 0x00	; 0
    127c:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <_ZN11USBKeyboard8set_key2Eh>
    1280:	17 c0       	rjmp	.+46     	; 0x12b0 <_Z5keyupi+0xc0>
                    RX400.set_key2(0);
                #endif /* ENABLE_RX400 */
                break;
            case 2:
                #ifdef ENABLE_USB
                    Keyboard.set_key3(0);
    1282:	88 e1       	ldi	r24, 0x18	; 24
    1284:	99 e0       	ldi	r25, 0x09	; 9
    1286:	60 e0       	ldi	r22, 0x00	; 0
    1288:	0e 94 e8 2a 	call	0x55d0	; 0x55d0 <_ZN11USBKeyboard8set_key3Eh>
    128c:	11 c0       	rjmp	.+34     	; 0x12b0 <_Z5keyupi+0xc0>
                    RX400.set_key3(0);
                #endif /* ENABLE_RX400 */
                break;
            case 3:
                #ifdef ENABLE_USB
                    Keyboard.set_key4(0);
    128e:	88 e1       	ldi	r24, 0x18	; 24
    1290:	99 e0       	ldi	r25, 0x09	; 9
    1292:	60 e0       	ldi	r22, 0x00	; 0
    1294:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <_ZN11USBKeyboard8set_key4Eh>
    1298:	0b c0       	rjmp	.+22     	; 0x12b0 <_Z5keyupi+0xc0>
                    RX400.set_key4(0);
                #endif /* ENABLE_RX400 */
                break;
            case 4:
                #ifdef ENABLE_USB
                    Keyboard.set_key5(0);
    129a:	88 e1       	ldi	r24, 0x18	; 24
    129c:	99 e0       	ldi	r25, 0x09	; 9
    129e:	60 e0       	ldi	r22, 0x00	; 0
    12a0:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <_ZN11USBKeyboard8set_key5Eh>
    12a4:	05 c0       	rjmp	.+10     	; 0x12b0 <_Z5keyupi+0xc0>
                    RX400.set_key5(0);
                #endif /* ENABLE_RX400 */
                break;
            case 5:
                #ifdef ENABLE_USB
                    Keyboard.set_key6(0);
    12a6:	88 e1       	ldi	r24, 0x18	; 24
    12a8:	99 e0       	ldi	r25, 0x09	; 9
    12aa:	60 e0       	ldi	r22, 0x00	; 0
    12ac:	0e 94 f1 2a 	call	0x55e2	; 0x55e2 <_ZN11USBKeyboard8set_key6Eh>
                    RX400.set_key6(0);
                #endif /* ENABLE_RX400 */
                break;
        }
        #ifdef ENABLE_USB
            Keyboard.send_now();
    12b0:	88 e1       	ldi	r24, 0x18	; 24
    12b2:	99 e0       	ldi	r25, 0x09	; 9
    12b4:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <_ZN11USBKeyboard8send_nowEv>
            bluetooth.send_now();
        #endif /* ENABLE_BLUETOOTH */
        #ifdef ENABLE_RX400
            RX400.send_now();
        #endif /* ENABLE_RX400 */
    }
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	08 95       	ret

000012be <_Z7keydowni>:
        mousedown(button);
        delay(5);
        mouseup(button);
    }
    
    void keydown(int code) {
    12be:	0f 93       	push	r16
    12c0:	1f 93       	push	r17
    12c2:	18 2f       	mov	r17, r24
    12c4:	09 2f       	mov	r16, r25
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset keydown ");
    12c6:	80 ef       	ldi	r24, 0xF0	; 240
    12c8:	98 e0       	ldi	r25, 0x08	; 8
    12ca:	65 e5       	ldi	r22, 0x55	; 85
    12cc:	72 e0       	ldi	r23, 0x02	; 2
    12ce:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(code);
    12d2:	80 ef       	ldi	r24, 0xF0	; 240
    12d4:	98 e0       	ldi	r25, 0x08	; 8
    12d6:	61 2f       	mov	r22, r17
    12d8:	70 2f       	mov	r23, r16
    12da:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
    12de:	e1 e9       	ldi	r30, 0x91	; 145
    12e0:	f8 e0       	ldi	r31, 0x08	; 8
    12e2:	20 e0       	ldi	r18, 0x00	; 0
    12e4:	30 e0       	ldi	r19, 0x00	; 0
    12e6:	07 c0       	rjmp	.+14     	; 0x12f6 <_Z7keydowni+0x38>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        int usePos = 0;
        for (usePos = 0; usePos < 6 && keysDown[usePos] != 0; usePos++);
    12e8:	2f 5f       	subi	r18, 0xFF	; 255
    12ea:	3f 4f       	sbci	r19, 0xFF	; 255
    12ec:	32 96       	adiw	r30, 0x02	; 2
    12ee:	26 30       	cpi	r18, 0x06	; 6
    12f0:	31 05       	cpc	r19, r1
    12f2:	09 f4       	brne	.+2      	; 0x12f6 <_Z7keydowni+0x38>
    12f4:	49 c0       	rjmp	.+146    	; 0x1388 <_Z7keydowni+0xca>
    12f6:	80 81       	ld	r24, Z
    12f8:	91 81       	ldd	r25, Z+1	; 0x01
    12fa:	89 2b       	or	r24, r25
    12fc:	a9 f7       	brne	.-22     	; 0x12e8 <_Z7keydowni+0x2a>
        if (usePos == 6) return; // out of HID keyboard buffer space, REALLY weird for the Keyglove!
        keysDown[usePos] = code;
    12fe:	f9 01       	movw	r30, r18
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	ef 56       	subi	r30, 0x6F	; 111
    1306:	f7 4f       	sbci	r31, 0xF7	; 247
    1308:	10 83       	st	Z, r17
    130a:	01 83       	std	Z+1, r16	; 0x01
        switch (usePos) {
    130c:	22 30       	cpi	r18, 0x02	; 2
    130e:	31 05       	cpc	r19, r1
    1310:	01 f1       	breq	.+64     	; 0x1352 <_Z7keydowni+0x94>
    1312:	23 30       	cpi	r18, 0x03	; 3
    1314:	31 05       	cpc	r19, r1
    1316:	3c f4       	brge	.+14     	; 0x1326 <_Z7keydowni+0x68>
    1318:	21 15       	cp	r18, r1
    131a:	31 05       	cpc	r19, r1
    131c:	71 f0       	breq	.+28     	; 0x133a <_Z7keydowni+0x7c>
    131e:	21 30       	cpi	r18, 0x01	; 1
    1320:	31 05       	cpc	r19, r1
    1322:	71 f5       	brne	.+92     	; 0x1380 <_Z7keydowni+0xc2>
    1324:	10 c0       	rjmp	.+32     	; 0x1346 <_Z7keydowni+0x88>
    1326:	24 30       	cpi	r18, 0x04	; 4
    1328:	31 05       	cpc	r19, r1
    132a:	f9 f0       	breq	.+62     	; 0x136a <_Z7keydowni+0xac>
    132c:	24 30       	cpi	r18, 0x04	; 4
    132e:	31 05       	cpc	r19, r1
    1330:	b4 f0       	brlt	.+44     	; 0x135e <_Z7keydowni+0xa0>
    1332:	25 30       	cpi	r18, 0x05	; 5
    1334:	31 05       	cpc	r19, r1
    1336:	21 f5       	brne	.+72     	; 0x1380 <_Z7keydowni+0xc2>
    1338:	1e c0       	rjmp	.+60     	; 0x1376 <_Z7keydowni+0xb8>
            case 0:
                #ifdef ENABLE_USB
                    Keyboard.set_key1(code);
    133a:	88 e1       	ldi	r24, 0x18	; 24
    133c:	99 e0       	ldi	r25, 0x09	; 9
    133e:	61 2f       	mov	r22, r17
    1340:	0e 94 e2 2a 	call	0x55c4	; 0x55c4 <_ZN11USBKeyboard8set_key1Eh>
    1344:	1d c0       	rjmp	.+58     	; 0x1380 <_Z7keydowni+0xc2>
                    RX400.set_key1(code);
                #endif /* ENABLE_RX400 */
                break;
            case 1:
                #ifdef ENABLE_USB
                    Keyboard.set_key2(code);
    1346:	88 e1       	ldi	r24, 0x18	; 24
    1348:	99 e0       	ldi	r25, 0x09	; 9
    134a:	61 2f       	mov	r22, r17
    134c:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <_ZN11USBKeyboard8set_key2Eh>
    1350:	17 c0       	rjmp	.+46     	; 0x1380 <_Z7keydowni+0xc2>
                    RX400.set_key2(code);
                #endif /* ENABLE_RX400 */
                break;
            case 2:
                #ifdef ENABLE_USB
                    Keyboard.set_key3(code);
    1352:	88 e1       	ldi	r24, 0x18	; 24
    1354:	99 e0       	ldi	r25, 0x09	; 9
    1356:	61 2f       	mov	r22, r17
    1358:	0e 94 e8 2a 	call	0x55d0	; 0x55d0 <_ZN11USBKeyboard8set_key3Eh>
    135c:	11 c0       	rjmp	.+34     	; 0x1380 <_Z7keydowni+0xc2>
                    RX400.set_key3(code);
                #endif /* ENABLE_RX400 */
                break;
            case 3:
                #ifdef ENABLE_USB
                    Keyboard.set_key4(code);
    135e:	88 e1       	ldi	r24, 0x18	; 24
    1360:	99 e0       	ldi	r25, 0x09	; 9
    1362:	61 2f       	mov	r22, r17
    1364:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <_ZN11USBKeyboard8set_key4Eh>
    1368:	0b c0       	rjmp	.+22     	; 0x1380 <_Z7keydowni+0xc2>
                    RX400.set_key4(code);
                #endif /* ENABLE_RX400 */
                break;
            case 4:
                #ifdef ENABLE_USB
                    Keyboard.set_key5(code);
    136a:	88 e1       	ldi	r24, 0x18	; 24
    136c:	99 e0       	ldi	r25, 0x09	; 9
    136e:	61 2f       	mov	r22, r17
    1370:	0e 94 ee 2a 	call	0x55dc	; 0x55dc <_ZN11USBKeyboard8set_key5Eh>
    1374:	05 c0       	rjmp	.+10     	; 0x1380 <_Z7keydowni+0xc2>
                    RX400.set_key5(code);
                #endif /* ENABLE_RX400 */
                break;
            case 5:
                #ifdef ENABLE_USB
                    Keyboard.set_key6(code);
    1376:	88 e1       	ldi	r24, 0x18	; 24
    1378:	99 e0       	ldi	r25, 0x09	; 9
    137a:	61 2f       	mov	r22, r17
    137c:	0e 94 f1 2a 	call	0x55e2	; 0x55e2 <_ZN11USBKeyboard8set_key6Eh>
                    RX400.set_key6(code);
                #endif /* ENABLE_RX400 */
                break;
        }
        #ifdef ENABLE_USB
            Keyboard.send_now();
    1380:	88 e1       	ldi	r24, 0x18	; 24
    1382:	99 e0       	ldi	r25, 0x09	; 9
    1384:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <_ZN11USBKeyboard8send_nowEv>
            bluetooth.send_now();
        #endif /* ENABLE_BLUETOOTH */
        #ifdef ENABLE_RX400
            RX400.send_now();
        #endif /* ENABLE_RX400 */
    }
    1388:	1f 91       	pop	r17
    138a:	0f 91       	pop	r16
    138c:	08 95       	ret

0000138e <_Z8keypressi>:
        #ifdef ENABLE_RX400
            RX400.send_now();
        #endif /* ENABLE_RX400 */
    }
    
    void keypress(int code) {
    138e:	ef 92       	push	r14
    1390:	ff 92       	push	r15
    1392:	0f 93       	push	r16
    1394:	1f 93       	push	r17
    1396:	7c 01       	movw	r14, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset keypress ");
    1398:	00 ef       	ldi	r16, 0xF0	; 240
    139a:	18 e0       	ldi	r17, 0x08	; 8
    139c:	c8 01       	movw	r24, r16
    139e:	67 e6       	ldi	r22, 0x67	; 103
    13a0:	72 e0       	ldi	r23, 0x02	; 2
    13a2:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(code);
    13a6:	c8 01       	movw	r24, r16
    13a8:	b7 01       	movw	r22, r14
    13aa:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        keydown(code);
    13ae:	c7 01       	movw	r24, r14
    13b0:	86 df       	rcall	.-244    	; 0x12be <_Z7keydowni>
        delay(5);
    13b2:	65 e0       	ldi	r22, 0x05	; 5
    13b4:	70 e0       	ldi	r23, 0x00	; 0
    13b6:	80 e0       	ldi	r24, 0x00	; 0
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
        keyup(code);
    13be:	c7 01       	movw	r24, r14
    13c0:	17 df       	rcall	.-466    	; 0x11f0 <_Z5keyupi>
    }
    13c2:	1f 91       	pop	r17
    13c4:	0f 91       	pop	r16
    13c6:	ff 90       	pop	r15
    13c8:	ef 90       	pop	r14
    13ca:	08 95       	ret

000013cc <_Z7mouseupi>:
        #ifdef ENABLE_RX400
            RX400.set_buttons((mouseDown & 1) > 0 ? 1 : 0, (mouseDown & 2) > 0 ? 1 : 0, (mouseDown & 4) > 0 ? 1 : 0);
        #endif /* ENABLE_RX400 */
    }
    
    void mouseup(int button) {
    13cc:	cf 93       	push	r28
    13ce:	df 93       	push	r29
    13d0:	ec 01       	movw	r28, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset mouseup ");
    13d2:	80 ef       	ldi	r24, 0xF0	; 240
    13d4:	98 e0       	ldi	r25, 0x08	; 8
    13d6:	6a e7       	ldi	r22, 0x7A	; 122
    13d8:	72 e0       	ldi	r23, 0x02	; 2
    13da:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(button);
    13de:	80 ef       	ldi	r24, 0xF0	; 240
    13e0:	98 e0       	ldi	r25, 0x08	; 8
    13e2:	be 01       	movw	r22, r28
    13e4:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        if ((mouseDown & button) > 0) {
    13e8:	20 91 9d 08 	lds	r18, 0x089D
    13ec:	30 91 9e 08 	lds	r19, 0x089E
    13f0:	ce 01       	movw	r24, r28
    13f2:	82 23       	and	r24, r18
    13f4:	93 23       	and	r25, r19
    13f6:	18 16       	cp	r1, r24
    13f8:	19 06       	cpc	r1, r25
    13fa:	a4 f4       	brge	.+40     	; 0x1424 <_Z7mouseupi+0x58>
            mouseDown -= button;
    13fc:	2c 1b       	sub	r18, r28
    13fe:	3d 0b       	sbc	r19, r29
    1400:	30 93 9e 08 	sts	0x089E, r19
    1404:	20 93 9d 08 	sts	0x089D, r18
            #ifdef ENABLE_USB
                Mouse.set_buttons((mouseDown & 1) > 0 ? 1 : 0, (mouseDown & 2) > 0 ? 1 : 0, (mouseDown & 4) > 0 ? 1 : 0);
    1408:	60 e0       	ldi	r22, 0x00	; 0
    140a:	20 fd       	sbrc	r18, 0
    140c:	61 e0       	ldi	r22, 0x01	; 1
    140e:	36 95       	lsr	r19
    1410:	27 95       	ror	r18
    1412:	42 2f       	mov	r20, r18
    1414:	41 70       	andi	r20, 0x01	; 1
    1416:	36 95       	lsr	r19
    1418:	27 95       	ror	r18
    141a:	21 70       	andi	r18, 0x01	; 1
    141c:	80 e1       	ldi	r24, 0x10	; 16
    141e:	99 e0       	ldi	r25, 0x09	; 9
    1420:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <_ZN8USBMouse11set_buttonsEhhh>
            #endif /* ENABLE_USB */
            #ifdef ENABLE_RX400
                RX400.set_buttons((mouseDown & 1) > 0 ? 1 : 0, (mouseDown & 2) > 0 ? 1 : 0, (mouseDown & 4) > 0 ? 1 : 0);
            #endif /* ENABLE_RX400 */
        }
    }
    1424:	df 91       	pop	r29
    1426:	cf 91       	pop	r28
    1428:	08 95       	ret

0000142a <_Z21check_sensors_releasemmi>:
        check_sensors_touch(sensors1, sensors2, pos + 1);
        return;
    }
}
 
void check_sensors_release(long unsigned int sensors1, long unsigned int sensors2, int pos) {
    142a:	4f 92       	push	r4
    142c:	5f 92       	push	r5
    142e:	6f 92       	push	r6
    1430:	7f 92       	push	r7
    1432:	8f 92       	push	r8
    1434:	9f 92       	push	r9
    1436:	af 92       	push	r10
    1438:	bf 92       	push	r11
    143a:	cf 92       	push	r12
    143c:	df 92       	push	r13
    143e:	ef 92       	push	r14
    1440:	ff 92       	push	r15
    1442:	0f 93       	push	r16
    1444:	1f 93       	push	r17
    1446:	df 93       	push	r29
    1448:	cf 93       	push	r28
    144a:	cd b7       	in	r28, 0x3d	; 61
    144c:	de b7       	in	r29, 0x3e	; 62
    144e:	cc 54       	subi	r28, 0x4C	; 76
    1450:	d0 40       	sbci	r29, 0x00	; 0
    1452:	0f b6       	in	r0, 0x3f	; 63
    1454:	f8 94       	cli
    1456:	de bf       	out	0x3e, r29	; 62
    1458:	0f be       	out	0x3f, r0	; 63
    145a:	cd bf       	out	0x3d, r28	; 61
    145c:	6b 01       	movw	r12, r22
    145e:	7c 01       	movw	r14, r24
    1460:	49 01       	movw	r8, r18
    1462:	5a 01       	movw	r10, r20
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1464:	60 91 b3 08 	lds	r22, 0x08B3
    1468:	70 91 b4 08 	lds	r23, 0x08B4
    146c:	98 01       	movw	r18, r16
    146e:	40 e0       	ldi	r20, 0x00	; 0
    1470:	50 e0       	ldi	r21, 0x00	; 0
    if ((sensors1 & KS1_Y7) == KS1_Y7 && (sensors2 & KS2_Y7) == KS2_Y7) {
    1472:	d7 01       	movw	r26, r14
    1474:	c6 01       	movw	r24, r12
    1476:	82 70       	andi	r24, 0x02	; 2
    1478:	90 70       	andi	r25, 0x00	; 0
    147a:	a0 70       	andi	r26, 0x00	; 0
    147c:	b0 70       	andi	r27, 0x00	; 0
    147e:	89 83       	std	Y+1, r24	; 0x01
    1480:	9a 83       	std	Y+2, r25	; 0x02
    1482:	ab 83       	std	Y+3, r26	; 0x03
    1484:	bc 83       	std	Y+4, r27	; 0x04
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_JY) == KS1_JY && (sensors2 & KS2_JY) == KS2_JY) {
    1486:	d7 01       	movw	r26, r14
    1488:	c6 01       	movw	r24, r12
    148a:	88 70       	andi	r24, 0x08	; 8
    148c:	90 70       	andi	r25, 0x00	; 0
    148e:	a0 70       	andi	r26, 0x00	; 0
    1490:	b0 70       	andi	r27, 0x00	; 0
    1492:	8d 83       	std	Y+5, r24	; 0x05
    1494:	9e 83       	std	Y+6, r25	; 0x06
    1496:	af 83       	std	Y+7, r26	; 0x07
    1498:	b8 87       	std	Y+8, r27	; 0x08
                modifierup(MODIFIERKEY_CTRL);
                modifierup(MODIFIERKEY_ALT);
                return;
             }
        }
    } else if ((sensors1 & KS1_KY) == KS1_KY && (sensors2 & KS2_KY) == KS2_KY) {
    149a:	d7 01       	movw	r26, r14
    149c:	c6 01       	movw	r24, r12
    149e:	80 71       	andi	r24, 0x10	; 16
    14a0:	90 70       	andi	r25, 0x00	; 0
    14a2:	a0 70       	andi	r26, 0x00	; 0
    14a4:	b0 70       	andi	r27, 0x00	; 0
    14a6:	89 87       	std	Y+9, r24	; 0x09
    14a8:	9a 87       	std	Y+10, r25	; 0x0a
    14aa:	ab 87       	std	Y+11, r26	; 0x0b
    14ac:	bc 87       	std	Y+12, r27	; 0x0c
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_LY) == KS1_LY && (sensors2 & KS2_LY) == KS2_LY) {
    14ae:	d7 01       	movw	r26, r14
    14b0:	c6 01       	movw	r24, r12
    14b2:	80 72       	andi	r24, 0x20	; 32
    14b4:	90 70       	andi	r25, 0x00	; 0
    14b6:	a0 70       	andi	r26, 0x00	; 0
    14b8:	b0 70       	andi	r27, 0x00	; 0
    14ba:	8d 87       	std	Y+13, r24	; 0x0d
    14bc:	9e 87       	std	Y+14, r25	; 0x0e
    14be:	af 87       	std	Y+15, r26	; 0x0f
    14c0:	b8 8b       	std	Y+16, r27	; 0x10
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_HY) == KS1_HY && (sensors2 & KS2_HY) == KS2_HY) {
    14c2:	d7 01       	movw	r26, r14
    14c4:	c6 01       	movw	r24, r12
    14c6:	80 74       	andi	r24, 0x40	; 64
    14c8:	90 70       	andi	r25, 0x00	; 0
    14ca:	a0 70       	andi	r26, 0x00	; 0
    14cc:	b0 70       	andi	r27, 0x00	; 0
    14ce:	89 8b       	std	Y+17, r24	; 0x11
    14d0:	9a 8b       	std	Y+18, r25	; 0x12
    14d2:	ab 8b       	std	Y+19, r26	; 0x13
    14d4:	bc 8b       	std	Y+20, r27	; 0x14
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_WY) == KS1_WY && (sensors2 & KS2_WY) == KS2_WY) {
    14d6:	d7 01       	movw	r26, r14
    14d8:	c6 01       	movw	r24, r12
    14da:	80 70       	andi	r24, 0x00	; 0
    14dc:	91 70       	andi	r25, 0x01	; 1
    14de:	a0 70       	andi	r26, 0x00	; 0
    14e0:	b0 70       	andi	r27, 0x00	; 0
    14e2:	8d 8b       	std	Y+21, r24	; 0x15
    14e4:	9e 8b       	std	Y+22, r25	; 0x16
    14e6:	af 8b       	std	Y+23, r26	; 0x17
    14e8:	b8 8f       	std	Y+24, r27	; 0x18
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_XY) == KS1_XY && (sensors2 & KS2_XY) == KS2_XY) {
    14ea:	d7 01       	movw	r26, r14
    14ec:	c6 01       	movw	r24, r12
    14ee:	80 70       	andi	r24, 0x00	; 0
    14f0:	92 70       	andi	r25, 0x02	; 2
    14f2:	a0 70       	andi	r26, 0x00	; 0
    14f4:	b0 70       	andi	r27, 0x00	; 0
    14f6:	89 8f       	std	Y+25, r24	; 0x19
    14f8:	9a 8f       	std	Y+26, r25	; 0x1a
    14fa:	ab 8f       	std	Y+27, r26	; 0x1b
    14fc:	bc 8f       	std	Y+28, r27	; 0x1c
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_Y6) == KS1_Y6 && (sensors2 & KS2_Y6) == KS2_Y6) {
    14fe:	d7 01       	movw	r26, r14
    1500:	c6 01       	movw	r24, r12
    1502:	80 70       	andi	r24, 0x00	; 0
    1504:	98 70       	andi	r25, 0x08	; 8
    1506:	a0 70       	andi	r26, 0x00	; 0
    1508:	b0 70       	andi	r27, 0x00	; 0
    150a:	8d 8f       	std	Y+29, r24	; 0x1d
    150c:	9e 8f       	std	Y+30, r25	; 0x1e
    150e:	af 8f       	std	Y+31, r26	; 0x1f
    1510:	b8 a3       	std	Y+32, r27	; 0x20
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_GY) == KS1_GY && (sensors2 & KS2_GY) == KS2_GY) {
    1512:	d7 01       	movw	r26, r14
    1514:	c6 01       	movw	r24, r12
    1516:	80 70       	andi	r24, 0x00	; 0
    1518:	90 72       	andi	r25, 0x20	; 32
    151a:	a0 70       	andi	r26, 0x00	; 0
    151c:	b0 70       	andi	r27, 0x00	; 0
    151e:	89 a3       	std	Y+33, r24	; 0x21
    1520:	9a a3       	std	Y+34, r25	; 0x22
    1522:	ab a3       	std	Y+35, r26	; 0x23
    1524:	bc a3       	std	Y+36, r27	; 0x24
                modifierup(MODIFIERKEY_CTRL);
                modifierup(MODIFIERKEY_ALT);
                return;
             }
        }
    } else if ((sensors1 & KS1_IY) == KS1_IY && (sensors2 & KS2_IY) == KS2_IY) {
    1526:	d7 01       	movw	r26, r14
    1528:	c6 01       	movw	r24, r12
    152a:	80 70       	andi	r24, 0x00	; 0
    152c:	90 74       	andi	r25, 0x40	; 64
    152e:	a0 70       	andi	r26, 0x00	; 0
    1530:	b0 70       	andi	r27, 0x00	; 0
    1532:	8d a3       	std	Y+37, r24	; 0x25
    1534:	9e a3       	std	Y+38, r25	; 0x26
    1536:	af a3       	std	Y+39, r26	; 0x27
    1538:	b8 a7       	std	Y+40, r27	; 0x28
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_TY) == KS1_TY && (sensors2 & KS2_TY) == KS2_TY) {
    153a:	d7 01       	movw	r26, r14
    153c:	c6 01       	movw	r24, r12
    153e:	80 70       	andi	r24, 0x00	; 0
    1540:	90 70       	andi	r25, 0x00	; 0
    1542:	a1 70       	andi	r26, 0x01	; 1
    1544:	b0 70       	andi	r27, 0x00	; 0
    1546:	89 a7       	std	Y+41, r24	; 0x29
    1548:	9a a7       	std	Y+42, r25	; 0x2a
    154a:	ab a7       	std	Y+43, r26	; 0x2b
    154c:	bc a7       	std	Y+44, r27	; 0x2c
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_UY) == KS1_UY && (sensors2 & KS2_UY) == KS2_UY) {
    154e:	d7 01       	movw	r26, r14
    1550:	c6 01       	movw	r24, r12
    1552:	80 70       	andi	r24, 0x00	; 0
    1554:	90 70       	andi	r25, 0x00	; 0
    1556:	a2 70       	andi	r26, 0x02	; 2
    1558:	b0 70       	andi	r27, 0x00	; 0
    155a:	8d a7       	std	Y+45, r24	; 0x2d
    155c:	9e a7       	std	Y+46, r25	; 0x2e
    155e:	af a7       	std	Y+47, r26	; 0x2f
    1560:	b8 ab       	std	Y+48, r27	; 0x30
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_Y5) == KS1_Y5 && (sensors2 & KS2_Y5) == KS2_Y5 && modeCheck(KMODE_DEFAULT, pos)) {
    1562:	d7 01       	movw	r26, r14
    1564:	c6 01       	movw	r24, r12
    1566:	80 70       	andi	r24, 0x00	; 0
    1568:	90 70       	andi	r25, 0x00	; 0
    156a:	a0 71       	andi	r26, 0x10	; 16
    156c:	b0 70       	andi	r27, 0x00	; 0
    156e:	89 ab       	std	Y+49, r24	; 0x31
    1570:	9a ab       	std	Y+50, r25	; 0x32
    1572:	ab ab       	std	Y+51, r26	; 0x33
    1574:	bc ab       	std	Y+52, r27	; 0x34
        keypress(KEY_V);
        modifierup(MODIFIERKEY_SHIFT);
        modifierup(MODIFIERKEY_CTRL);
        modifierup(MODIFIERKEY_ALT);
        return;
    } else if ((sensors1 & KS1_D8) == KS1_D8 && (sensors2 & KS2_D8) == KS2_D8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    1576:	d7 01       	movw	r26, r14
    1578:	c6 01       	movw	r24, r12
    157a:	80 70       	andi	r24, 0x00	; 0
    157c:	90 70       	andi	r25, 0x00	; 0
    157e:	a0 72       	andi	r26, 0x20	; 32
    1580:	b0 70       	andi	r27, 0x00	; 0
    1582:	8d ab       	std	Y+53, r24	; 0x35
    1584:	9e ab       	std	Y+54, r25	; 0x36
    1586:	af ab       	std	Y+55, r26	; 0x37
    1588:	b8 af       	std	Y+56, r27	; 0x38
        mouseoff(KMOUSE_SCROLL);
        return;
    } else if ((sensors1 & KS1_DY) == KS1_DY && (sensors2 & KS2_DY) == KS2_DY) {
    158a:	d7 01       	movw	r26, r14
    158c:	c6 01       	movw	r24, r12
    158e:	80 70       	andi	r24, 0x00	; 0
    1590:	90 70       	andi	r25, 0x00	; 0
    1592:	a0 74       	andi	r26, 0x40	; 64
    1594:	b0 70       	andi	r27, 0x00	; 0
    1596:	89 af       	std	Y+57, r24	; 0x39
    1598:	9a af       	std	Y+58, r25	; 0x3a
    159a:	ab af       	std	Y+59, r26	; 0x3b
    159c:	bc af       	std	Y+60, r27	; 0x3c
                modifierup(MODIFIERKEY_CTRL);
                modifierup(MODIFIERKEY_ALT);
                return;
             }
        }
    } else if ((sensors1 & KS1_EY) == KS1_EY && (sensors2 & KS2_EY) == KS2_EY) {
    159e:	d7 01       	movw	r26, r14
    15a0:	c6 01       	movw	r24, r12
    15a2:	80 70       	andi	r24, 0x00	; 0
    15a4:	90 70       	andi	r25, 0x00	; 0
    15a6:	a0 78       	andi	r26, 0x80	; 128
    15a8:	b0 70       	andi	r27, 0x00	; 0
    15aa:	21 96       	adiw	r28, 0x01	; 1
    15ac:	8c af       	std	Y+60, r24	; 0x3c
    15ae:	9d af       	std	Y+61, r25	; 0x3d
    15b0:	ae af       	std	Y+62, r26	; 0x3e
    15b2:	bf af       	std	Y+63, r27	; 0x3f
    15b4:	21 97       	sbiw	r28, 0x01	; 1
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_FY) == KS1_FY && (sensors2 & KS2_FY) == KS2_FY) {
    15b6:	d7 01       	movw	r26, r14
    15b8:	c6 01       	movw	r24, r12
    15ba:	80 70       	andi	r24, 0x00	; 0
    15bc:	90 70       	andi	r25, 0x00	; 0
    15be:	a0 70       	andi	r26, 0x00	; 0
    15c0:	b1 70       	andi	r27, 0x01	; 1
    15c2:	25 96       	adiw	r28, 0x05	; 5
    15c4:	8c af       	std	Y+60, r24	; 0x3c
    15c6:	9d af       	std	Y+61, r25	; 0x3d
    15c8:	ae af       	std	Y+62, r26	; 0x3e
    15ca:	bf af       	std	Y+63, r27	; 0x3f
    15cc:	25 97       	sbiw	r28, 0x05	; 5
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_PY) == KS1_PY && (sensors2 & KS2_PY) == KS2_PY) {
    15ce:	d7 01       	movw	r26, r14
    15d0:	c6 01       	movw	r24, r12
    15d2:	80 70       	andi	r24, 0x00	; 0
    15d4:	90 70       	andi	r25, 0x00	; 0
    15d6:	a0 70       	andi	r26, 0x00	; 0
    15d8:	b4 70       	andi	r27, 0x04	; 4
    15da:	29 96       	adiw	r28, 0x09	; 9
    15dc:	8c af       	std	Y+60, r24	; 0x3c
    15de:	9d af       	std	Y+61, r25	; 0x3d
    15e0:	ae af       	std	Y+62, r26	; 0x3e
    15e2:	bf af       	std	Y+63, r27	; 0x3f
    15e4:	29 97       	sbiw	r28, 0x09	; 9
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_QY) == KS1_QY && (sensors2 & KS2_QY) == KS2_QY) {
    15e6:	d7 01       	movw	r26, r14
    15e8:	c6 01       	movw	r24, r12
    15ea:	80 70       	andi	r24, 0x00	; 0
    15ec:	90 70       	andi	r25, 0x00	; 0
    15ee:	a0 70       	andi	r26, 0x00	; 0
    15f0:	b0 71       	andi	r27, 0x10	; 16
    15f2:	2d 96       	adiw	r28, 0x0d	; 13
    15f4:	8c af       	std	Y+60, r24	; 0x3c
    15f6:	9d af       	std	Y+61, r25	; 0x3d
    15f8:	ae af       	std	Y+62, r26	; 0x3e
    15fa:	bf af       	std	Y+63, r27	; 0x3f
    15fc:	2d 97       	sbiw	r28, 0x0d	; 13
            modifierup(MODIFIERKEY_SHIFT);
            modifierup(MODIFIERKEY_CTRL);
            modifierup(MODIFIERKEY_ALT);
            return;
         }
    } else if ((sensors1 & KS1_RY) == KS1_RY && (sensors2 & KS2_RY) == KS2_RY) {
    15fe:	41 2c       	mov	r4, r1
    1600:	51 2c       	mov	r5, r1
    1602:	61 2c       	mov	r6, r1
    1604:	f0 e4       	ldi	r31, 0x40	; 64
    1606:	7f 2e       	mov	r7, r31
    1608:	4c 20       	and	r4, r12
    160a:	5d 20       	and	r5, r13
    160c:	6e 20       	and	r6, r14
    160e:	7f 20       	and	r7, r15
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1610:	8f ef       	ldi	r24, 0xFF	; 255
    1612:	9f e7       	ldi	r25, 0x7F	; 127
    1614:	28 9f       	mul	r18, r24
    1616:	80 01       	movw	r16, r0
    1618:	29 9f       	mul	r18, r25
    161a:	10 0d       	add	r17, r0
    161c:	38 9f       	mul	r19, r24
    161e:	10 0d       	add	r17, r0
    1620:	11 24       	eor	r1, r1
    1622:	06 0f       	add	r16, r22
    1624:	17 1f       	adc	r17, r23
    1626:	00 0f       	add	r16, r16
    1628:	11 1f       	adc	r17, r17
    162a:	01 56       	subi	r16, 0x61	; 97
    162c:	17 4f       	sbci	r17, 0xF7	; 247
        return;
    }
}
 
void check_sensors_release(long unsigned int sensors1, long unsigned int sensors2, int pos) {
    if ((sensors1 & KS1_Y7) == KS1_Y7 && (sensors2 & KS2_Y7) == KS2_Y7) {
    162e:	89 81       	ldd	r24, Y+1	; 0x01
    1630:	9a 81       	ldd	r25, Y+2	; 0x02
    1632:	ab 81       	ldd	r26, Y+3	; 0x03
    1634:	bc 81       	ldd	r27, Y+4	; 0x04
    1636:	00 97       	sbiw	r24, 0x00	; 0
    1638:	a1 05       	cpc	r26, r1
    163a:	b1 05       	cpc	r27, r1
    163c:	99 f1       	breq	.+102    	; 0x16a4 <_Z21check_sensors_releasemmi+0x27a>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    163e:	62 17       	cp	r22, r18
    1640:	73 07       	cpc	r23, r19
    1642:	14 f4       	brge	.+4      	; 0x1648 <_Z21check_sensors_releasemmi+0x21e>
    1644:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1648:	f8 01       	movw	r30, r16
    164a:	e4 0f       	add	r30, r20
    164c:	f5 1f       	adc	r31, r21
    164e:	01 90       	ld	r0, Z+
    1650:	f0 81       	ld	r31, Z
    1652:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1654:	30 97       	sbiw	r30, 0x00	; 0
    1656:	71 f4       	brne	.+28     	; 0x1674 <_Z21check_sensors_releasemmi+0x24a>
            keypress(KEY_PERIOD);
    1658:	87 e3       	ldi	r24, 0x37	; 55
            modifierup(MODIFIERKEY_SHIFT);
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	98 de       	rcall	.-720    	; 0x138e <_Z8keypressi>
    165e:	82 e0       	ldi	r24, 0x02	; 2
    1660:	90 e0       	ldi	r25, 0x00	; 0
    1662:	86 da       	rcall	.-2804   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1664:	84 e0       	ldi	r24, 0x04	; 4
    1666:	90 e0       	ldi	r25, 0x00	; 0
    1668:	83 da       	rcall	.-2810   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	90 e0       	ldi	r25, 0x00	; 0
    166e:	80 da       	rcall	.-2816   	; 0xb70 <_Z10modifierupi>
    1670:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos)) {
    1674:	e1 30       	cpi	r30, 0x01	; 1
    1676:	f1 05       	cpc	r31, r1
    1678:	39 f0       	breq	.+14     	; 0x1688 <_Z21check_sensors_releasemmi+0x25e>
    167a:	e2 30       	cpi	r30, 0x02	; 2
    167c:	f1 05       	cpc	r31, r1
    167e:	21 f0       	breq	.+8      	; 0x1688 <_Z21check_sensors_releasemmi+0x25e>
    1680:	33 97       	sbiw	r30, 0x03	; 3
    1682:	11 f0       	breq	.+4      	; 0x1688 <_Z21check_sensors_releasemmi+0x25e>
    1684:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_ESC);
    1688:	89 e2       	ldi	r24, 0x29	; 41
    168a:	90 e0       	ldi	r25, 0x00	; 0
    168c:	80 de       	rcall	.-768    	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    168e:	82 e0       	ldi	r24, 0x02	; 2
    1690:	90 e0       	ldi	r25, 0x00	; 0
    1692:	6e da       	rcall	.-2852   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1694:	84 e0       	ldi	r24, 0x04	; 4
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	6b da       	rcall	.-2858   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	90 e0       	ldi	r25, 0x00	; 0
    169e:	68 da       	rcall	.-2864   	; 0xb70 <_Z10modifierupi>
    16a0:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_JY) == KS1_JY && (sensors2 & KS2_JY) == KS2_JY) {
    16a4:	8d 81       	ldd	r24, Y+5	; 0x05
    16a6:	9e 81       	ldd	r25, Y+6	; 0x06
    16a8:	af 81       	ldd	r26, Y+7	; 0x07
    16aa:	b8 85       	ldd	r27, Y+8	; 0x08
    16ac:	00 97       	sbiw	r24, 0x00	; 0
    16ae:	a1 05       	cpc	r26, r1
    16b0:	b1 05       	cpc	r27, r1
    16b2:	09 f4       	brne	.+2      	; 0x16b6 <_Z21check_sensors_releasemmi+0x28c>
    16b4:	b2 c0       	rjmp	.+356    	; 0x181a <_Z21check_sensors_releasemmi+0x3f0>
        if ((sensors1 & KS1_GJY) == KS1_GJY && (sensors2 & KS2_GJY) == KS2_GJY) {
    16b6:	d7 01       	movw	r26, r14
    16b8:	c6 01       	movw	r24, r12
    16ba:	88 70       	andi	r24, 0x08	; 8
    16bc:	90 72       	andi	r25, 0x20	; 32
    16be:	a0 70       	andi	r26, 0x00	; 0
    16c0:	b0 70       	andi	r27, 0x00	; 0
    16c2:	88 50       	subi	r24, 0x08	; 8
    16c4:	90 42       	sbci	r25, 0x20	; 32
    16c6:	a0 40       	sbci	r26, 0x00	; 0
    16c8:	b0 40       	sbci	r27, 0x00	; 0
    16ca:	99 f5       	brne	.+102    	; 0x1732 <_Z21check_sensors_releasemmi+0x308>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    16cc:	62 17       	cp	r22, r18
    16ce:	73 07       	cpc	r23, r19
    16d0:	14 f4       	brge	.+4      	; 0x16d6 <_Z21check_sensors_releasemmi+0x2ac>
    16d2:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    16d6:	f8 01       	movw	r30, r16
    16d8:	e4 0f       	add	r30, r20
    16da:	f5 1f       	adc	r31, r21
    16dc:	01 90       	ld	r0, Z+
    16de:	f0 81       	ld	r31, Z
    16e0:	e0 2d       	mov	r30, r0
            if (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos)) {
    16e2:	30 97       	sbiw	r30, 0x00	; 0
    16e4:	31 f0       	breq	.+12     	; 0x16f2 <_Z21check_sensors_releasemmi+0x2c8>
    16e6:	e2 30       	cpi	r30, 0x02	; 2
    16e8:	f1 05       	cpc	r31, r1
    16ea:	19 f0       	breq	.+6      	; 0x16f2 <_Z21check_sensors_releasemmi+0x2c8>
    16ec:	e3 30       	cpi	r30, 0x03	; 3
    16ee:	f1 05       	cpc	r31, r1
    16f0:	71 f4       	brne	.+28     	; 0x170e <_Z21check_sensors_releasemmi+0x2e4>
                keypress(KEY_ENTER);
    16f2:	88 e2       	ldi	r24, 0x28	; 40
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	4b de       	rcall	.-874    	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    16f8:	82 e0       	ldi	r24, 0x02	; 2
    16fa:	90 e0       	ldi	r25, 0x00	; 0
    16fc:	39 da       	rcall	.-2958   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    16fe:	84 e0       	ldi	r24, 0x04	; 4
    1700:	90 e0       	ldi	r25, 0x00	; 0
    1702:	36 da       	rcall	.-2964   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1704:	81 e0       	ldi	r24, 0x01	; 1
    1706:	90 e0       	ldi	r25, 0x00	; 0
    1708:	33 da       	rcall	.-2970   	; 0xb70 <_Z10modifierupi>
    170a:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_NUMBERS, pos)) {
    170e:	31 97       	sbiw	r30, 0x01	; 1
    1710:	11 f0       	breq	.+4      	; 0x1716 <_Z21check_sensors_releasemmi+0x2ec>
    1712:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
                keypress(KEYPAD_ENTER);
    1716:	88 e5       	ldi	r24, 0x58	; 88
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	39 de       	rcall	.-910    	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    171c:	82 e0       	ldi	r24, 0x02	; 2
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	27 da       	rcall	.-2994   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    1722:	84 e0       	ldi	r24, 0x04	; 4
    1724:	90 e0       	ldi	r25, 0x00	; 0
    1726:	24 da       	rcall	.-3000   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1728:	81 e0       	ldi	r24, 0x01	; 1
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	21 da       	rcall	.-3006   	; 0xb70 <_Z10modifierupi>
    172e:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
                return;
             }
        } else if ((sensors1 & KS1_AJY) == KS1_AJY && (sensors2 & KS2_AJY) == KS2_AJY && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    1732:	87 fc       	sbrc	r8, 7
    1734:	02 c0       	rjmp	.+4      	; 0x173a <_Z21check_sensors_releasemmi+0x310>
    1736:	0c 94 fa 15 	jmp	0x2bf4	; 0x2bf4 <__stack+0xaf5>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    173a:	62 17       	cp	r22, r18
    173c:	73 07       	cpc	r23, r19
    173e:	14 f4       	brge	.+4      	; 0x1744 <_Z21check_sensors_releasemmi+0x31a>
    1740:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1744:	f8 01       	movw	r30, r16
    1746:	e4 0f       	add	r30, r20
    1748:	f5 1f       	adc	r31, r21
    174a:	01 90       	ld	r0, Z+
    174c:	f0 81       	ld	r31, Z
    174e:	e0 2d       	mov	r30, r0
    1750:	30 97       	sbiw	r30, 0x00	; 0
    1752:	41 f0       	breq	.+16     	; 0x1764 <_Z21check_sensors_releasemmi+0x33a>
    1754:	e1 30       	cpi	r30, 0x01	; 1
    1756:	f1 05       	cpc	r31, r1
    1758:	29 f0       	breq	.+10     	; 0x1764 <_Z21check_sensors_releasemmi+0x33a>
    175a:	e2 30       	cpi	r30, 0x02	; 2
    175c:	f1 05       	cpc	r31, r1
    175e:	11 f0       	breq	.+4      	; 0x1764 <_Z21check_sensors_releasemmi+0x33a>
    1760:	33 97       	sbiw	r30, 0x03	; 3
    1762:	71 f4       	brne	.+28     	; 0x1780 <_Z21check_sensors_releasemmi+0x356>
            keypress(KEY_TAB);
    1764:	8b e2       	ldi	r24, 0x2B	; 43
    1766:	90 e0       	ldi	r25, 0x00	; 0
    1768:	12 de       	rcall	.-988    	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    176a:	82 e0       	ldi	r24, 0x02	; 2
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	00 da       	rcall	.-3072   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1770:	84 e0       	ldi	r24, 0x04	; 4
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	fd d9       	rcall	.-3078   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1776:	81 e0       	ldi	r24, 0x01	; 1
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	fa d9       	rcall	.-3084   	; 0xb70 <_Z10modifierupi>
    177c:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
    1780:	f8 01       	movw	r30, r16
    1782:	e4 0f       	add	r30, r20
    1784:	f5 1f       	adc	r31, r21
    1786:	01 90       	ld	r0, Z+
    1788:	f0 81       	ld	r31, Z
    178a:	e0 2d       	mov	r30, r0
            return;
        } else {
             if (modeCheck(KMODE_DEFAULT, pos)) {
    178c:	30 97       	sbiw	r30, 0x00	; 0
    178e:	71 f4       	brne	.+28     	; 0x17ac <_Z21check_sensors_releasemmi+0x382>
                keypress(KEY_S);
    1790:	86 e1       	ldi	r24, 0x16	; 22
    1792:	90 e0       	ldi	r25, 0x00	; 0
    1794:	fc dd       	rcall	.-1032   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1796:	82 e0       	ldi	r24, 0x02	; 2
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	ea d9       	rcall	.-3116   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    179c:	84 e0       	ldi	r24, 0x04	; 4
    179e:	90 e0       	ldi	r25, 0x00	; 0
    17a0:	e7 d9       	rcall	.-3122   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	e4 d9       	rcall	.-3128   	; 0xb70 <_Z10modifierupi>
    17a8:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_NUMBERS, pos)) {
    17ac:	e1 30       	cpi	r30, 0x01	; 1
    17ae:	f1 05       	cpc	r31, r1
    17b0:	89 f4       	brne	.+34     	; 0x17d4 <_Z21check_sensors_releasemmi+0x3aa>
                modifierdown(MODIFIERKEY_SHIFT);
    17b2:	82 e0       	ldi	r24, 0x02	; 2
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	0b da       	rcall	.-3050   	; 0xbce <_Z12modifierdowni>
                keypress(KEY_3);
    17b8:	80 e2       	ldi	r24, 0x20	; 32
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	e8 dd       	rcall	.-1072   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    17be:	82 e0       	ldi	r24, 0x02	; 2
    17c0:	90 e0       	ldi	r25, 0x00	; 0
    17c2:	d6 d9       	rcall	.-3156   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    17c4:	84 e0       	ldi	r24, 0x04	; 4
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	d3 d9       	rcall	.-3162   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	d0 d9       	rcall	.-3168   	; 0xb70 <_Z10modifierupi>
    17d0:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    17d4:	e2 30       	cpi	r30, 0x02	; 2
    17d6:	f1 05       	cpc	r31, r1
    17d8:	71 f4       	brne	.+28     	; 0x17f6 <_Z21check_sensors_releasemmi+0x3cc>
                keypress(KEY_SEMICOLON);
    17da:	83 e3       	ldi	r24, 0x33	; 51
    17dc:	90 e0       	ldi	r25, 0x00	; 0
    17de:	d7 dd       	rcall	.-1106   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    17e0:	82 e0       	ldi	r24, 0x02	; 2
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	c5 d9       	rcall	.-3190   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    17e6:	84 e0       	ldi	r24, 0x04	; 4
    17e8:	90 e0       	ldi	r25, 0x00	; 0
    17ea:	c2 d9       	rcall	.-3196   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    17ec:	81 e0       	ldi	r24, 0x01	; 1
    17ee:	90 e0       	ldi	r25, 0x00	; 0
    17f0:	bf d9       	rcall	.-3202   	; 0xb70 <_Z10modifierupi>
                return;
             } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    17f2:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
    17f6:	33 97       	sbiw	r30, 0x03	; 3
    17f8:	11 f0       	breq	.+4      	; 0x17fe <_Z21check_sensors_releasemmi+0x3d4>
    17fa:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
                keypress(KEY_F10);
    17fe:	83 e4       	ldi	r24, 0x43	; 67
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	c5 dd       	rcall	.-1142   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1804:	82 e0       	ldi	r24, 0x02	; 2
    1806:	90 e0       	ldi	r25, 0x00	; 0
    1808:	b3 d9       	rcall	.-3226   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    180a:	84 e0       	ldi	r24, 0x04	; 4
    180c:	90 e0       	ldi	r25, 0x00	; 0
    180e:	b0 d9       	rcall	.-3232   	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1810:	81 e0       	ldi	r24, 0x01	; 1
    1812:	90 e0       	ldi	r25, 0x00	; 0
    1814:	ad d9       	rcall	.-3238   	; 0xb70 <_Z10modifierupi>
    1816:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
                return;
             }
        }
    } else if ((sensors1 & KS1_KY) == KS1_KY && (sensors2 & KS2_KY) == KS2_KY) {
    181a:	89 85       	ldd	r24, Y+9	; 0x09
    181c:	9a 85       	ldd	r25, Y+10	; 0x0a
    181e:	ab 85       	ldd	r26, Y+11	; 0x0b
    1820:	bc 85       	ldd	r27, Y+12	; 0x0c
    1822:	00 97       	sbiw	r24, 0x00	; 0
    1824:	a1 05       	cpc	r26, r1
    1826:	b1 05       	cpc	r27, r1
    1828:	09 f4       	brne	.+2      	; 0x182c <_Z21check_sensors_releasemmi+0x402>
    182a:	52 c0       	rjmp	.+164    	; 0x18d0 <_Z21check_sensors_releasemmi+0x4a6>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    182c:	62 17       	cp	r22, r18
    182e:	73 07       	cpc	r23, r19
    1830:	14 f4       	brge	.+4      	; 0x1836 <_Z21check_sensors_releasemmi+0x40c>
    1832:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1836:	f8 01       	movw	r30, r16
    1838:	e4 0f       	add	r30, r20
    183a:	f5 1f       	adc	r31, r21
    183c:	01 90       	ld	r0, Z+
    183e:	f0 81       	ld	r31, Z
    1840:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1842:	30 97       	sbiw	r30, 0x00	; 0
    1844:	71 f4       	brne	.+28     	; 0x1862 <_Z21check_sensors_releasemmi+0x438>
            keypress(KEY_C);
    1846:	86 e0       	ldi	r24, 0x06	; 6
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	a1 dd       	rcall	.-1214   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    184c:	82 e0       	ldi	r24, 0x02	; 2
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	8f d9       	rcall	.-3298   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1852:	84 e0       	ldi	r24, 0x04	; 4
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	8c d9       	rcall	.-3304   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1858:	81 e0       	ldi	r24, 0x01	; 1
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	89 d9       	rcall	.-3310   	; 0xb70 <_Z10modifierupi>
    185e:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1862:	e1 30       	cpi	r30, 0x01	; 1
    1864:	f1 05       	cpc	r31, r1
    1866:	71 f4       	brne	.+28     	; 0x1884 <_Z21check_sensors_releasemmi+0x45a>
            keypress(KEY_0);
    1868:	87 e2       	ldi	r24, 0x27	; 39
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	90 dd       	rcall	.-1248   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    186e:	82 e0       	ldi	r24, 0x02	; 2
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	7e d9       	rcall	.-3332   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1874:	84 e0       	ldi	r24, 0x04	; 4
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	7b d9       	rcall	.-3338   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	90 e0       	ldi	r25, 0x00	; 0
    187e:	78 d9       	rcall	.-3344   	; 0xb70 <_Z10modifierupi>
    1880:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1884:	e2 30       	cpi	r30, 0x02	; 2
    1886:	f1 05       	cpc	r31, r1
    1888:	89 f4       	brne	.+34     	; 0x18ac <_Z21check_sensors_releasemmi+0x482>
            modifierdown(MODIFIERKEY_SHIFT);
    188a:	82 e0       	ldi	r24, 0x02	; 2
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	9f d9       	rcall	.-3266   	; 0xbce <_Z12modifierdowni>
            keypress(KEY_SEMICOLON);
    1890:	83 e3       	ldi	r24, 0x33	; 51
    1892:	90 e0       	ldi	r25, 0x00	; 0
    1894:	7c dd       	rcall	.-1288   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1896:	82 e0       	ldi	r24, 0x02	; 2
    1898:	90 e0       	ldi	r25, 0x00	; 0
    189a:	6a d9       	rcall	.-3372   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    189c:	84 e0       	ldi	r24, 0x04	; 4
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	67 d9       	rcall	.-3378   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	90 e0       	ldi	r25, 0x00	; 0
    18a6:	64 d9       	rcall	.-3384   	; 0xb70 <_Z10modifierupi>
    18a8:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    18ac:	33 97       	sbiw	r30, 0x03	; 3
    18ae:	11 f0       	breq	.+4      	; 0x18b4 <_Z21check_sensors_releasemmi+0x48a>
    18b0:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F11);
    18b4:	84 e4       	ldi	r24, 0x44	; 68
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	6a dd       	rcall	.-1324   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    18ba:	82 e0       	ldi	r24, 0x02	; 2
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	58 d9       	rcall	.-3408   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    18c0:	84 e0       	ldi	r24, 0x04	; 4
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	55 d9       	rcall	.-3414   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	90 e0       	ldi	r25, 0x00	; 0
    18ca:	52 d9       	rcall	.-3420   	; 0xb70 <_Z10modifierupi>
    18cc:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_LY) == KS1_LY && (sensors2 & KS2_LY) == KS2_LY) {
    18d0:	8d 85       	ldd	r24, Y+13	; 0x0d
    18d2:	9e 85       	ldd	r25, Y+14	; 0x0e
    18d4:	af 85       	ldd	r26, Y+15	; 0x0f
    18d6:	b8 89       	ldd	r27, Y+16	; 0x10
    18d8:	00 97       	sbiw	r24, 0x00	; 0
    18da:	a1 05       	cpc	r26, r1
    18dc:	b1 05       	cpc	r27, r1
    18de:	09 f4       	brne	.+2      	; 0x18e2 <_Z21check_sensors_releasemmi+0x4b8>
    18e0:	55 c0       	rjmp	.+170    	; 0x198c <_Z21check_sensors_releasemmi+0x562>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    18e2:	62 17       	cp	r22, r18
    18e4:	73 07       	cpc	r23, r19
    18e6:	14 f4       	brge	.+4      	; 0x18ec <_Z21check_sensors_releasemmi+0x4c2>
    18e8:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    18ec:	f8 01       	movw	r30, r16
    18ee:	e4 0f       	add	r30, r20
    18f0:	f5 1f       	adc	r31, r21
    18f2:	01 90       	ld	r0, Z+
    18f4:	f0 81       	ld	r31, Z
    18f6:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    18f8:	30 97       	sbiw	r30, 0x00	; 0
    18fa:	71 f4       	brne	.+28     	; 0x1918 <_Z21check_sensors_releasemmi+0x4ee>
            keypress(KEY_P);
    18fc:	83 e1       	ldi	r24, 0x13	; 19
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	46 dd       	rcall	.-1396   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1902:	82 e0       	ldi	r24, 0x02	; 2
    1904:	90 e0       	ldi	r25, 0x00	; 0
    1906:	34 d9       	rcall	.-3480   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1908:	84 e0       	ldi	r24, 0x04	; 4
    190a:	90 e0       	ldi	r25, 0x00	; 0
    190c:	31 d9       	rcall	.-3486   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    190e:	81 e0       	ldi	r24, 0x01	; 1
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	2e d9       	rcall	.-3492   	; 0xb70 <_Z10modifierupi>
    1914:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1918:	e1 30       	cpi	r30, 0x01	; 1
    191a:	f1 05       	cpc	r31, r1
    191c:	89 f4       	brne	.+34     	; 0x1940 <_Z21check_sensors_releasemmi+0x516>
            modifierdown(MODIFIERKEY_SHIFT);
    191e:	82 e0       	ldi	r24, 0x02	; 2
    1920:	90 e0       	ldi	r25, 0x00	; 0
    1922:	55 d9       	rcall	.-3414   	; 0xbce <_Z12modifierdowni>
            keypress(KEY_8);
    1924:	85 e2       	ldi	r24, 0x25	; 37
    1926:	90 e0       	ldi	r25, 0x00	; 0
    1928:	32 dd       	rcall	.-1436   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    192a:	82 e0       	ldi	r24, 0x02	; 2
    192c:	90 e0       	ldi	r25, 0x00	; 0
    192e:	20 d9       	rcall	.-3520   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1930:	84 e0       	ldi	r24, 0x04	; 4
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	1d d9       	rcall	.-3526   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1936:	81 e0       	ldi	r24, 0x01	; 1
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	1a d9       	rcall	.-3532   	; 0xb70 <_Z10modifierupi>
    193c:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1940:	e2 30       	cpi	r30, 0x02	; 2
    1942:	f1 05       	cpc	r31, r1
    1944:	89 f4       	brne	.+34     	; 0x1968 <_Z21check_sensors_releasemmi+0x53e>
            modifierdown(MODIFIERKEY_SHIFT);
    1946:	82 e0       	ldi	r24, 0x02	; 2
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	41 d9       	rcall	.-3454   	; 0xbce <_Z12modifierdowni>
            keypress(KEY_TILDE);
    194c:	85 e3       	ldi	r24, 0x35	; 53
    194e:	90 e0       	ldi	r25, 0x00	; 0
    1950:	1e dd       	rcall	.-1476   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1952:	82 e0       	ldi	r24, 0x02	; 2
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	0c d9       	rcall	.-3560   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1958:	84 e0       	ldi	r24, 0x04	; 4
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	09 d9       	rcall	.-3566   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    195e:	81 e0       	ldi	r24, 0x01	; 1
    1960:	90 e0       	ldi	r25, 0x00	; 0
    1962:	06 d9       	rcall	.-3572   	; 0xb70 <_Z10modifierupi>
    1964:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    1968:	33 97       	sbiw	r30, 0x03	; 3
    196a:	11 f0       	breq	.+4      	; 0x1970 <_Z21check_sensors_releasemmi+0x546>
    196c:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F12);
    1970:	85 e4       	ldi	r24, 0x45	; 69
    1972:	90 e0       	ldi	r25, 0x00	; 0
    1974:	0c dd       	rcall	.-1512   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1976:	82 e0       	ldi	r24, 0x02	; 2
    1978:	90 e0       	ldi	r25, 0x00	; 0
    197a:	fa d8       	rcall	.-3596   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    197c:	84 e0       	ldi	r24, 0x04	; 4
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	f7 d8       	rcall	.-3602   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1982:	81 e0       	ldi	r24, 0x01	; 1
    1984:	90 e0       	ldi	r25, 0x00	; 0
    1986:	f4 d8       	rcall	.-3608   	; 0xb70 <_Z10modifierupi>
    1988:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_HY) == KS1_HY && (sensors2 & KS2_HY) == KS2_HY) {
    198c:	89 89       	ldd	r24, Y+17	; 0x11
    198e:	9a 89       	ldd	r25, Y+18	; 0x12
    1990:	ab 89       	ldd	r26, Y+19	; 0x13
    1992:	bc 89       	ldd	r27, Y+20	; 0x14
    1994:	00 97       	sbiw	r24, 0x00	; 0
    1996:	a1 05       	cpc	r26, r1
    1998:	b1 05       	cpc	r27, r1
    199a:	09 f4       	brne	.+2      	; 0x199e <_Z21check_sensors_releasemmi+0x574>
    199c:	52 c0       	rjmp	.+164    	; 0x1a42 <_Z21check_sensors_releasemmi+0x618>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    199e:	62 17       	cp	r22, r18
    19a0:	73 07       	cpc	r23, r19
    19a2:	14 f4       	brge	.+4      	; 0x19a8 <_Z21check_sensors_releasemmi+0x57e>
    19a4:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    19a8:	f8 01       	movw	r30, r16
    19aa:	e4 0f       	add	r30, r20
    19ac:	f5 1f       	adc	r31, r21
    19ae:	01 90       	ld	r0, Z+
    19b0:	f0 81       	ld	r31, Z
    19b2:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    19b4:	30 97       	sbiw	r30, 0x00	; 0
    19b6:	71 f4       	brne	.+28     	; 0x19d4 <_Z21check_sensors_releasemmi+0x5aa>
            keypress(KEY_L);
    19b8:	8f e0       	ldi	r24, 0x0F	; 15
    19ba:	90 e0       	ldi	r25, 0x00	; 0
    19bc:	e8 dc       	rcall	.-1584   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    19be:	82 e0       	ldi	r24, 0x02	; 2
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	d6 d8       	rcall	.-3668   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    19c4:	84 e0       	ldi	r24, 0x04	; 4
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	d3 d8       	rcall	.-3674   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    19ca:	81 e0       	ldi	r24, 0x01	; 1
    19cc:	90 e0       	ldi	r25, 0x00	; 0
    19ce:	d0 d8       	rcall	.-3680   	; 0xb70 <_Z10modifierupi>
    19d0:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    19d4:	e1 30       	cpi	r30, 0x01	; 1
    19d6:	f1 05       	cpc	r31, r1
    19d8:	71 f4       	brne	.+28     	; 0x19f6 <_Z21check_sensors_releasemmi+0x5cc>
            keypress(KEY_8);
    19da:	85 e2       	ldi	r24, 0x25	; 37
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	d7 dc       	rcall	.-1618   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    19e0:	82 e0       	ldi	r24, 0x02	; 2
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	c5 d8       	rcall	.-3702   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    19e6:	84 e0       	ldi	r24, 0x04	; 4
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	c2 d8       	rcall	.-3708   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    19ec:	81 e0       	ldi	r24, 0x01	; 1
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	bf d8       	rcall	.-3714   	; 0xb70 <_Z10modifierupi>
    19f2:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    19f6:	e2 30       	cpi	r30, 0x02	; 2
    19f8:	f1 05       	cpc	r31, r1
    19fa:	89 f4       	brne	.+34     	; 0x1a1e <_Z21check_sensors_releasemmi+0x5f4>
            modifierdown(MODIFIERKEY_SHIFT);
    19fc:	82 e0       	ldi	r24, 0x02	; 2
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	e6 d8       	rcall	.-3636   	; 0xbce <_Z12modifierdowni>
            keypress(KEY_PERIOD);
    1a02:	87 e3       	ldi	r24, 0x37	; 55
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	c3 dc       	rcall	.-1658   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1a08:	82 e0       	ldi	r24, 0x02	; 2
    1a0a:	90 e0       	ldi	r25, 0x00	; 0
    1a0c:	b1 d8       	rcall	.-3742   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1a0e:	84 e0       	ldi	r24, 0x04	; 4
    1a10:	90 e0       	ldi	r25, 0x00	; 0
    1a12:	ae d8       	rcall	.-3748   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	90 e0       	ldi	r25, 0x00	; 0
    1a18:	ab d8       	rcall	.-3754   	; 0xb70 <_Z10modifierupi>
    1a1a:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    1a1e:	33 97       	sbiw	r30, 0x03	; 3
    1a20:	11 f0       	breq	.+4      	; 0x1a26 <_Z21check_sensors_releasemmi+0x5fc>
    1a22:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F8);
    1a26:	81 e4       	ldi	r24, 0x41	; 65
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	b1 dc       	rcall	.-1694   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1a2c:	82 e0       	ldi	r24, 0x02	; 2
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	9f d8       	rcall	.-3778   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1a32:	84 e0       	ldi	r24, 0x04	; 4
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	9c d8       	rcall	.-3784   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	90 e0       	ldi	r25, 0x00	; 0
    1a3c:	99 d8       	rcall	.-3790   	; 0xb70 <_Z10modifierupi>
    1a3e:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_VY) == KS1_VY && (sensors2 & KS2_VY) == KS2_VY) {
    1a42:	c7 fe       	sbrs	r12, 7
    1a44:	3e c0       	rjmp	.+124    	; 0x1ac2 <_Z21check_sensors_releasemmi+0x698>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1a46:	62 17       	cp	r22, r18
    1a48:	73 07       	cpc	r23, r19
    1a4a:	14 f4       	brge	.+4      	; 0x1a50 <_Z21check_sensors_releasemmi+0x626>
    1a4c:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1a50:	f8 01       	movw	r30, r16
    1a52:	e4 0f       	add	r30, r20
    1a54:	f5 1f       	adc	r31, r21
    1a56:	01 90       	ld	r0, Z+
    1a58:	f0 81       	ld	r31, Z
    1a5a:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1a5c:	30 97       	sbiw	r30, 0x00	; 0
    1a5e:	71 f4       	brne	.+28     	; 0x1a7c <_Z21check_sensors_releasemmi+0x652>
            keypress(KEY_Q);
    1a60:	84 e1       	ldi	r24, 0x14	; 20
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	94 dc       	rcall	.-1752   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1a66:	82 e0       	ldi	r24, 0x02	; 2
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	82 d8       	rcall	.-3836   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1a6c:	84 e0       	ldi	r24, 0x04	; 4
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	7f d8       	rcall	.-3842   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1a72:	81 e0       	ldi	r24, 0x01	; 1
    1a74:	90 e0       	ldi	r25, 0x00	; 0
    1a76:	7c d8       	rcall	.-3848   	; 0xb70 <_Z10modifierupi>
    1a78:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1a7c:	e1 30       	cpi	r30, 0x01	; 1
    1a7e:	f1 05       	cpc	r31, r1
    1a80:	71 f4       	brne	.+28     	; 0x1a9e <_Z21check_sensors_releasemmi+0x674>
            keypress(KEYPAD_PERIOD);
    1a82:	83 e6       	ldi	r24, 0x63	; 99
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	83 dc       	rcall	.-1786   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1a88:	82 e0       	ldi	r24, 0x02	; 2
    1a8a:	90 e0       	ldi	r25, 0x00	; 0
    1a8c:	71 d8       	rcall	.-3870   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1a8e:	84 e0       	ldi	r24, 0x04	; 4
    1a90:	90 e0       	ldi	r25, 0x00	; 0
    1a92:	6e d8       	rcall	.-3876   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1a94:	81 e0       	ldi	r24, 0x01	; 1
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	6b d8       	rcall	.-3882   	; 0xb70 <_Z10modifierupi>
    1a9a:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1a9e:	32 97       	sbiw	r30, 0x02	; 2
    1aa0:	11 f0       	breq	.+4      	; 0x1aa6 <_Z21check_sensors_releasemmi+0x67c>
    1aa2:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_TILDE);
    1aa6:	85 e3       	ldi	r24, 0x35	; 53
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
    1aaa:	71 dc       	rcall	.-1822   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1aac:	82 e0       	ldi	r24, 0x02	; 2
    1aae:	90 e0       	ldi	r25, 0x00	; 0
    1ab0:	5f d8       	rcall	.-3906   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1ab2:	84 e0       	ldi	r24, 0x04	; 4
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	5c d8       	rcall	.-3912   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	59 d8       	rcall	.-3918   	; 0xb70 <_Z10modifierupi>
    1abe:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_WY) == KS1_WY && (sensors2 & KS2_WY) == KS2_WY) {
    1ac2:	8d 89       	ldd	r24, Y+21	; 0x15
    1ac4:	9e 89       	ldd	r25, Y+22	; 0x16
    1ac6:	af 89       	ldd	r26, Y+23	; 0x17
    1ac8:	b8 8d       	ldd	r27, Y+24	; 0x18
    1aca:	00 97       	sbiw	r24, 0x00	; 0
    1acc:	a1 05       	cpc	r26, r1
    1ace:	b1 05       	cpc	r27, r1
    1ad0:	09 f4       	brne	.+2      	; 0x1ad4 <_Z21check_sensors_releasemmi+0x6aa>
    1ad2:	41 c0       	rjmp	.+130    	; 0x1b56 <_Z21check_sensors_releasemmi+0x72c>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1ad4:	62 17       	cp	r22, r18
    1ad6:	73 07       	cpc	r23, r19
    1ad8:	14 f4       	brge	.+4      	; 0x1ade <_Z21check_sensors_releasemmi+0x6b4>
    1ada:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1ade:	f8 01       	movw	r30, r16
    1ae0:	e4 0f       	add	r30, r20
    1ae2:	f5 1f       	adc	r31, r21
    1ae4:	01 90       	ld	r0, Z+
    1ae6:	f0 81       	ld	r31, Z
    1ae8:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1aea:	30 97       	sbiw	r30, 0x00	; 0
    1aec:	71 f4       	brne	.+28     	; 0x1b0a <_Z21check_sensors_releasemmi+0x6e0>
            keypress(KEY_Y);
    1aee:	8c e1       	ldi	r24, 0x1C	; 28
    1af0:	90 e0       	ldi	r25, 0x00	; 0
    1af2:	4d dc       	rcall	.-1894   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1af4:	82 e0       	ldi	r24, 0x02	; 2
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	3b d8       	rcall	.-3978   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1afa:	84 e0       	ldi	r24, 0x04	; 4
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	38 d8       	rcall	.-3984   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1b00:	81 e0       	ldi	r24, 0x01	; 1
    1b02:	90 e0       	ldi	r25, 0x00	; 0
    1b04:	35 d8       	rcall	.-3990   	; 0xb70 <_Z10modifierupi>
    1b06:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1b0a:	e2 30       	cpi	r30, 0x02	; 2
    1b0c:	f1 05       	cpc	r31, r1
    1b0e:	89 f4       	brne	.+34     	; 0x1b32 <_Z21check_sensors_releasemmi+0x708>
            modifierdown(MODIFIERKEY_SHIFT);
    1b10:	82 e0       	ldi	r24, 0x02	; 2
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	5c d8       	rcall	.-3912   	; 0xbce <_Z12modifierdowni>
            keypress(KEY_MINUS);
    1b16:	8d e2       	ldi	r24, 0x2D	; 45
    1b18:	90 e0       	ldi	r25, 0x00	; 0
    1b1a:	39 dc       	rcall	.-1934   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1b1c:	82 e0       	ldi	r24, 0x02	; 2
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
    1b20:	27 d8       	rcall	.-4018   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1b22:	84 e0       	ldi	r24, 0x04	; 4
    1b24:	90 e0       	ldi	r25, 0x00	; 0
    1b26:	24 d8       	rcall	.-4024   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	90 e0       	ldi	r25, 0x00	; 0
    1b2c:	21 d8       	rcall	.-4030   	; 0xb70 <_Z10modifierupi>
    1b2e:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    1b32:	33 97       	sbiw	r30, 0x03	; 3
    1b34:	11 f0       	breq	.+4      	; 0x1b3a <_Z21check_sensors_releasemmi+0x710>
    1b36:	0c 94 e4 15 	jmp	0x2bc8	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_INSERT);
    1b3a:	89 e4       	ldi	r24, 0x49	; 73
    1b3c:	90 e0       	ldi	r25, 0x00	; 0
    1b3e:	27 dc       	rcall	.-1970   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1b40:	82 e0       	ldi	r24, 0x02	; 2
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	15 d8       	rcall	.-4054   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1b46:	84 e0       	ldi	r24, 0x04	; 4
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	12 d8       	rcall	.-4060   	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1b4c:	81 e0       	ldi	r24, 0x01	; 1
    1b4e:	90 e0       	ldi	r25, 0x00	; 0
    1b50:	0f d8       	rcall	.-4066   	; 0xb70 <_Z10modifierupi>
    1b52:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_XY) == KS1_XY && (sensors2 & KS2_XY) == KS2_XY) {
    1b56:	89 8d       	ldd	r24, Y+25	; 0x19
    1b58:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b5a:	ab 8d       	ldd	r26, Y+27	; 0x1b
    1b5c:	bc 8d       	ldd	r27, Y+28	; 0x1c
    1b5e:	00 97       	sbiw	r24, 0x00	; 0
    1b60:	a1 05       	cpc	r26, r1
    1b62:	b1 05       	cpc	r27, r1
    1b64:	09 f4       	brne	.+2      	; 0x1b68 <_Z21check_sensors_releasemmi+0x73e>
    1b66:	49 c0       	rjmp	.+146    	; 0x1bfa <_Z21check_sensors_releasemmi+0x7d0>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1b68:	62 17       	cp	r22, r18
    1b6a:	73 07       	cpc	r23, r19
    1b6c:	14 f4       	brge	.+4      	; 0x1b72 <_Z21check_sensors_releasemmi+0x748>
    1b6e:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1b72:	f8 01       	movw	r30, r16
    1b74:	e4 0f       	add	r30, r20
    1b76:	f5 1f       	adc	r31, r21
    1b78:	01 90       	ld	r0, Z+
    1b7a:	f0 81       	ld	r31, Z
    1b7c:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1b7e:	30 97       	sbiw	r30, 0x00	; 0
    1b80:	89 f4       	brne	.+34     	; 0x1ba4 <_Z21check_sensors_releasemmi+0x77a>
            keypress(KEY_X);
    1b82:	8b e1       	ldi	r24, 0x1B	; 27
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	03 dc       	rcall	.-2042   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1b88:	82 e0       	ldi	r24, 0x02	; 2
    1b8a:	90 e0       	ldi	r25, 0x00	; 0
    1b8c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1b90:	84 e0       	ldi	r24, 0x04	; 4
    1b92:	90 e0       	ldi	r25, 0x00	; 0
    1b94:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	90 e0       	ldi	r25, 0x00	; 0
    1b9c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1ba0:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1ba4:	e2 30       	cpi	r30, 0x02	; 2
    1ba6:	f1 05       	cpc	r31, r1
    1ba8:	a1 f4       	brne	.+40     	; 0x1bd2 <_Z21check_sensors_releasemmi+0x7a8>
            modifierdown(MODIFIERKEY_SHIFT);
    1baa:	82 e0       	ldi	r24, 0x02	; 2
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	0f d8       	rcall	.-4066   	; 0xbce <_Z12modifierdowni>
            keypress(KEY_BACKSLASH);
    1bb0:	81 e3       	ldi	r24, 0x31	; 49
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	ec db       	rcall	.-2088   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1bb6:	82 e0       	ldi	r24, 0x02	; 2
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1bbe:	84 e0       	ldi	r24, 0x04	; 4
    1bc0:	90 e0       	ldi	r25, 0x00	; 0
    1bc2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1bc6:	81 e0       	ldi	r24, 0x01	; 1
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1bce:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    1bd2:	33 97       	sbiw	r30, 0x03	; 3
    1bd4:	09 f0       	breq	.+2      	; 0x1bd8 <_Z21check_sensors_releasemmi+0x7ae>
    1bd6:	f8 c7       	rjmp	.+4080   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_PRINTSCREEN);
    1bd8:	86 e4       	ldi	r24, 0x46	; 70
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	d8 db       	rcall	.-2128   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1bde:	82 e0       	ldi	r24, 0x02	; 2
    1be0:	90 e0       	ldi	r25, 0x00	; 0
    1be2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1be6:	84 e0       	ldi	r24, 0x04	; 4
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	90 e0       	ldi	r25, 0x00	; 0
    1bf2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1bf6:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_Y6) == KS1_Y6 && (sensors2 & KS2_Y6) == KS2_Y6) {
    1bfa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1bfc:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1bfe:	af 8d       	ldd	r26, Y+31	; 0x1f
    1c00:	b8 a1       	ldd	r27, Y+32	; 0x20
    1c02:	00 97       	sbiw	r24, 0x00	; 0
    1c04:	a1 05       	cpc	r26, r1
    1c06:	b1 05       	cpc	r27, r1
    1c08:	b9 f1       	breq	.+110    	; 0x1c78 <_Z21check_sensors_releasemmi+0x84e>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1c0a:	62 17       	cp	r22, r18
    1c0c:	73 07       	cpc	r23, r19
    1c0e:	14 f4       	brge	.+4      	; 0x1c14 <_Z21check_sensors_releasemmi+0x7ea>
    1c10:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1c14:	f8 01       	movw	r30, r16
    1c16:	e4 0f       	add	r30, r20
    1c18:	f5 1f       	adc	r31, r21
    1c1a:	01 90       	ld	r0, Z+
    1c1c:	f0 81       	ld	r31, Z
    1c1e:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1c20:	30 97       	sbiw	r30, 0x00	; 0
    1c22:	89 f4       	brne	.+34     	; 0x1c46 <_Z21check_sensors_releasemmi+0x81c>
            keypress(KEY_COMMA);
    1c24:	86 e3       	ldi	r24, 0x36	; 54
    1c26:	90 e0       	ldi	r25, 0x00	; 0
    1c28:	b2 db       	rcall	.-2204   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1c2a:	82 e0       	ldi	r24, 0x02	; 2
    1c2c:	90 e0       	ldi	r25, 0x00	; 0
    1c2e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1c32:	84 e0       	ldi	r24, 0x04	; 4
    1c34:	90 e0       	ldi	r25, 0x00	; 0
    1c36:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1c3a:	81 e0       	ldi	r24, 0x01	; 1
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1c42:	0c 94 23 16 	jmp	0x2c46	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos)) {
    1c46:	e1 30       	cpi	r30, 0x01	; 1
    1c48:	f1 05       	cpc	r31, r1
    1c4a:	31 f0       	breq	.+12     	; 0x1c58 <_Z21check_sensors_releasemmi+0x82e>
    1c4c:	e2 30       	cpi	r30, 0x02	; 2
    1c4e:	f1 05       	cpc	r31, r1
    1c50:	19 f0       	breq	.+6      	; 0x1c58 <_Z21check_sensors_releasemmi+0x82e>
    1c52:	33 97       	sbiw	r30, 0x03	; 3
    1c54:	09 f0       	breq	.+2      	; 0x1c58 <_Z21check_sensors_releasemmi+0x82e>
    1c56:	b8 c7       	rjmp	.+3952   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_DELETE);
    1c58:	8c e4       	ldi	r24, 0x4C	; 76
    1c5a:	90 e0       	ldi	r25, 0x00	; 0
    1c5c:	98 db       	rcall	.-2256   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1c5e:	82 e0       	ldi	r24, 0x02	; 2
    1c60:	90 e0       	ldi	r25, 0x00	; 0
    1c62:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1c66:	84 e0       	ldi	r24, 0x04	; 4
    1c68:	90 e0       	ldi	r25, 0x00	; 0
    1c6a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1c76:	e7 c7       	rjmp	.+4046   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_GY) == KS1_GY && (sensors2 & KS2_GY) == KS2_GY) {
    1c78:	89 a1       	ldd	r24, Y+33	; 0x21
    1c7a:	9a a1       	ldd	r25, Y+34	; 0x22
    1c7c:	ab a1       	ldd	r26, Y+35	; 0x23
    1c7e:	bc a1       	ldd	r27, Y+36	; 0x24
    1c80:	00 97       	sbiw	r24, 0x00	; 0
    1c82:	a1 05       	cpc	r26, r1
    1c84:	b1 05       	cpc	r27, r1
    1c86:	09 f4       	brne	.+2      	; 0x1c8a <_Z21check_sensors_releasemmi+0x860>
    1c88:	99 c0       	rjmp	.+306    	; 0x1dbc <_Z21check_sensors_releasemmi+0x992>
        if ((sensors1 & KS1_DGY) == KS1_DGY && (sensors2 & KS2_DGY) == KS2_DGY) {
    1c8a:	d7 01       	movw	r26, r14
    1c8c:	c6 01       	movw	r24, r12
    1c8e:	80 70       	andi	r24, 0x00	; 0
    1c90:	90 72       	andi	r25, 0x20	; 32
    1c92:	a0 74       	andi	r26, 0x40	; 64
    1c94:	b0 70       	andi	r27, 0x00	; 0
    1c96:	80 50       	subi	r24, 0x00	; 0
    1c98:	90 42       	sbci	r25, 0x20	; 32
    1c9a:	a0 44       	sbci	r26, 0x40	; 64
    1c9c:	b0 40       	sbci	r27, 0x00	; 0
    1c9e:	a9 f5       	brne	.+106    	; 0x1d0a <_Z21check_sensors_releasemmi+0x8e0>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1ca0:	62 17       	cp	r22, r18
    1ca2:	73 07       	cpc	r23, r19
    1ca4:	0c f4       	brge	.+2      	; 0x1ca8 <_Z21check_sensors_releasemmi+0x87e>
    1ca6:	cf c7       	rjmp	.+3998   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1ca8:	f8 01       	movw	r30, r16
    1caa:	e4 0f       	add	r30, r20
    1cac:	f5 1f       	adc	r31, r21
    1cae:	01 90       	ld	r0, Z+
    1cb0:	f0 81       	ld	r31, Z
    1cb2:	e0 2d       	mov	r30, r0
            if (modeCheck(KMODE_DEFAULT, pos)) {
    1cb4:	30 97       	sbiw	r30, 0x00	; 0
    1cb6:	81 f4       	brne	.+32     	; 0x1cd8 <_Z21check_sensors_releasemmi+0x8ae>
                keypress(KEY_BACKSPACE);
    1cb8:	8a e2       	ldi	r24, 0x2A	; 42
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	68 db       	rcall	.-2352   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1cbe:	82 e0       	ldi	r24, 0x02	; 2
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    1cc6:	84 e0       	ldi	r24, 0x04	; 4
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1cce:	81 e0       	ldi	r24, 0x01	; 1
    1cd0:	90 e0       	ldi	r25, 0x00	; 0
    1cd2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1cd6:	b7 c7       	rjmp	.+3950   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos)) {
    1cd8:	e1 30       	cpi	r30, 0x01	; 1
    1cda:	f1 05       	cpc	r31, r1
    1cdc:	31 f0       	breq	.+12     	; 0x1cea <_Z21check_sensors_releasemmi+0x8c0>
    1cde:	e2 30       	cpi	r30, 0x02	; 2
    1ce0:	f1 05       	cpc	r31, r1
    1ce2:	19 f0       	breq	.+6      	; 0x1cea <_Z21check_sensors_releasemmi+0x8c0>
    1ce4:	33 97       	sbiw	r30, 0x03	; 3
    1ce6:	09 f0       	breq	.+2      	; 0x1cea <_Z21check_sensors_releasemmi+0x8c0>
    1ce8:	6f c7       	rjmp	.+3806   	; 0x2bc8 <__stack+0xac9>
                keypress(KEY_SPACE);
    1cea:	8c e2       	ldi	r24, 0x2C	; 44
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	4f db       	rcall	.-2402   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1cf0:	82 e0       	ldi	r24, 0x02	; 2
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    1cf8:	84 e0       	ldi	r24, 0x04	; 4
    1cfa:	90 e0       	ldi	r25, 0x00	; 0
    1cfc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1d00:	81 e0       	ldi	r24, 0x01	; 1
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1d08:	9e c7       	rjmp	.+3900   	; 0x2c46 <__stack+0xb47>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1d0a:	62 17       	cp	r22, r18
    1d0c:	73 07       	cpc	r23, r19
    1d0e:	0c f4       	brge	.+2      	; 0x1d12 <_Z21check_sensors_releasemmi+0x8e8>
    1d10:	9a c7       	rjmp	.+3892   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1d12:	f8 01       	movw	r30, r16
    1d14:	e4 0f       	add	r30, r20
    1d16:	f5 1f       	adc	r31, r21
    1d18:	01 90       	ld	r0, Z+
    1d1a:	f0 81       	ld	r31, Z
    1d1c:	e0 2d       	mov	r30, r0
                return;
             }
        } else {
             if (modeCheck(KMODE_DEFAULT, pos)) {
    1d1e:	30 97       	sbiw	r30, 0x00	; 0
    1d20:	81 f4       	brne	.+32     	; 0x1d42 <_Z21check_sensors_releasemmi+0x918>
                keypress(KEY_T);
    1d22:	87 e1       	ldi	r24, 0x17	; 23
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	33 db       	rcall	.-2458   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1d28:	82 e0       	ldi	r24, 0x02	; 2
    1d2a:	90 e0       	ldi	r25, 0x00	; 0
    1d2c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    1d30:	84 e0       	ldi	r24, 0x04	; 4
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1d38:	81 e0       	ldi	r24, 0x01	; 1
    1d3a:	90 e0       	ldi	r25, 0x00	; 0
    1d3c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1d40:	82 c7       	rjmp	.+3844   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1d42:	e1 30       	cpi	r30, 0x01	; 1
    1d44:	f1 05       	cpc	r31, r1
    1d46:	81 f4       	brne	.+32     	; 0x1d68 <_Z21check_sensors_releasemmi+0x93e>
                keypress(KEY_7);
    1d48:	84 e2       	ldi	r24, 0x24	; 36
    1d4a:	90 e0       	ldi	r25, 0x00	; 0
    1d4c:	20 db       	rcall	.-2496   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1d4e:	82 e0       	ldi	r24, 0x02	; 2
    1d50:	90 e0       	ldi	r25, 0x00	; 0
    1d52:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    1d56:	84 e0       	ldi	r24, 0x04	; 4
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1d66:	6f c7       	rjmp	.+3806   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1d68:	e2 30       	cpi	r30, 0x02	; 2
    1d6a:	f1 05       	cpc	r31, r1
    1d6c:	a1 f4       	brne	.+40     	; 0x1d96 <_Z21check_sensors_releasemmi+0x96c>
                modifierdown(MODIFIERKEY_SHIFT);
    1d6e:	82 e0       	ldi	r24, 0x02	; 2
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
                keypress(KEY_COMMA);
    1d76:	86 e3       	ldi	r24, 0x36	; 54
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	09 db       	rcall	.-2542   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1d7c:	82 e0       	ldi	r24, 0x02	; 2
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    1d84:	84 e0       	ldi	r24, 0x04	; 4
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1d8c:	81 e0       	ldi	r24, 0x01	; 1
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1d94:	58 c7       	rjmp	.+3760   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    1d96:	33 97       	sbiw	r30, 0x03	; 3
    1d98:	09 f0       	breq	.+2      	; 0x1d9c <_Z21check_sensors_releasemmi+0x972>
    1d9a:	16 c7       	rjmp	.+3628   	; 0x2bc8 <__stack+0xac9>
                keypress(KEY_F7);
    1d9c:	80 e4       	ldi	r24, 0x40	; 64
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	f6 da       	rcall	.-2580   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    1da2:	82 e0       	ldi	r24, 0x02	; 2
    1da4:	90 e0       	ldi	r25, 0x00	; 0
    1da6:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    1daa:	84 e0       	ldi	r24, 0x04	; 4
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1dba:	45 c7       	rjmp	.+3722   	; 0x2c46 <__stack+0xb47>
                return;
             }
        }
    } else if ((sensors1 & KS1_IY) == KS1_IY && (sensors2 & KS2_IY) == KS2_IY) {
    1dbc:	8d a1       	ldd	r24, Y+37	; 0x25
    1dbe:	9e a1       	ldd	r25, Y+38	; 0x26
    1dc0:	af a1       	ldd	r26, Y+39	; 0x27
    1dc2:	b8 a5       	ldd	r27, Y+40	; 0x28
    1dc4:	00 97       	sbiw	r24, 0x00	; 0
    1dc6:	a1 05       	cpc	r26, r1
    1dc8:	b1 05       	cpc	r27, r1
    1dca:	09 f4       	brne	.+2      	; 0x1dce <_Z21check_sensors_releasemmi+0x9a4>
    1dcc:	55 c0       	rjmp	.+170    	; 0x1e78 <_Z21check_sensors_releasemmi+0xa4e>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1dce:	62 17       	cp	r22, r18
    1dd0:	73 07       	cpc	r23, r19
    1dd2:	0c f4       	brge	.+2      	; 0x1dd6 <_Z21check_sensors_releasemmi+0x9ac>
    1dd4:	38 c7       	rjmp	.+3696   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1dd6:	f8 01       	movw	r30, r16
    1dd8:	e4 0f       	add	r30, r20
    1dda:	f5 1f       	adc	r31, r21
    1ddc:	01 90       	ld	r0, Z+
    1dde:	f0 81       	ld	r31, Z
    1de0:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1de2:	30 97       	sbiw	r30, 0x00	; 0
    1de4:	81 f4       	brne	.+32     	; 0x1e06 <_Z21check_sensors_releasemmi+0x9dc>
            keypress(KEY_G);
    1de6:	8a e0       	ldi	r24, 0x0A	; 10
    1de8:	90 e0       	ldi	r25, 0x00	; 0
    1dea:	d1 da       	rcall	.-2654   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1dec:	82 e0       	ldi	r24, 0x02	; 2
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1df4:	84 e0       	ldi	r24, 0x04	; 4
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1dfc:	81 e0       	ldi	r24, 0x01	; 1
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1e04:	20 c7       	rjmp	.+3648   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1e06:	e1 30       	cpi	r30, 0x01	; 1
    1e08:	f1 05       	cpc	r31, r1
    1e0a:	81 f4       	brne	.+32     	; 0x1e2c <_Z21check_sensors_releasemmi+0xa02>
            keypress(KEY_9);
    1e0c:	86 e2       	ldi	r24, 0x26	; 38
    1e0e:	90 e0       	ldi	r25, 0x00	; 0
    1e10:	be da       	rcall	.-2692   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1e12:	82 e0       	ldi	r24, 0x02	; 2
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1e1a:	84 e0       	ldi	r24, 0x04	; 4
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1e22:	81 e0       	ldi	r24, 0x01	; 1
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1e2a:	0d c7       	rjmp	.+3610   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1e2c:	e2 30       	cpi	r30, 0x02	; 2
    1e2e:	f1 05       	cpc	r31, r1
    1e30:	81 f4       	brne	.+32     	; 0x1e52 <_Z21check_sensors_releasemmi+0xa28>
            keypress(KEY_SLASH);
    1e32:	88 e3       	ldi	r24, 0x38	; 56
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	ab da       	rcall	.-2730   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1e38:	82 e0       	ldi	r24, 0x02	; 2
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1e40:	84 e0       	ldi	r24, 0x04	; 4
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1e48:	81 e0       	ldi	r24, 0x01	; 1
    1e4a:	90 e0       	ldi	r25, 0x00	; 0
    1e4c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1e50:	fa c6       	rjmp	.+3572   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    1e52:	33 97       	sbiw	r30, 0x03	; 3
    1e54:	09 f0       	breq	.+2      	; 0x1e58 <_Z21check_sensors_releasemmi+0xa2e>
    1e56:	b8 c6       	rjmp	.+3440   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F9);
    1e58:	82 e4       	ldi	r24, 0x42	; 66
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	98 da       	rcall	.-2768   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1e5e:	82 e0       	ldi	r24, 0x02	; 2
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1e66:	84 e0       	ldi	r24, 0x04	; 4
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1e6e:	81 e0       	ldi	r24, 0x01	; 1
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1e76:	e7 c6       	rjmp	.+3534   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_SY) == KS1_SY && (sensors2 & KS2_SY) == KS2_SY) {
    1e78:	c6 01       	movw	r24, r12
    1e7a:	80 70       	andi	r24, 0x00	; 0
    1e7c:	90 78       	andi	r25, 0x80	; 128
    1e7e:	89 2b       	or	r24, r25
    1e80:	09 f4       	brne	.+2      	; 0x1e84 <_Z21check_sensors_releasemmi+0xa5a>
    1e82:	42 c0       	rjmp	.+132    	; 0x1f08 <_Z21check_sensors_releasemmi+0xade>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1e84:	62 17       	cp	r22, r18
    1e86:	73 07       	cpc	r23, r19
    1e88:	0c f4       	brge	.+2      	; 0x1e8c <_Z21check_sensors_releasemmi+0xa62>
    1e8a:	dd c6       	rjmp	.+3514   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1e8c:	f8 01       	movw	r30, r16
    1e8e:	e4 0f       	add	r30, r20
    1e90:	f5 1f       	adc	r31, r21
    1e92:	01 90       	ld	r0, Z+
    1e94:	f0 81       	ld	r31, Z
    1e96:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1e98:	30 97       	sbiw	r30, 0x00	; 0
    1e9a:	81 f4       	brne	.+32     	; 0x1ebc <_Z21check_sensors_releasemmi+0xa92>
            keypress(KEY_W);
    1e9c:	8a e1       	ldi	r24, 0x1A	; 26
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	76 da       	rcall	.-2836   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1ea2:	82 e0       	ldi	r24, 0x02	; 2
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1eaa:	84 e0       	ldi	r24, 0x04	; 4
    1eac:	90 e0       	ldi	r25, 0x00	; 0
    1eae:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1eb2:	81 e0       	ldi	r24, 0x01	; 1
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1eba:	c5 c6       	rjmp	.+3466   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1ebc:	e1 30       	cpi	r30, 0x01	; 1
    1ebe:	f1 05       	cpc	r31, r1
    1ec0:	81 f4       	brne	.+32     	; 0x1ee2 <_Z21check_sensors_releasemmi+0xab8>
            keypress(KEYPAD_EQUAL);
    1ec2:	87 e6       	ldi	r24, 0x67	; 103
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	63 da       	rcall	.-2874   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1ec8:	82 e0       	ldi	r24, 0x02	; 2
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1ed0:	84 e0       	ldi	r24, 0x04	; 4
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1ee0:	b2 c6       	rjmp	.+3428   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1ee2:	32 97       	sbiw	r30, 0x02	; 2
    1ee4:	09 f0       	breq	.+2      	; 0x1ee8 <_Z21check_sensors_releasemmi+0xabe>
    1ee6:	70 c6       	rjmp	.+3296   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_LEFT_BRACE);
    1ee8:	8f e2       	ldi	r24, 0x2F	; 47
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	50 da       	rcall	.-2912   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1eee:	82 e0       	ldi	r24, 0x02	; 2
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1ef6:	84 e0       	ldi	r24, 0x04	; 4
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1efe:	81 e0       	ldi	r24, 0x01	; 1
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1f06:	9f c6       	rjmp	.+3390   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_TY) == KS1_TY && (sensors2 & KS2_TY) == KS2_TY) {
    1f08:	89 a5       	ldd	r24, Y+41	; 0x29
    1f0a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1f0c:	ab a5       	ldd	r26, Y+43	; 0x2b
    1f0e:	bc a5       	ldd	r27, Y+44	; 0x2c
    1f10:	00 97       	sbiw	r24, 0x00	; 0
    1f12:	a1 05       	cpc	r26, r1
    1f14:	b1 05       	cpc	r27, r1
    1f16:	09 f4       	brne	.+2      	; 0x1f1a <_Z21check_sensors_releasemmi+0xaf0>
    1f18:	46 c0       	rjmp	.+140    	; 0x1fa6 <_Z21check_sensors_releasemmi+0xb7c>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1f1a:	62 17       	cp	r22, r18
    1f1c:	73 07       	cpc	r23, r19
    1f1e:	0c f4       	brge	.+2      	; 0x1f22 <_Z21check_sensors_releasemmi+0xaf8>
    1f20:	92 c6       	rjmp	.+3364   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1f22:	f8 01       	movw	r30, r16
    1f24:	e4 0f       	add	r30, r20
    1f26:	f5 1f       	adc	r31, r21
    1f28:	01 90       	ld	r0, Z+
    1f2a:	f0 81       	ld	r31, Z
    1f2c:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1f2e:	30 97       	sbiw	r30, 0x00	; 0
    1f30:	81 f4       	brne	.+32     	; 0x1f52 <_Z21check_sensors_releasemmi+0xb28>
            keypress(KEY_K);
    1f32:	8e e0       	ldi	r24, 0x0E	; 14
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	2b da       	rcall	.-2986   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1f38:	82 e0       	ldi	r24, 0x02	; 2
    1f3a:	90 e0       	ldi	r25, 0x00	; 0
    1f3c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1f40:	84 e0       	ldi	r24, 0x04	; 4
    1f42:	90 e0       	ldi	r25, 0x00	; 0
    1f44:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1f48:	81 e0       	ldi	r24, 0x01	; 1
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1f50:	7a c6       	rjmp	.+3316   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1f52:	e1 30       	cpi	r30, 0x01	; 1
    1f54:	f1 05       	cpc	r31, r1
    1f56:	a1 f4       	brne	.+40     	; 0x1f80 <_Z21check_sensors_releasemmi+0xb56>
            modifierdown(MODIFIERKEY_SHIFT);
    1f58:	82 e0       	ldi	r24, 0x02	; 2
    1f5a:	90 e0       	ldi	r25, 0x00	; 0
    1f5c:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_6);
    1f60:	83 e2       	ldi	r24, 0x23	; 35
    1f62:	90 e0       	ldi	r25, 0x00	; 0
    1f64:	14 da       	rcall	.-3032   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1f66:	82 e0       	ldi	r24, 0x02	; 2
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1f6e:	84 e0       	ldi	r24, 0x04	; 4
    1f70:	90 e0       	ldi	r25, 0x00	; 0
    1f72:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1f76:	81 e0       	ldi	r24, 0x01	; 1
    1f78:	90 e0       	ldi	r25, 0x00	; 0
    1f7a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1f7e:	63 c6       	rjmp	.+3270   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    1f80:	32 97       	sbiw	r30, 0x02	; 2
    1f82:	09 f0       	breq	.+2      	; 0x1f86 <_Z21check_sensors_releasemmi+0xb5c>
    1f84:	21 c6       	rjmp	.+3138   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_RIGHT_BRACE);
    1f86:	80 e3       	ldi	r24, 0x30	; 48
    1f88:	90 e0       	ldi	r25, 0x00	; 0
    1f8a:	01 da       	rcall	.-3070   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1f8c:	82 e0       	ldi	r24, 0x02	; 2
    1f8e:	90 e0       	ldi	r25, 0x00	; 0
    1f90:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1f94:	84 e0       	ldi	r24, 0x04	; 4
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1f9c:	81 e0       	ldi	r24, 0x01	; 1
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1fa4:	50 c6       	rjmp	.+3232   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_UY) == KS1_UY && (sensors2 & KS2_UY) == KS2_UY) {
    1fa6:	8d a5       	ldd	r24, Y+45	; 0x2d
    1fa8:	9e a5       	ldd	r25, Y+46	; 0x2e
    1faa:	af a5       	ldd	r26, Y+47	; 0x2f
    1fac:	b8 a9       	ldd	r27, Y+48	; 0x30
    1fae:	00 97       	sbiw	r24, 0x00	; 0
    1fb0:	a1 05       	cpc	r26, r1
    1fb2:	b1 05       	cpc	r27, r1
    1fb4:	09 f4       	brne	.+2      	; 0x1fb8 <_Z21check_sensors_releasemmi+0xb8e>
    1fb6:	46 c0       	rjmp	.+140    	; 0x2044 <_Z21check_sensors_releasemmi+0xc1a>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    1fb8:	62 17       	cp	r22, r18
    1fba:	73 07       	cpc	r23, r19
    1fbc:	0c f4       	brge	.+2      	; 0x1fc0 <_Z21check_sensors_releasemmi+0xb96>
    1fbe:	43 c6       	rjmp	.+3206   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    1fc0:	f8 01       	movw	r30, r16
    1fc2:	e4 0f       	add	r30, r20
    1fc4:	f5 1f       	adc	r31, r21
    1fc6:	01 90       	ld	r0, Z+
    1fc8:	f0 81       	ld	r31, Z
    1fca:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    1fcc:	30 97       	sbiw	r30, 0x00	; 0
    1fce:	81 f4       	brne	.+32     	; 0x1ff0 <_Z21check_sensors_releasemmi+0xbc6>
            keypress(KEY_Z);
    1fd0:	8d e1       	ldi	r24, 0x1D	; 29
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	dc d9       	rcall	.-3144   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    1fd6:	82 e0       	ldi	r24, 0x02	; 2
    1fd8:	90 e0       	ldi	r25, 0x00	; 0
    1fda:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    1fde:	84 e0       	ldi	r24, 0x04	; 4
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    1fe6:	81 e0       	ldi	r24, 0x01	; 1
    1fe8:	90 e0       	ldi	r25, 0x00	; 0
    1fea:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    1fee:	2b c6       	rjmp	.+3158   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    1ff0:	e1 30       	cpi	r30, 0x01	; 1
    1ff2:	f1 05       	cpc	r31, r1
    1ff4:	a1 f4       	brne	.+40     	; 0x201e <_Z21check_sensors_releasemmi+0xbf4>
            modifierdown(MODIFIERKEY_SHIFT);
    1ff6:	82 e0       	ldi	r24, 0x02	; 2
    1ff8:	90 e0       	ldi	r25, 0x00	; 0
    1ffa:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_5);
    1ffe:	82 e2       	ldi	r24, 0x22	; 34
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	c5 d9       	rcall	.-3190   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2004:	82 e0       	ldi	r24, 0x02	; 2
    2006:	90 e0       	ldi	r25, 0x00	; 0
    2008:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    200c:	84 e0       	ldi	r24, 0x04	; 4
    200e:	90 e0       	ldi	r25, 0x00	; 0
    2010:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    201c:	14 c6       	rjmp	.+3112   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    201e:	32 97       	sbiw	r30, 0x02	; 2
    2020:	09 f0       	breq	.+2      	; 0x2024 <_Z21check_sensors_releasemmi+0xbfa>
    2022:	d2 c5       	rjmp	.+2980   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_BACKSLASH);
    2024:	81 e3       	ldi	r24, 0x31	; 49
    2026:	90 e0       	ldi	r25, 0x00	; 0
    2028:	b2 d9       	rcall	.-3228   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    202a:	82 e0       	ldi	r24, 0x02	; 2
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2032:	84 e0       	ldi	r24, 0x04	; 4
    2034:	90 e0       	ldi	r25, 0x00	; 0
    2036:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    203a:	81 e0       	ldi	r24, 0x01	; 1
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2042:	01 c6       	rjmp	.+3074   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_Y5) == KS1_Y5 && (sensors2 & KS2_Y5) == KS2_Y5 && modeCheck(KMODE_DEFAULT, pos)) {
    2044:	89 a9       	ldd	r24, Y+49	; 0x31
    2046:	9a a9       	ldd	r25, Y+50	; 0x32
    2048:	ab a9       	ldd	r26, Y+51	; 0x33
    204a:	bc a9       	ldd	r27, Y+52	; 0x34
    204c:	00 97       	sbiw	r24, 0x00	; 0
    204e:	a1 05       	cpc	r26, r1
    2050:	b1 05       	cpc	r27, r1
    2052:	09 f4       	brne	.+2      	; 0x2056 <_Z21check_sensors_releasemmi+0xc2c>
    2054:	d5 c5       	rjmp	.+2986   	; 0x2c00 <__stack+0xb01>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2056:	62 17       	cp	r22, r18
    2058:	73 07       	cpc	r23, r19
    205a:	0c f4       	brge	.+2      	; 0x205e <_Z21check_sensors_releasemmi+0xc34>
    205c:	d1 c5       	rjmp	.+2978   	; 0x2c00 <__stack+0xb01>
    205e:	f8 01       	movw	r30, r16
    2060:	e4 0f       	add	r30, r20
    2062:	f5 1f       	adc	r31, r21
    2064:	80 81       	ld	r24, Z
    2066:	91 81       	ldd	r25, Z+1	; 0x01
    2068:	89 2b       	or	r24, r25
    206a:	09 f0       	breq	.+2      	; 0x206e <_Z21check_sensors_releasemmi+0xc44>
    206c:	c9 c5       	rjmp	.+2962   	; 0x2c00 <__stack+0xb01>
        keypress(KEY_V);
    206e:	89 e1       	ldi	r24, 0x19	; 25
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	8d d9       	rcall	.-3302   	; 0x138e <_Z8keypressi>
        modifierup(MODIFIERKEY_SHIFT);
    2074:	82 e0       	ldi	r24, 0x02	; 2
    2076:	90 e0       	ldi	r25, 0x00	; 0
    2078:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
        modifierup(MODIFIERKEY_CTRL);
    207c:	84 e0       	ldi	r24, 0x04	; 4
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
        modifierup(MODIFIERKEY_ALT);
    2084:	81 e0       	ldi	r24, 0x01	; 1
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    208c:	dc c5       	rjmp	.+3000   	; 0x2c46 <__stack+0xb47>
    208e:	62 17       	cp	r22, r18
    2090:	73 07       	cpc	r23, r19
    2092:	0c f4       	brge	.+2      	; 0x2096 <_Z21check_sensors_releasemmi+0xc6c>
    2094:	be c5       	rjmp	.+2940   	; 0x2c12 <__stack+0xb13>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2096:	f8 01       	movw	r30, r16
    2098:	e4 0f       	add	r30, r20
    209a:	f5 1f       	adc	r31, r21
    209c:	01 90       	ld	r0, Z+
    209e:	f0 81       	ld	r31, Z
    20a0:	e0 2d       	mov	r30, r0
        return;
    } else if ((sensors1 & KS1_D8) == KS1_D8 && (sensors2 & KS2_D8) == KS2_D8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    20a2:	30 97       	sbiw	r30, 0x00	; 0
    20a4:	49 f0       	breq	.+18     	; 0x20b8 <_Z21check_sensors_releasemmi+0xc8e>
    20a6:	e1 30       	cpi	r30, 0x01	; 1
    20a8:	f1 05       	cpc	r31, r1
    20aa:	31 f0       	breq	.+12     	; 0x20b8 <_Z21check_sensors_releasemmi+0xc8e>
    20ac:	e2 30       	cpi	r30, 0x02	; 2
    20ae:	f1 05       	cpc	r31, r1
    20b0:	19 f0       	breq	.+6      	; 0x20b8 <_Z21check_sensors_releasemmi+0xc8e>
    20b2:	33 97       	sbiw	r30, 0x03	; 3
    20b4:	09 f0       	breq	.+2      	; 0x20b8 <_Z21check_sensors_releasemmi+0xc8e>
    20b6:	ad c5       	rjmp	.+2906   	; 0x2c12 <__stack+0xb13>
        mouseoff(KMOUSE_SCROLL);
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	0e 94 03 04 	call	0x806	; 0x806 <_Z8mouseoffi>
    20c0:	c2 c5       	rjmp	.+2948   	; 0x2c46 <__stack+0xb47>
        return;
    } else if ((sensors1 & KS1_DY) == KS1_DY && (sensors2 & KS2_DY) == KS2_DY) {
        if ((sensors1 & KS1_ADY) == KS1_ADY && (sensors2 & KS2_ADY) == KS2_ADY) {
    20c2:	87 fe       	sbrs	r8, 7
    20c4:	35 c0       	rjmp	.+106    	; 0x2130 <__stack+0x31>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    20c6:	62 17       	cp	r22, r18
    20c8:	73 07       	cpc	r23, r19
    20ca:	0c f4       	brge	.+2      	; 0x20ce <_Z21check_sensors_releasemmi+0xca4>
    20cc:	bc c5       	rjmp	.+2936   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    20ce:	f8 01       	movw	r30, r16
    20d0:	e4 0f       	add	r30, r20
    20d2:	f5 1f       	adc	r31, r21
    20d4:	01 90       	ld	r0, Z+
    20d6:	f0 81       	ld	r31, Z
    20d8:	e0 2d       	mov	r30, r0
            if (modeCheck(KMODE_DEFAULT, pos)) {
    20da:	30 97       	sbiw	r30, 0x00	; 0
    20dc:	81 f4       	brne	.+32     	; 0x20fe <_Z21check_sensors_releasemmi+0xcd4>
                keypress(KEY_SPACE);
    20de:	8c e2       	ldi	r24, 0x2C	; 44
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	55 d9       	rcall	.-3414   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    20e4:	82 e0       	ldi	r24, 0x02	; 2
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    20ec:	84 e0       	ldi	r24, 0x04	; 4
    20ee:	90 e0       	ldi	r25, 0x00	; 0
    20f0:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	90 e0       	ldi	r25, 0x00	; 0
    20f8:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    20fc:	a4 c5       	rjmp	.+2888   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos)) {
    20fe:	e1 30       	cpi	r30, 0x01	; 1
    2100:	f1 05       	cpc	r31, r1
    2102:	31 f0       	breq	.+12     	; 0x2110 <__stack+0x11>
    2104:	e2 30       	cpi	r30, 0x02	; 2
    2106:	f1 05       	cpc	r31, r1
    2108:	19 f0       	breq	.+6      	; 0x2110 <__stack+0x11>
    210a:	33 97       	sbiw	r30, 0x03	; 3
    210c:	09 f0       	breq	.+2      	; 0x2110 <__stack+0x11>
    210e:	5c c5       	rjmp	.+2744   	; 0x2bc8 <__stack+0xac9>
                keypress(KEY_BACKSPACE);
    2110:	8a e2       	ldi	r24, 0x2A	; 42
    2112:	90 e0       	ldi	r25, 0x00	; 0
    2114:	3c d9       	rcall	.-3464   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    2116:	82 e0       	ldi	r24, 0x02	; 2
    2118:	90 e0       	ldi	r25, 0x00	; 0
    211a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    211e:	84 e0       	ldi	r24, 0x04	; 4
    2120:	90 e0       	ldi	r25, 0x00	; 0
    2122:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    212e:	8b c5       	rjmp	.+2838   	; 0x2c46 <__stack+0xb47>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2130:	62 17       	cp	r22, r18
    2132:	73 07       	cpc	r23, r19
    2134:	0c f4       	brge	.+2      	; 0x2138 <__stack+0x39>
    2136:	87 c5       	rjmp	.+2830   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2138:	f8 01       	movw	r30, r16
    213a:	e4 0f       	add	r30, r20
    213c:	f5 1f       	adc	r31, r21
    213e:	01 90       	ld	r0, Z+
    2140:	f0 81       	ld	r31, Z
    2142:	e0 2d       	mov	r30, r0
                return;
             }
        } else {
             if (modeCheck(KMODE_DEFAULT, pos)) {
    2144:	30 97       	sbiw	r30, 0x00	; 0
    2146:	81 f4       	brne	.+32     	; 0x2168 <__stack+0x69>
                keypress(KEY_H);
    2148:	8b e0       	ldi	r24, 0x0B	; 11
    214a:	90 e0       	ldi	r25, 0x00	; 0
    214c:	20 d9       	rcall	.-3520   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    214e:	82 e0       	ldi	r24, 0x02	; 2
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    2156:	84 e0       	ldi	r24, 0x04	; 4
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    215e:	81 e0       	ldi	r24, 0x01	; 1
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2166:	6f c5       	rjmp	.+2782   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_NUMBERS, pos)) {
    2168:	e1 30       	cpi	r30, 0x01	; 1
    216a:	f1 05       	cpc	r31, r1
    216c:	81 f4       	brne	.+32     	; 0x218e <__stack+0x8f>
                keypress(KEY_4);
    216e:	81 e2       	ldi	r24, 0x21	; 33
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	0d d9       	rcall	.-3558   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    2174:	82 e0       	ldi	r24, 0x02	; 2
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    217c:	84 e0       	ldi	r24, 0x04	; 4
    217e:	90 e0       	ldi	r25, 0x00	; 0
    2180:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    2184:	81 e0       	ldi	r24, 0x01	; 1
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    218c:	5c c5       	rjmp	.+2744   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    218e:	e2 30       	cpi	r30, 0x02	; 2
    2190:	f1 05       	cpc	r31, r1
    2192:	a1 f4       	brne	.+40     	; 0x21bc <__stack+0xbd>
                modifierdown(MODIFIERKEY_SHIFT);
    2194:	82 e0       	ldi	r24, 0x02	; 2
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
                keypress(KEY_9);
    219c:	86 e2       	ldi	r24, 0x26	; 38
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	f6 d8       	rcall	.-3604   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    21a2:	82 e0       	ldi	r24, 0x02	; 2
    21a4:	90 e0       	ldi	r25, 0x00	; 0
    21a6:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    21aa:	84 e0       	ldi	r24, 0x04	; 4
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    21b2:	81 e0       	ldi	r24, 0x01	; 1
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    21ba:	45 c5       	rjmp	.+2698   	; 0x2c46 <__stack+0xb47>
                return;
             } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    21bc:	33 97       	sbiw	r30, 0x03	; 3
    21be:	09 f0       	breq	.+2      	; 0x21c2 <__stack+0xc3>
    21c0:	03 c5       	rjmp	.+2566   	; 0x2bc8 <__stack+0xac9>
                keypress(KEY_F4);
    21c2:	8d e3       	ldi	r24, 0x3D	; 61
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	e3 d8       	rcall	.-3642   	; 0x138e <_Z8keypressi>
                modifierup(MODIFIERKEY_SHIFT);
    21c8:	82 e0       	ldi	r24, 0x02	; 2
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_CTRL);
    21d0:	84 e0       	ldi	r24, 0x04	; 4
    21d2:	90 e0       	ldi	r25, 0x00	; 0
    21d4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
                modifierup(MODIFIERKEY_ALT);
    21d8:	81 e0       	ldi	r24, 0x01	; 1
    21da:	90 e0       	ldi	r25, 0x00	; 0
    21dc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    21e0:	32 c5       	rjmp	.+2660   	; 0x2c46 <__stack+0xb47>
                return;
             }
        }
    } else if ((sensors1 & KS1_EY) == KS1_EY && (sensors2 & KS2_EY) == KS2_EY) {
    21e2:	21 96       	adiw	r28, 0x01	; 1
    21e4:	8c ad       	ldd	r24, Y+60	; 0x3c
    21e6:	9d ad       	ldd	r25, Y+61	; 0x3d
    21e8:	ae ad       	ldd	r26, Y+62	; 0x3e
    21ea:	bf ad       	ldd	r27, Y+63	; 0x3f
    21ec:	21 97       	sbiw	r28, 0x01	; 1
    21ee:	00 97       	sbiw	r24, 0x00	; 0
    21f0:	a1 05       	cpc	r26, r1
    21f2:	b1 05       	cpc	r27, r1
    21f4:	09 f4       	brne	.+2      	; 0x21f8 <__stack+0xf9>
    21f6:	59 c0       	rjmp	.+178    	; 0x22aa <__stack+0x1ab>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    21f8:	62 17       	cp	r22, r18
    21fa:	73 07       	cpc	r23, r19
    21fc:	0c f4       	brge	.+2      	; 0x2200 <__stack+0x101>
    21fe:	23 c5       	rjmp	.+2630   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2200:	f8 01       	movw	r30, r16
    2202:	e4 0f       	add	r30, r20
    2204:	f5 1f       	adc	r31, r21
    2206:	01 90       	ld	r0, Z+
    2208:	f0 81       	ld	r31, Z
    220a:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    220c:	30 97       	sbiw	r30, 0x00	; 0
    220e:	81 f4       	brne	.+32     	; 0x2230 <__stack+0x131>
            keypress(KEY_M);
    2210:	80 e1       	ldi	r24, 0x10	; 16
    2212:	90 e0       	ldi	r25, 0x00	; 0
    2214:	bc d8       	rcall	.-3720   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2216:	82 e0       	ldi	r24, 0x02	; 2
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    221e:	84 e0       	ldi	r24, 0x04	; 4
    2220:	90 e0       	ldi	r25, 0x00	; 0
    2222:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2226:	81 e0       	ldi	r24, 0x01	; 1
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    222e:	0b c5       	rjmp	.+2582   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    2230:	e1 30       	cpi	r30, 0x01	; 1
    2232:	f1 05       	cpc	r31, r1
    2234:	81 f4       	brne	.+32     	; 0x2256 <__stack+0x157>
            keypress(KEY_5);
    2236:	82 e2       	ldi	r24, 0x22	; 34
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	a9 d8       	rcall	.-3758   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    223c:	82 e0       	ldi	r24, 0x02	; 2
    223e:	90 e0       	ldi	r25, 0x00	; 0
    2240:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2244:	84 e0       	ldi	r24, 0x04	; 4
    2246:	90 e0       	ldi	r25, 0x00	; 0
    2248:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    224c:	81 e0       	ldi	r24, 0x01	; 1
    224e:	90 e0       	ldi	r25, 0x00	; 0
    2250:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2254:	f8 c4       	rjmp	.+2544   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    2256:	e2 30       	cpi	r30, 0x02	; 2
    2258:	f1 05       	cpc	r31, r1
    225a:	a1 f4       	brne	.+40     	; 0x2284 <__stack+0x185>
            modifierdown(MODIFIERKEY_SHIFT);
    225c:	82 e0       	ldi	r24, 0x02	; 2
    225e:	90 e0       	ldi	r25, 0x00	; 0
    2260:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_0);
    2264:	87 e2       	ldi	r24, 0x27	; 39
    2266:	90 e0       	ldi	r25, 0x00	; 0
    2268:	92 d8       	rcall	.-3804   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    226a:	82 e0       	ldi	r24, 0x02	; 2
    226c:	90 e0       	ldi	r25, 0x00	; 0
    226e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2272:	84 e0       	ldi	r24, 0x04	; 4
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    227a:	81 e0       	ldi	r24, 0x01	; 1
    227c:	90 e0       	ldi	r25, 0x00	; 0
    227e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2282:	e1 c4       	rjmp	.+2498   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    2284:	33 97       	sbiw	r30, 0x03	; 3
    2286:	09 f0       	breq	.+2      	; 0x228a <__stack+0x18b>
    2288:	9f c4       	rjmp	.+2366   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F5);
    228a:	8e e3       	ldi	r24, 0x3E	; 62
    228c:	90 e0       	ldi	r25, 0x00	; 0
    228e:	7f d8       	rcall	.-3842   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2290:	82 e0       	ldi	r24, 0x02	; 2
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2298:	84 e0       	ldi	r24, 0x04	; 4
    229a:	90 e0       	ldi	r25, 0x00	; 0
    229c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    22a0:	81 e0       	ldi	r24, 0x01	; 1
    22a2:	90 e0       	ldi	r25, 0x00	; 0
    22a4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    22a8:	ce c4       	rjmp	.+2460   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_FY) == KS1_FY && (sensors2 & KS2_FY) == KS2_FY) {
    22aa:	25 96       	adiw	r28, 0x05	; 5
    22ac:	8c ad       	ldd	r24, Y+60	; 0x3c
    22ae:	9d ad       	ldd	r25, Y+61	; 0x3d
    22b0:	ae ad       	ldd	r26, Y+62	; 0x3e
    22b2:	bf ad       	ldd	r27, Y+63	; 0x3f
    22b4:	25 97       	sbiw	r28, 0x05	; 5
    22b6:	00 97       	sbiw	r24, 0x00	; 0
    22b8:	a1 05       	cpc	r26, r1
    22ba:	b1 05       	cpc	r27, r1
    22bc:	09 f4       	brne	.+2      	; 0x22c0 <__stack+0x1c1>
    22be:	59 c0       	rjmp	.+178    	; 0x2372 <__stack+0x273>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    22c0:	62 17       	cp	r22, r18
    22c2:	73 07       	cpc	r23, r19
    22c4:	0c f4       	brge	.+2      	; 0x22c8 <__stack+0x1c9>
    22c6:	bf c4       	rjmp	.+2430   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    22c8:	f8 01       	movw	r30, r16
    22ca:	e4 0f       	add	r30, r20
    22cc:	f5 1f       	adc	r31, r21
    22ce:	01 90       	ld	r0, Z+
    22d0:	f0 81       	ld	r31, Z
    22d2:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    22d4:	30 97       	sbiw	r30, 0x00	; 0
    22d6:	81 f4       	brne	.+32     	; 0x22f8 <__stack+0x1f9>
            keypress(KEY_B);
    22d8:	85 e0       	ldi	r24, 0x05	; 5
    22da:	90 e0       	ldi	r25, 0x00	; 0
    22dc:	58 d8       	rcall	.-3920   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    22de:	82 e0       	ldi	r24, 0x02	; 2
    22e0:	90 e0       	ldi	r25, 0x00	; 0
    22e2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    22e6:	84 e0       	ldi	r24, 0x04	; 4
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    22ee:	81 e0       	ldi	r24, 0x01	; 1
    22f0:	90 e0       	ldi	r25, 0x00	; 0
    22f2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    22f6:	a7 c4       	rjmp	.+2382   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    22f8:	e1 30       	cpi	r30, 0x01	; 1
    22fa:	f1 05       	cpc	r31, r1
    22fc:	81 f4       	brne	.+32     	; 0x231e <__stack+0x21f>
            keypress(KEY_6);
    22fe:	83 e2       	ldi	r24, 0x23	; 35
    2300:	90 e0       	ldi	r25, 0x00	; 0
    2302:	45 d8       	rcall	.-3958   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2304:	82 e0       	ldi	r24, 0x02	; 2
    2306:	90 e0       	ldi	r25, 0x00	; 0
    2308:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    230c:	84 e0       	ldi	r24, 0x04	; 4
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	90 e0       	ldi	r25, 0x00	; 0
    2318:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    231c:	94 c4       	rjmp	.+2344   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    231e:	e2 30       	cpi	r30, 0x02	; 2
    2320:	f1 05       	cpc	r31, r1
    2322:	a1 f4       	brne	.+40     	; 0x234c <__stack+0x24d>
            modifierdown(MODIFIERKEY_SHIFT);
    2324:	82 e0       	ldi	r24, 0x02	; 2
    2326:	90 e0       	ldi	r25, 0x00	; 0
    2328:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_SLASH);
    232c:	88 e3       	ldi	r24, 0x38	; 56
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	2e d8       	rcall	.-4004   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2332:	82 e0       	ldi	r24, 0x02	; 2
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    233a:	84 e0       	ldi	r24, 0x04	; 4
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	90 e0       	ldi	r25, 0x00	; 0
    2346:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    234a:	7d c4       	rjmp	.+2298   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    234c:	33 97       	sbiw	r30, 0x03	; 3
    234e:	09 f0       	breq	.+2      	; 0x2352 <__stack+0x253>
    2350:	3b c4       	rjmp	.+2166   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F6);
    2352:	8f e3       	ldi	r24, 0x3F	; 63
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	1b d8       	rcall	.-4042   	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2358:	82 e0       	ldi	r24, 0x02	; 2
    235a:	90 e0       	ldi	r25, 0x00	; 0
    235c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2360:	84 e0       	ldi	r24, 0x04	; 4
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2368:	81 e0       	ldi	r24, 0x01	; 1
    236a:	90 e0       	ldi	r25, 0x00	; 0
    236c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2370:	6a c4       	rjmp	.+2260   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_PY) == KS1_PY && (sensors2 & KS2_PY) == KS2_PY) {
    2372:	29 96       	adiw	r28, 0x09	; 9
    2374:	8c ad       	ldd	r24, Y+60	; 0x3c
    2376:	9d ad       	ldd	r25, Y+61	; 0x3d
    2378:	ae ad       	ldd	r26, Y+62	; 0x3e
    237a:	bf ad       	ldd	r27, Y+63	; 0x3f
    237c:	29 97       	sbiw	r28, 0x09	; 9
    237e:	00 97       	sbiw	r24, 0x00	; 0
    2380:	a1 05       	cpc	r26, r1
    2382:	b1 05       	cpc	r27, r1
    2384:	09 f4       	brne	.+2      	; 0x2388 <__stack+0x289>
    2386:	5d c0       	rjmp	.+186    	; 0x2442 <__stack+0x343>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2388:	62 17       	cp	r22, r18
    238a:	73 07       	cpc	r23, r19
    238c:	0c f4       	brge	.+2      	; 0x2390 <__stack+0x291>
    238e:	5b c4       	rjmp	.+2230   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2390:	f8 01       	movw	r30, r16
    2392:	e4 0f       	add	r30, r20
    2394:	f5 1f       	adc	r31, r21
    2396:	01 90       	ld	r0, Z+
    2398:	f0 81       	ld	r31, Z
    239a:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    239c:	30 97       	sbiw	r30, 0x00	; 0
    239e:	89 f4       	brne	.+34     	; 0x23c2 <__stack+0x2c3>
            keypress(KEY_O);
    23a0:	82 e1       	ldi	r24, 0x12	; 18
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    23a8:	82 e0       	ldi	r24, 0x02	; 2
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    23b0:	84 e0       	ldi	r24, 0x04	; 4
    23b2:	90 e0       	ldi	r25, 0x00	; 0
    23b4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    23b8:	81 e0       	ldi	r24, 0x01	; 1
    23ba:	90 e0       	ldi	r25, 0x00	; 0
    23bc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    23c0:	42 c4       	rjmp	.+2180   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    23c2:	e1 30       	cpi	r30, 0x01	; 1
    23c4:	f1 05       	cpc	r31, r1
    23c6:	89 f4       	brne	.+34     	; 0x23ea <__stack+0x2eb>
            keypress(KEYPAD_ASTERIX);
    23c8:	85 e5       	ldi	r24, 0x55	; 85
    23ca:	90 e0       	ldi	r25, 0x00	; 0
    23cc:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    23d0:	82 e0       	ldi	r24, 0x02	; 2
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    23d8:	84 e0       	ldi	r24, 0x04	; 4
    23da:	90 e0       	ldi	r25, 0x00	; 0
    23dc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    23e0:	81 e0       	ldi	r24, 0x01	; 1
    23e2:	90 e0       	ldi	r25, 0x00	; 0
    23e4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    23e8:	2e c4       	rjmp	.+2140   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    23ea:	e2 30       	cpi	r30, 0x02	; 2
    23ec:	f1 05       	cpc	r31, r1
    23ee:	a9 f4       	brne	.+42     	; 0x241a <__stack+0x31b>
            modifierdown(MODIFIERKEY_SHIFT);
    23f0:	82 e0       	ldi	r24, 0x02	; 2
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_LEFT_BRACE);
    23f8:	8f e2       	ldi	r24, 0x2F	; 47
    23fa:	90 e0       	ldi	r25, 0x00	; 0
    23fc:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2400:	82 e0       	ldi	r24, 0x02	; 2
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2408:	84 e0       	ldi	r24, 0x04	; 4
    240a:	90 e0       	ldi	r25, 0x00	; 0
    240c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2410:	81 e0       	ldi	r24, 0x01	; 1
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2418:	16 c4       	rjmp	.+2092   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    241a:	33 97       	sbiw	r30, 0x03	; 3
    241c:	09 f0       	breq	.+2      	; 0x2420 <__stack+0x321>
    241e:	d4 c3       	rjmp	.+1960   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_MUTE);
    2420:	8f e7       	ldi	r24, 0x7F	; 127
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2428:	82 e0       	ldi	r24, 0x02	; 2
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2430:	84 e0       	ldi	r24, 0x04	; 4
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2438:	81 e0       	ldi	r24, 0x01	; 1
    243a:	90 e0       	ldi	r25, 0x00	; 0
    243c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2440:	02 c4       	rjmp	.+2052   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_QY) == KS1_QY && (sensors2 & KS2_QY) == KS2_QY) {
    2442:	2d 96       	adiw	r28, 0x0d	; 13
    2444:	8c ad       	ldd	r24, Y+60	; 0x3c
    2446:	9d ad       	ldd	r25, Y+61	; 0x3d
    2448:	ae ad       	ldd	r26, Y+62	; 0x3e
    244a:	bf ad       	ldd	r27, Y+63	; 0x3f
    244c:	2d 97       	sbiw	r28, 0x0d	; 13
    244e:	00 97       	sbiw	r24, 0x00	; 0
    2450:	a1 05       	cpc	r26, r1
    2452:	b1 05       	cpc	r27, r1
    2454:	09 f4       	brne	.+2      	; 0x2458 <__stack+0x359>
    2456:	49 c0       	rjmp	.+146    	; 0x24ea <__stack+0x3eb>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2458:	62 17       	cp	r22, r18
    245a:	73 07       	cpc	r23, r19
    245c:	0c f4       	brge	.+2      	; 0x2460 <__stack+0x361>
    245e:	f3 c3       	rjmp	.+2022   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2460:	f8 01       	movw	r30, r16
    2462:	e4 0f       	add	r30, r20
    2464:	f5 1f       	adc	r31, r21
    2466:	01 90       	ld	r0, Z+
    2468:	f0 81       	ld	r31, Z
    246a:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    246c:	30 97       	sbiw	r30, 0x00	; 0
    246e:	89 f4       	brne	.+34     	; 0x2492 <__stack+0x393>
            keypress(KEY_U);
    2470:	88 e1       	ldi	r24, 0x18	; 24
    2472:	90 e0       	ldi	r25, 0x00	; 0
    2474:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2478:	82 e0       	ldi	r24, 0x02	; 2
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2480:	84 e0       	ldi	r24, 0x04	; 4
    2482:	90 e0       	ldi	r25, 0x00	; 0
    2484:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2488:	81 e0       	ldi	r24, 0x01	; 1
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2490:	da c3       	rjmp	.+1972   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    2492:	e1 30       	cpi	r30, 0x01	; 1
    2494:	f1 05       	cpc	r31, r1
    2496:	89 f4       	brne	.+34     	; 0x24ba <__stack+0x3bb>
            keypress(KEYPAD_SLASH);
    2498:	84 e5       	ldi	r24, 0x54	; 84
    249a:	90 e0       	ldi	r25, 0x00	; 0
    249c:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    24a0:	82 e0       	ldi	r24, 0x02	; 2
    24a2:	90 e0       	ldi	r25, 0x00	; 0
    24a4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    24a8:	84 e0       	ldi	r24, 0x04	; 4
    24aa:	90 e0       	ldi	r25, 0x00	; 0
    24ac:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    24b0:	81 e0       	ldi	r24, 0x01	; 1
    24b2:	90 e0       	ldi	r25, 0x00	; 0
    24b4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    24b8:	c6 c3       	rjmp	.+1932   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    24ba:	32 97       	sbiw	r30, 0x02	; 2
    24bc:	09 f0       	breq	.+2      	; 0x24c0 <__stack+0x3c1>
    24be:	84 c3       	rjmp	.+1800   	; 0x2bc8 <__stack+0xac9>
            modifierdown(MODIFIERKEY_SHIFT);
    24c0:	82 e0       	ldi	r24, 0x02	; 2
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_RIGHT_BRACE);
    24c8:	80 e3       	ldi	r24, 0x30	; 48
    24ca:	90 e0       	ldi	r25, 0x00	; 0
    24cc:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    24d0:	82 e0       	ldi	r24, 0x02	; 2
    24d2:	90 e0       	ldi	r25, 0x00	; 0
    24d4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    24d8:	84 e0       	ldi	r24, 0x04	; 4
    24da:	90 e0       	ldi	r25, 0x00	; 0
    24dc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    24e0:	81 e0       	ldi	r24, 0x01	; 1
    24e2:	90 e0       	ldi	r25, 0x00	; 0
    24e4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    24e8:	ae c3       	rjmp	.+1884   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_RY) == KS1_RY && (sensors2 & KS2_RY) == KS2_RY) {
    24ea:	41 14       	cp	r4, r1
    24ec:	51 04       	cpc	r5, r1
    24ee:	61 04       	cpc	r6, r1
    24f0:	71 04       	cpc	r7, r1
    24f2:	a9 f1       	breq	.+106    	; 0x255e <__stack+0x45f>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    24f4:	62 17       	cp	r22, r18
    24f6:	73 07       	cpc	r23, r19
    24f8:	0c f4       	brge	.+2      	; 0x24fc <__stack+0x3fd>
    24fa:	a5 c3       	rjmp	.+1866   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    24fc:	f8 01       	movw	r30, r16
    24fe:	e4 0f       	add	r30, r20
    2500:	f5 1f       	adc	r31, r21
    2502:	01 90       	ld	r0, Z+
    2504:	f0 81       	ld	r31, Z
    2506:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    2508:	30 97       	sbiw	r30, 0x00	; 0
    250a:	89 f4       	brne	.+34     	; 0x252e <__stack+0x42f>
            keypress(KEY_D);
    250c:	87 e0       	ldi	r24, 0x07	; 7
    250e:	90 e0       	ldi	r25, 0x00	; 0
    2510:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2514:	82 e0       	ldi	r24, 0x02	; 2
    2516:	90 e0       	ldi	r25, 0x00	; 0
    2518:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    251c:	84 e0       	ldi	r24, 0x04	; 4
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2524:	81 e0       	ldi	r24, 0x01	; 1
    2526:	90 e0       	ldi	r25, 0x00	; 0
    2528:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    252c:	8c c3       	rjmp	.+1816   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    252e:	32 97       	sbiw	r30, 0x02	; 2
    2530:	09 f0       	breq	.+2      	; 0x2534 <__stack+0x435>
    2532:	4a c3       	rjmp	.+1684   	; 0x2bc8 <__stack+0xac9>
            modifierdown(MODIFIERKEY_SHIFT);
    2534:	82 e0       	ldi	r24, 0x02	; 2
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_1);
    253c:	8e e1       	ldi	r24, 0x1E	; 30
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2544:	82 e0       	ldi	r24, 0x02	; 2
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    254c:	84 e0       	ldi	r24, 0x04	; 4
    254e:	90 e0       	ldi	r25, 0x00	; 0
    2550:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2554:	81 e0       	ldi	r24, 0x01	; 1
    2556:	90 e0       	ldi	r25, 0x00	; 0
    2558:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    255c:	74 c3       	rjmp	.+1768   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_Y4) == KS1_Y4 && (sensors2 & KS2_Y4) == KS2_Y4 && modeCheck(KMODE_DEFAULT, pos)) {
    255e:	84 fe       	sbrs	r8, 4
    2560:	62 c3       	rjmp	.+1732   	; 0x2c26 <__stack+0xb27>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2562:	62 17       	cp	r22, r18
    2564:	73 07       	cpc	r23, r19
    2566:	0c f4       	brge	.+2      	; 0x256a <__stack+0x46b>
    2568:	5e c3       	rjmp	.+1724   	; 0x2c26 <__stack+0xb27>
    256a:	f8 01       	movw	r30, r16
    256c:	e4 0f       	add	r30, r20
    256e:	f5 1f       	adc	r31, r21
    2570:	80 81       	ld	r24, Z
    2572:	91 81       	ldd	r25, Z+1	; 0x01
    2574:	89 2b       	or	r24, r25
    2576:	09 f0       	breq	.+2      	; 0x257a <__stack+0x47b>
    2578:	56 c3       	rjmp	.+1708   	; 0x2c26 <__stack+0xb27>
        keypress(KEY_J);
    257a:	8d e0       	ldi	r24, 0x0D	; 13
    257c:	90 e0       	ldi	r25, 0x00	; 0
    257e:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
        modifierup(MODIFIERKEY_SHIFT);
    2582:	82 e0       	ldi	r24, 0x02	; 2
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
        modifierup(MODIFIERKEY_CTRL);
    258a:	84 e0       	ldi	r24, 0x04	; 4
    258c:	90 e0       	ldi	r25, 0x00	; 0
    258e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
        modifierup(MODIFIERKEY_ALT);
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    259a:	55 c3       	rjmp	.+1706   	; 0x2c46 <__stack+0xb47>
    259c:	62 17       	cp	r22, r18
    259e:	73 07       	cpc	r23, r19
    25a0:	0c f4       	brge	.+2      	; 0x25a4 <__stack+0x4a5>
    25a2:	43 c3       	rjmp	.+1670   	; 0x2c2a <__stack+0xb2b>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    25a4:	f8 01       	movw	r30, r16
    25a6:	e4 0f       	add	r30, r20
    25a8:	f5 1f       	adc	r31, r21
    25aa:	01 90       	ld	r0, Z+
    25ac:	f0 81       	ld	r31, Z
    25ae:	e0 2d       	mov	r30, r0
        return;
    } else if ((sensors1 & KS1_A8) == KS1_A8 && (sensors2 & KS2_A8) == KS2_A8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    25b0:	30 97       	sbiw	r30, 0x00	; 0
    25b2:	49 f0       	breq	.+18     	; 0x25c6 <__stack+0x4c7>
    25b4:	e1 30       	cpi	r30, 0x01	; 1
    25b6:	f1 05       	cpc	r31, r1
    25b8:	31 f0       	breq	.+12     	; 0x25c6 <__stack+0x4c7>
    25ba:	e2 30       	cpi	r30, 0x02	; 2
    25bc:	f1 05       	cpc	r31, r1
    25be:	19 f0       	breq	.+6      	; 0x25c6 <__stack+0x4c7>
    25c0:	33 97       	sbiw	r30, 0x03	; 3
    25c2:	09 f0       	breq	.+2      	; 0x25c6 <__stack+0x4c7>
    25c4:	32 c3       	rjmp	.+1636   	; 0x2c2a <__stack+0xb2b>
        mouseoff(KMOUSE_MOVE);
    25c6:	80 e0       	ldi	r24, 0x00	; 0
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	0e 94 03 04 	call	0x806	; 0x806 <_Z8mouseoffi>
    25ce:	3b c3       	rjmp	.+1654   	; 0x2c46 <__stack+0xb47>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    25d0:	62 17       	cp	r22, r18
    25d2:	73 07       	cpc	r23, r19
    25d4:	0c f4       	brge	.+2      	; 0x25d8 <__stack+0x4d9>
    25d6:	37 c3       	rjmp	.+1646   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    25d8:	f8 01       	movw	r30, r16
    25da:	e4 0f       	add	r30, r20
    25dc:	f5 1f       	adc	r31, r21
    25de:	01 90       	ld	r0, Z+
    25e0:	f0 81       	ld	r31, Z
    25e2:	e0 2d       	mov	r30, r0
        return;
    } else if ((sensors1 & KS1_MY) == KS1_MY && (sensors2 & KS2_MY) == KS2_MY) {
        if (modeCheck(KMODE_DEFAULT, pos)) {
    25e4:	30 97       	sbiw	r30, 0x00	; 0
    25e6:	89 f4       	brne	.+34     	; 0x260a <__stack+0x50b>
            keypress(KEY_A);
    25e8:	84 e0       	ldi	r24, 0x04	; 4
    25ea:	90 e0       	ldi	r25, 0x00	; 0
    25ec:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    25f0:	82 e0       	ldi	r24, 0x02	; 2
    25f2:	90 e0       	ldi	r25, 0x00	; 0
    25f4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    25f8:	84 e0       	ldi	r24, 0x04	; 4
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	90 e0       	ldi	r25, 0x00	; 0
    2604:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2608:	1e c3       	rjmp	.+1596   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    260a:	e1 30       	cpi	r30, 0x01	; 1
    260c:	f1 05       	cpc	r31, r1
    260e:	89 f4       	brne	.+34     	; 0x2632 <__stack+0x533>
            keypress(KEYPAD_PLUS);
    2610:	87 e5       	ldi	r24, 0x57	; 87
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2618:	82 e0       	ldi	r24, 0x02	; 2
    261a:	90 e0       	ldi	r25, 0x00	; 0
    261c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2620:	84 e0       	ldi	r24, 0x04	; 4
    2622:	90 e0       	ldi	r25, 0x00	; 0
    2624:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2628:	81 e0       	ldi	r24, 0x01	; 1
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2630:	0a c3       	rjmp	.+1556   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    2632:	32 97       	sbiw	r30, 0x02	; 2
    2634:	09 f0       	breq	.+2      	; 0x2638 <__stack+0x539>
    2636:	c8 c2       	rjmp	.+1424   	; 0x2bc8 <__stack+0xac9>
            modifierdown(MODIFIERKEY_SHIFT);
    2638:	82 e0       	ldi	r24, 0x02	; 2
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_QUOTE);
    2640:	84 e3       	ldi	r24, 0x34	; 52
    2642:	90 e0       	ldi	r25, 0x00	; 0
    2644:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2648:	82 e0       	ldi	r24, 0x02	; 2
    264a:	90 e0       	ldi	r25, 0x00	; 0
    264c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2650:	84 e0       	ldi	r24, 0x04	; 4
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2658:	81 e0       	ldi	r24, 0x01	; 1
    265a:	90 e0       	ldi	r25, 0x00	; 0
    265c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2660:	f2 c2       	rjmp	.+1508   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_AY) == KS1_AY && (sensors2 & KS2_AY) == KS2_AY) {
    2662:	87 fe       	sbrs	r8, 7
    2664:	59 c0       	rjmp	.+178    	; 0x2718 <__stack+0x619>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2666:	62 17       	cp	r22, r18
    2668:	73 07       	cpc	r23, r19
    266a:	0c f4       	brge	.+2      	; 0x266e <__stack+0x56f>
    266c:	ec c2       	rjmp	.+1496   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    266e:	f8 01       	movw	r30, r16
    2670:	e4 0f       	add	r30, r20
    2672:	f5 1f       	adc	r31, r21
    2674:	01 90       	ld	r0, Z+
    2676:	f0 81       	ld	r31, Z
    2678:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    267a:	30 97       	sbiw	r30, 0x00	; 0
    267c:	89 f4       	brne	.+34     	; 0x26a0 <__stack+0x5a1>
            keypress(KEY_R);
    267e:	85 e1       	ldi	r24, 0x15	; 21
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2686:	82 e0       	ldi	r24, 0x02	; 2
    2688:	90 e0       	ldi	r25, 0x00	; 0
    268a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    268e:	84 e0       	ldi	r24, 0x04	; 4
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2696:	81 e0       	ldi	r24, 0x01	; 1
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    269e:	d3 c2       	rjmp	.+1446   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    26a0:	e1 30       	cpi	r30, 0x01	; 1
    26a2:	f1 05       	cpc	r31, r1
    26a4:	89 f4       	brne	.+34     	; 0x26c8 <__stack+0x5c9>
            keypress(KEY_1);
    26a6:	8e e1       	ldi	r24, 0x1E	; 30
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    26ae:	82 e0       	ldi	r24, 0x02	; 2
    26b0:	90 e0       	ldi	r25, 0x00	; 0
    26b2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    26b6:	84 e0       	ldi	r24, 0x04	; 4
    26b8:	90 e0       	ldi	r25, 0x00	; 0
    26ba:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	90 e0       	ldi	r25, 0x00	; 0
    26c2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    26c6:	bf c2       	rjmp	.+1406   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    26c8:	e2 30       	cpi	r30, 0x02	; 2
    26ca:	f1 05       	cpc	r31, r1
    26cc:	89 f4       	brne	.+34     	; 0x26f0 <__stack+0x5f1>
            keypress(KEY_PERIOD);
    26ce:	87 e3       	ldi	r24, 0x37	; 55
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    26d6:	82 e0       	ldi	r24, 0x02	; 2
    26d8:	90 e0       	ldi	r25, 0x00	; 0
    26da:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    26de:	84 e0       	ldi	r24, 0x04	; 4
    26e0:	90 e0       	ldi	r25, 0x00	; 0
    26e2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	90 e0       	ldi	r25, 0x00	; 0
    26ea:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    26ee:	ab c2       	rjmp	.+1366   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    26f0:	33 97       	sbiw	r30, 0x03	; 3
    26f2:	09 f0       	breq	.+2      	; 0x26f6 <__stack+0x5f7>
    26f4:	69 c2       	rjmp	.+1234   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F1);
    26f6:	8a e3       	ldi	r24, 0x3A	; 58
    26f8:	90 e0       	ldi	r25, 0x00	; 0
    26fa:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    26fe:	82 e0       	ldi	r24, 0x02	; 2
    2700:	90 e0       	ldi	r25, 0x00	; 0
    2702:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2706:	84 e0       	ldi	r24, 0x04	; 4
    2708:	90 e0       	ldi	r25, 0x00	; 0
    270a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    270e:	81 e0       	ldi	r24, 0x01	; 1
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2716:	97 c2       	rjmp	.+1326   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_BY) == KS1_BY && (sensors2 & KS2_BY) == KS2_BY) {
    2718:	90 fe       	sbrs	r9, 0
    271a:	59 c0       	rjmp	.+178    	; 0x27ce <__stack+0x6cf>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    271c:	62 17       	cp	r22, r18
    271e:	73 07       	cpc	r23, r19
    2720:	0c f4       	brge	.+2      	; 0x2724 <__stack+0x625>
    2722:	91 c2       	rjmp	.+1314   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2724:	f8 01       	movw	r30, r16
    2726:	e4 0f       	add	r30, r20
    2728:	f5 1f       	adc	r31, r21
    272a:	01 90       	ld	r0, Z+
    272c:	f0 81       	ld	r31, Z
    272e:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    2730:	30 97       	sbiw	r30, 0x00	; 0
    2732:	89 f4       	brne	.+34     	; 0x2756 <__stack+0x657>
            keypress(KEY_N);
    2734:	81 e1       	ldi	r24, 0x11	; 17
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    273c:	82 e0       	ldi	r24, 0x02	; 2
    273e:	90 e0       	ldi	r25, 0x00	; 0
    2740:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2744:	84 e0       	ldi	r24, 0x04	; 4
    2746:	90 e0       	ldi	r25, 0x00	; 0
    2748:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    274c:	81 e0       	ldi	r24, 0x01	; 1
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2754:	78 c2       	rjmp	.+1264   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    2756:	e1 30       	cpi	r30, 0x01	; 1
    2758:	f1 05       	cpc	r31, r1
    275a:	89 f4       	brne	.+34     	; 0x277e <__stack+0x67f>
            keypress(KEY_2);
    275c:	8f e1       	ldi	r24, 0x1F	; 31
    275e:	90 e0       	ldi	r25, 0x00	; 0
    2760:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2764:	82 e0       	ldi	r24, 0x02	; 2
    2766:	90 e0       	ldi	r25, 0x00	; 0
    2768:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    276c:	84 e0       	ldi	r24, 0x04	; 4
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2774:	81 e0       	ldi	r24, 0x01	; 1
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    277c:	64 c2       	rjmp	.+1224   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    277e:	e2 30       	cpi	r30, 0x02	; 2
    2780:	f1 05       	cpc	r31, r1
    2782:	89 f4       	brne	.+34     	; 0x27a6 <__stack+0x6a7>
            keypress(KEY_COMMA);
    2784:	86 e3       	ldi	r24, 0x36	; 54
    2786:	90 e0       	ldi	r25, 0x00	; 0
    2788:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    278c:	82 e0       	ldi	r24, 0x02	; 2
    278e:	90 e0       	ldi	r25, 0x00	; 0
    2790:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2794:	84 e0       	ldi	r24, 0x04	; 4
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    27a4:	50 c2       	rjmp	.+1184   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    27a6:	33 97       	sbiw	r30, 0x03	; 3
    27a8:	09 f0       	breq	.+2      	; 0x27ac <__stack+0x6ad>
    27aa:	0e c2       	rjmp	.+1052   	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F2);
    27ac:	8b e3       	ldi	r24, 0x3B	; 59
    27ae:	90 e0       	ldi	r25, 0x00	; 0
    27b0:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    27b4:	82 e0       	ldi	r24, 0x02	; 2
    27b6:	90 e0       	ldi	r25, 0x00	; 0
    27b8:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    27bc:	84 e0       	ldi	r24, 0x04	; 4
    27be:	90 e0       	ldi	r25, 0x00	; 0
    27c0:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    27c4:	81 e0       	ldi	r24, 0x01	; 1
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    27cc:	3c c2       	rjmp	.+1144   	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_CY) == KS1_CY && (sensors2 & KS2_CY) == KS2_CY) {
    27ce:	91 fe       	sbrs	r9, 1
    27d0:	5d c0       	rjmp	.+186    	; 0x288c <__stack+0x78d>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    27d2:	62 17       	cp	r22, r18
    27d4:	73 07       	cpc	r23, r19
    27d6:	0c f4       	brge	.+2      	; 0x27da <__stack+0x6db>
    27d8:	36 c2       	rjmp	.+1132   	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    27da:	f8 01       	movw	r30, r16
    27dc:	e4 0f       	add	r30, r20
    27de:	f5 1f       	adc	r31, r21
    27e0:	01 90       	ld	r0, Z+
    27e2:	f0 81       	ld	r31, Z
    27e4:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    27e6:	30 97       	sbiw	r30, 0x00	; 0
    27e8:	89 f4       	brne	.+34     	; 0x280c <__stack+0x70d>
            keypress(KEY_F);
    27ea:	89 e0       	ldi	r24, 0x09	; 9
    27ec:	90 e0       	ldi	r25, 0x00	; 0
    27ee:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    27f2:	82 e0       	ldi	r24, 0x02	; 2
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    27fa:	84 e0       	ldi	r24, 0x04	; 4
    27fc:	90 e0       	ldi	r25, 0x00	; 0
    27fe:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2802:	81 e0       	ldi	r24, 0x01	; 1
    2804:	90 e0       	ldi	r25, 0x00	; 0
    2806:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    280a:	1d c2       	rjmp	.+1082   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    280c:	e1 30       	cpi	r30, 0x01	; 1
    280e:	f1 05       	cpc	r31, r1
    2810:	89 f4       	brne	.+34     	; 0x2834 <__stack+0x735>
            keypress(KEY_3);
    2812:	80 e2       	ldi	r24, 0x20	; 32
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    281a:	82 e0       	ldi	r24, 0x02	; 2
    281c:	90 e0       	ldi	r25, 0x00	; 0
    281e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2822:	84 e0       	ldi	r24, 0x04	; 4
    2824:	90 e0       	ldi	r25, 0x00	; 0
    2826:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    282a:	81 e0       	ldi	r24, 0x01	; 1
    282c:	90 e0       	ldi	r25, 0x00	; 0
    282e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2832:	09 c2       	rjmp	.+1042   	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    2834:	e2 30       	cpi	r30, 0x02	; 2
    2836:	f1 05       	cpc	r31, r1
    2838:	a9 f4       	brne	.+42     	; 0x2864 <__stack+0x765>
            modifierdown(MODIFIERKEY_SHIFT);
    283a:	82 e0       	ldi	r24, 0x02	; 2
    283c:	90 e0       	ldi	r25, 0x00	; 0
    283e:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_2);
    2842:	8f e1       	ldi	r24, 0x1F	; 31
    2844:	90 e0       	ldi	r25, 0x00	; 0
    2846:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    284a:	82 e0       	ldi	r24, 0x02	; 2
    284c:	90 e0       	ldi	r25, 0x00	; 0
    284e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2852:	84 e0       	ldi	r24, 0x04	; 4
    2854:	90 e0       	ldi	r25, 0x00	; 0
    2856:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2862:	f1 c1       	rjmp	.+994    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    2864:	33 97       	sbiw	r30, 0x03	; 3
    2866:	09 f0       	breq	.+2      	; 0x286a <__stack+0x76b>
    2868:	af c1       	rjmp	.+862    	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_F3);
    286a:	8c e3       	ldi	r24, 0x3C	; 60
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2872:	82 e0       	ldi	r24, 0x02	; 2
    2874:	90 e0       	ldi	r25, 0x00	; 0
    2876:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    287a:	84 e0       	ldi	r24, 0x04	; 4
    287c:	90 e0       	ldi	r25, 0x00	; 0
    287e:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    288a:	dd c1       	rjmp	.+954    	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_NY) == KS1_NY && (sensors2 & KS2_NY) == KS2_NY) {
    288c:	94 fe       	sbrs	r9, 4
    288e:	4d c0       	rjmp	.+154    	; 0x292a <__stack+0x82b>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2890:	62 17       	cp	r22, r18
    2892:	73 07       	cpc	r23, r19
    2894:	0c f4       	brge	.+2      	; 0x2898 <__stack+0x799>
    2896:	d7 c1       	rjmp	.+942    	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2898:	f8 01       	movw	r30, r16
    289a:	e4 0f       	add	r30, r20
    289c:	f5 1f       	adc	r31, r21
    289e:	01 90       	ld	r0, Z+
    28a0:	f0 81       	ld	r31, Z
    28a2:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    28a4:	30 97       	sbiw	r30, 0x00	; 0
    28a6:	89 f4       	brne	.+34     	; 0x28ca <__stack+0x7cb>
            keypress(KEY_E);
    28a8:	88 e0       	ldi	r24, 0x08	; 8
    28aa:	90 e0       	ldi	r25, 0x00	; 0
    28ac:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    28b0:	82 e0       	ldi	r24, 0x02	; 2
    28b2:	90 e0       	ldi	r25, 0x00	; 0
    28b4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    28b8:	84 e0       	ldi	r24, 0x04	; 4
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    28c0:	81 e0       	ldi	r24, 0x01	; 1
    28c2:	90 e0       	ldi	r25, 0x00	; 0
    28c4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    28c8:	be c1       	rjmp	.+892    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    28ca:	e1 30       	cpi	r30, 0x01	; 1
    28cc:	f1 05       	cpc	r31, r1
    28ce:	89 f4       	brne	.+34     	; 0x28f2 <__stack+0x7f3>
            keypress(KEYPAD_MINUS);
    28d0:	86 e5       	ldi	r24, 0x56	; 86
    28d2:	90 e0       	ldi	r25, 0x00	; 0
    28d4:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    28d8:	82 e0       	ldi	r24, 0x02	; 2
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    28e0:	84 e0       	ldi	r24, 0x04	; 4
    28e2:	90 e0       	ldi	r25, 0x00	; 0
    28e4:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    28e8:	81 e0       	ldi	r24, 0x01	; 1
    28ea:	90 e0       	ldi	r25, 0x00	; 0
    28ec:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    28f0:	aa c1       	rjmp	.+852    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    28f2:	e2 30       	cpi	r30, 0x02	; 2
    28f4:	f1 05       	cpc	r31, r1
    28f6:	89 f4       	brne	.+34     	; 0x291a <__stack+0x81b>
            keypress(KEY_QUOTE);
    28f8:	84 e3       	ldi	r24, 0x34	; 52
    28fa:	90 e0       	ldi	r25, 0x00	; 0
    28fc:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    2900:	82 e0       	ldi	r24, 0x02	; 2
    2902:	90 e0       	ldi	r25, 0x00	; 0
    2904:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2908:	84 e0       	ldi	r24, 0x04	; 4
    290a:	90 e0       	ldi	r25, 0x00	; 0
    290c:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    2910:	81 e0       	ldi	r24, 0x01	; 1
    2912:	90 e0       	ldi	r25, 0x00	; 0
    2914:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2918:	96 c1       	rjmp	.+812    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    291a:	33 97       	sbiw	r30, 0x03	; 3
    291c:	09 f0       	breq	.+2      	; 0x2920 <__stack+0x821>
    291e:	54 c1       	rjmp	.+680    	; 0x2bc8 <__stack+0xac9>
            modifierpress(MODIFIERKEY_GUI);
    2920:	88 e0       	ldi	r24, 0x08	; 8
    2922:	90 e0       	ldi	r25, 0x00	; 0
    2924:	0e 94 ba 08 	call	0x1174	; 0x1174 <_Z13modifierpressi>
    2928:	8e c1       	rjmp	.+796    	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_OY) == KS1_OY && (sensors2 & KS2_OY) == KS2_OY) {
    292a:	96 fe       	sbrs	r9, 6
    292c:	49 c0       	rjmp	.+146    	; 0x29c0 <__stack+0x8c1>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    292e:	62 17       	cp	r22, r18
    2930:	73 07       	cpc	r23, r19
    2932:	0c f4       	brge	.+2      	; 0x2936 <__stack+0x837>
    2934:	88 c1       	rjmp	.+784    	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2936:	f8 01       	movw	r30, r16
    2938:	e4 0f       	add	r30, r20
    293a:	f5 1f       	adc	r31, r21
    293c:	01 90       	ld	r0, Z+
    293e:	f0 81       	ld	r31, Z
    2940:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos)) {
    2942:	30 97       	sbiw	r30, 0x00	; 0
    2944:	89 f4       	brne	.+34     	; 0x2968 <__stack+0x869>
            keypress(KEY_I);
    2946:	8c e0       	ldi	r24, 0x0C	; 12
    2948:	90 e0       	ldi	r25, 0x00	; 0
    294a:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    294e:	82 e0       	ldi	r24, 0x02	; 2
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2956:	84 e0       	ldi	r24, 0x04	; 4
    2958:	90 e0       	ldi	r25, 0x00	; 0
    295a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    295e:	81 e0       	ldi	r24, 0x01	; 1
    2960:	90 e0       	ldi	r25, 0x00	; 0
    2962:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2966:	6f c1       	rjmp	.+734    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    2968:	e2 30       	cpi	r30, 0x02	; 2
    296a:	f1 05       	cpc	r31, r1
    296c:	a9 f4       	brne	.+42     	; 0x2998 <__stack+0x899>
            modifierdown(MODIFIERKEY_SHIFT);
    296e:	82 e0       	ldi	r24, 0x02	; 2
    2970:	90 e0       	ldi	r25, 0x00	; 0
    2972:	0e 94 e7 05 	call	0xbce	; 0xbce <_Z12modifierdowni>
            keypress(KEY_7);
    2976:	84 e2       	ldi	r24, 0x24	; 36
    2978:	90 e0       	ldi	r25, 0x00	; 0
    297a:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    297e:	82 e0       	ldi	r24, 0x02	; 2
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    2986:	84 e0       	ldi	r24, 0x04	; 4
    2988:	90 e0       	ldi	r25, 0x00	; 0
    298a:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    298e:	81 e0       	ldi	r24, 0x01	; 1
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    2996:	57 c1       	rjmp	.+686    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    2998:	33 97       	sbiw	r30, 0x03	; 3
    299a:	09 f0       	breq	.+2      	; 0x299e <__stack+0x89f>
    299c:	15 c1       	rjmp	.+554    	; 0x2bc8 <__stack+0xac9>
            keypress(KEY_APP);
    299e:	85 e6       	ldi	r24, 0x65	; 101
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	0e 94 c7 09 	call	0x138e	; 0x138e <_Z8keypressi>
            modifierup(MODIFIERKEY_SHIFT);
    29a6:	82 e0       	ldi	r24, 0x02	; 2
    29a8:	90 e0       	ldi	r25, 0x00	; 0
    29aa:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_CTRL);
    29ae:	84 e0       	ldi	r24, 0x04	; 4
    29b0:	90 e0       	ldi	r25, 0x00	; 0
    29b2:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
            modifierup(MODIFIERKEY_ALT);
    29b6:	81 e0       	ldi	r24, 0x01	; 1
    29b8:	90 e0       	ldi	r25, 0x00	; 0
    29ba:	0e 94 b8 05 	call	0xb70	; 0xb70 <_Z10modifierupi>
    29be:	43 c1       	rjmp	.+646    	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_A3) == KS1_A3 && (sensors2 & KS2_A3) == KS2_A3) {
    29c0:	c4 01       	movw	r24, r8
    29c2:	80 70       	andi	r24, 0x00	; 0
    29c4:	90 78       	andi	r25, 0x80	; 128
    29c6:	89 2b       	or	r24, r25
    29c8:	f9 f0       	breq	.+62     	; 0x2a08 <__stack+0x909>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    29ca:	62 17       	cp	r22, r18
    29cc:	73 07       	cpc	r23, r19
    29ce:	0c f4       	brge	.+2      	; 0x29d2 <__stack+0x8d3>
    29d0:	3a c1       	rjmp	.+628    	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    29d2:	f8 01       	movw	r30, r16
    29d4:	e4 0f       	add	r30, r20
    29d6:	f5 1f       	adc	r31, r21
    29d8:	01 90       	ld	r0, Z+
    29da:	f0 81       	ld	r31, Z
    29dc:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos)) {
    29de:	30 97       	sbiw	r30, 0x00	; 0
    29e0:	31 f0       	breq	.+12     	; 0x29ee <__stack+0x8ef>
    29e2:	e1 30       	cpi	r30, 0x01	; 1
    29e4:	f1 05       	cpc	r31, r1
    29e6:	19 f0       	breq	.+6      	; 0x29ee <__stack+0x8ef>
    29e8:	e2 30       	cpi	r30, 0x02	; 2
    29ea:	f1 05       	cpc	r31, r1
    29ec:	29 f4       	brne	.+10     	; 0x29f8 <__stack+0x8f9>
            setmode(KMODE_FUNCTIONS);
    29ee:	83 e0       	ldi	r24, 0x03	; 3
    29f0:	90 e0       	ldi	r25, 0x00	; 0
    29f2:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z7setmodei>
    29f6:	27 c1       	rjmp	.+590    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_FUNCTIONS, pos)) {
    29f8:	33 97       	sbiw	r30, 0x03	; 3
    29fa:	09 f0       	breq	.+2      	; 0x29fe <__stack+0x8ff>
    29fc:	e5 c0       	rjmp	.+458    	; 0x2bc8 <__stack+0xac9>
            setmode(KMODE_DEFAULT);
    29fe:	80 e0       	ldi	r24, 0x00	; 0
    2a00:	90 e0       	ldi	r25, 0x00	; 0
    2a02:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z7setmodei>
    2a06:	1f c1       	rjmp	.+574    	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_A2) == KS1_A2 && (sensors2 & KS2_A2) == KS2_A2) {
    2a08:	a0 fe       	sbrs	r10, 0
    2a0a:	1f c0       	rjmp	.+62     	; 0x2a4a <__stack+0x94b>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2a0c:	62 17       	cp	r22, r18
    2a0e:	73 07       	cpc	r23, r19
    2a10:	0c f4       	brge	.+2      	; 0x2a14 <__stack+0x915>
    2a12:	19 c1       	rjmp	.+562    	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2a14:	f8 01       	movw	r30, r16
    2a16:	e4 0f       	add	r30, r20
    2a18:	f5 1f       	adc	r31, r21
    2a1a:	01 90       	ld	r0, Z+
    2a1c:	f0 81       	ld	r31, Z
    2a1e:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_FUNCTIONS, pos)) {
    2a20:	30 97       	sbiw	r30, 0x00	; 0
    2a22:	31 f0       	breq	.+12     	; 0x2a30 <__stack+0x931>
    2a24:	e1 30       	cpi	r30, 0x01	; 1
    2a26:	f1 05       	cpc	r31, r1
    2a28:	19 f0       	breq	.+6      	; 0x2a30 <__stack+0x931>
    2a2a:	e3 30       	cpi	r30, 0x03	; 3
    2a2c:	f1 05       	cpc	r31, r1
    2a2e:	29 f4       	brne	.+10     	; 0x2a3a <__stack+0x93b>
            setmode(KMODE_SYMBOLS);
    2a30:	82 e0       	ldi	r24, 0x02	; 2
    2a32:	90 e0       	ldi	r25, 0x00	; 0
    2a34:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z7setmodei>
    2a38:	06 c1       	rjmp	.+524    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_SYMBOLS, pos)) {
    2a3a:	32 97       	sbiw	r30, 0x02	; 2
    2a3c:	09 f0       	breq	.+2      	; 0x2a40 <__stack+0x941>
    2a3e:	c4 c0       	rjmp	.+392    	; 0x2bc8 <__stack+0xac9>
            setmode(KMODE_DEFAULT);
    2a40:	80 e0       	ldi	r24, 0x00	; 0
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z7setmodei>
    2a48:	fe c0       	rjmp	.+508    	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_A1) == KS1_A1 && (sensors2 & KS2_A1) == KS2_A1) {
    2a4a:	a1 fe       	sbrs	r10, 1
    2a4c:	1f c0       	rjmp	.+62     	; 0x2a8c <__stack+0x98d>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2a4e:	62 17       	cp	r22, r18
    2a50:	73 07       	cpc	r23, r19
    2a52:	0c f4       	brge	.+2      	; 0x2a56 <__stack+0x957>
    2a54:	f8 c0       	rjmp	.+496    	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2a56:	f8 01       	movw	r30, r16
    2a58:	e4 0f       	add	r30, r20
    2a5a:	f5 1f       	adc	r31, r21
    2a5c:	01 90       	ld	r0, Z+
    2a5e:	f0 81       	ld	r31, Z
    2a60:	e0 2d       	mov	r30, r0
        if (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos)) {
    2a62:	30 97       	sbiw	r30, 0x00	; 0
    2a64:	31 f0       	breq	.+12     	; 0x2a72 <__stack+0x973>
    2a66:	e2 30       	cpi	r30, 0x02	; 2
    2a68:	f1 05       	cpc	r31, r1
    2a6a:	19 f0       	breq	.+6      	; 0x2a72 <__stack+0x973>
    2a6c:	e3 30       	cpi	r30, 0x03	; 3
    2a6e:	f1 05       	cpc	r31, r1
    2a70:	29 f4       	brne	.+10     	; 0x2a7c <__stack+0x97d>
            setmode(KMODE_NUMBERS);
    2a72:	81 e0       	ldi	r24, 0x01	; 1
    2a74:	90 e0       	ldi	r25, 0x00	; 0
    2a76:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z7setmodei>
    2a7a:	e5 c0       	rjmp	.+458    	; 0x2c46 <__stack+0xb47>
            return;
         } else if (modeCheck(KMODE_NUMBERS, pos)) {
    2a7c:	31 97       	sbiw	r30, 0x01	; 1
    2a7e:	09 f0       	breq	.+2      	; 0x2a82 <__stack+0x983>
    2a80:	a3 c0       	rjmp	.+326    	; 0x2bc8 <__stack+0xac9>
            setmode(KMODE_DEFAULT);
    2a82:	80 e0       	ldi	r24, 0x00	; 0
    2a84:	90 e0       	ldi	r25, 0x00	; 0
    2a86:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z7setmodei>
    2a8a:	dd c0       	rjmp	.+442    	; 0x2c46 <__stack+0xb47>
            return;
         }
    } else if ((sensors1 & KS1_D3) == KS1_D3 && (sensors2 & KS2_D3) == KS2_D3 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2a8c:	a2 fe       	sbrs	r10, 2
    2a8e:	d0 c0       	rjmp	.+416    	; 0x2c30 <__stack+0xb31>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2a90:	62 17       	cp	r22, r18
    2a92:	73 07       	cpc	r23, r19
    2a94:	0c f4       	brge	.+2      	; 0x2a98 <__stack+0x999>
    2a96:	cc c0       	rjmp	.+408    	; 0x2c30 <__stack+0xb31>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2a98:	f8 01       	movw	r30, r16
    2a9a:	e4 0f       	add	r30, r20
    2a9c:	f5 1f       	adc	r31, r21
    2a9e:	01 90       	ld	r0, Z+
    2aa0:	f0 81       	ld	r31, Z
    2aa2:	e0 2d       	mov	r30, r0
    2aa4:	30 97       	sbiw	r30, 0x00	; 0
    2aa6:	09 f4       	brne	.+2      	; 0x2aaa <__stack+0x9ab>
    2aa8:	ce c0       	rjmp	.+412    	; 0x2c46 <__stack+0xb47>
    2aaa:	e1 30       	cpi	r30, 0x01	; 1
    2aac:	f1 05       	cpc	r31, r1
    2aae:	09 f4       	brne	.+2      	; 0x2ab2 <__stack+0x9b3>
    2ab0:	ca c0       	rjmp	.+404    	; 0x2c46 <__stack+0xb47>
    2ab2:	e2 30       	cpi	r30, 0x02	; 2
    2ab4:	f1 05       	cpc	r31, r1
    2ab6:	09 f4       	brne	.+2      	; 0x2aba <__stack+0x9bb>
    2ab8:	c6 c0       	rjmp	.+396    	; 0x2c46 <__stack+0xb47>
    2aba:	33 97       	sbiw	r30, 0x03	; 3
    2abc:	09 f4       	brne	.+2      	; 0x2ac0 <__stack+0x9c1>
    2abe:	c3 c0       	rjmp	.+390    	; 0x2c46 <__stack+0xb47>
    2ac0:	b7 c0       	rjmp	.+366    	; 0x2c30 <__stack+0xb31>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2ac2:	62 17       	cp	r22, r18
    2ac4:	73 07       	cpc	r23, r19
    2ac6:	0c f4       	brge	.+2      	; 0x2aca <__stack+0x9cb>
    2ac8:	b5 c0       	rjmp	.+362    	; 0x2c34 <__stack+0xb35>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2aca:	f8 01       	movw	r30, r16
    2acc:	e4 0f       	add	r30, r20
    2ace:	f5 1f       	adc	r31, r21
    2ad0:	01 90       	ld	r0, Z+
    2ad2:	f0 81       	ld	r31, Z
    2ad4:	e0 2d       	mov	r30, r0
        // UNKNOWN: array (   'action' => 'togglemodifier',   'code' => 'MODIFIERKEY_ALT', )
        return;
    } else if ((sensors1 & KS1_D2) == KS1_D2 && (sensors2 & KS2_D2) == KS2_D2 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2ad6:	30 97       	sbiw	r30, 0x00	; 0
    2ad8:	09 f4       	brne	.+2      	; 0x2adc <__stack+0x9dd>
    2ada:	b5 c0       	rjmp	.+362    	; 0x2c46 <__stack+0xb47>
    2adc:	e1 30       	cpi	r30, 0x01	; 1
    2ade:	f1 05       	cpc	r31, r1
    2ae0:	09 f4       	brne	.+2      	; 0x2ae4 <__stack+0x9e5>
    2ae2:	b1 c0       	rjmp	.+354    	; 0x2c46 <__stack+0xb47>
    2ae4:	e2 30       	cpi	r30, 0x02	; 2
    2ae6:	f1 05       	cpc	r31, r1
    2ae8:	09 f4       	brne	.+2      	; 0x2aec <__stack+0x9ed>
    2aea:	ad c0       	rjmp	.+346    	; 0x2c46 <__stack+0xb47>
    2aec:	33 97       	sbiw	r30, 0x03	; 3
    2aee:	09 f4       	brne	.+2      	; 0x2af2 <__stack+0x9f3>
    2af0:	aa c0       	rjmp	.+340    	; 0x2c46 <__stack+0xb47>
    2af2:	a0 c0       	rjmp	.+320    	; 0x2c34 <__stack+0xb35>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2af4:	62 17       	cp	r22, r18
    2af6:	73 07       	cpc	r23, r19
    2af8:	0c f4       	brge	.+2      	; 0x2afc <__stack+0x9fd>
    2afa:	9e c0       	rjmp	.+316    	; 0x2c38 <__stack+0xb39>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2afc:	f8 01       	movw	r30, r16
    2afe:	e4 0f       	add	r30, r20
    2b00:	f5 1f       	adc	r31, r21
    2b02:	01 90       	ld	r0, Z+
    2b04:	f0 81       	ld	r31, Z
    2b06:	e0 2d       	mov	r30, r0
        // UNKNOWN: array (   'action' => 'togglemodifier',   'code' => 'MODIFIERKEY_CTRL', )
        return;
    } else if ((sensors1 & KS1_D1) == KS1_D1 && (sensors2 & KS2_D1) == KS2_D1 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2b08:	30 97       	sbiw	r30, 0x00	; 0
    2b0a:	09 f4       	brne	.+2      	; 0x2b0e <__stack+0xa0f>
    2b0c:	9c c0       	rjmp	.+312    	; 0x2c46 <__stack+0xb47>
    2b0e:	e1 30       	cpi	r30, 0x01	; 1
    2b10:	f1 05       	cpc	r31, r1
    2b12:	09 f4       	brne	.+2      	; 0x2b16 <__stack+0xa17>
    2b14:	98 c0       	rjmp	.+304    	; 0x2c46 <__stack+0xb47>
    2b16:	e2 30       	cpi	r30, 0x02	; 2
    2b18:	f1 05       	cpc	r31, r1
    2b1a:	09 f4       	brne	.+2      	; 0x2b1e <__stack+0xa1f>
    2b1c:	94 c0       	rjmp	.+296    	; 0x2c46 <__stack+0xb47>
    2b1e:	33 97       	sbiw	r30, 0x03	; 3
    2b20:	09 f4       	brne	.+2      	; 0x2b24 <__stack+0xa25>
    2b22:	91 c0       	rjmp	.+290    	; 0x2c46 <__stack+0xb47>
    2b24:	89 c0       	rjmp	.+274    	; 0x2c38 <__stack+0xb39>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2b26:	62 17       	cp	r22, r18
    2b28:	73 07       	cpc	r23, r19
    2b2a:	0c f4       	brge	.+2      	; 0x2b2e <__stack+0xa2f>
    2b2c:	87 c0       	rjmp	.+270    	; 0x2c3c <__stack+0xb3d>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2b2e:	f8 01       	movw	r30, r16
    2b30:	e4 0f       	add	r30, r20
    2b32:	f5 1f       	adc	r31, r21
    2b34:	01 90       	ld	r0, Z+
    2b36:	f0 81       	ld	r31, Z
    2b38:	e0 2d       	mov	r30, r0
        // UNKNOWN: array (   'action' => 'togglemodifier',   'code' => 'MODIFIERKEY_SHIFT', )
        return;
    } else if ((sensors1 & KS1_J3) == KS1_J3 && (sensors2 & KS2_J3) == KS2_J3 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2b3a:	30 97       	sbiw	r30, 0x00	; 0
    2b3c:	49 f0       	breq	.+18     	; 0x2b50 <__stack+0xa51>
    2b3e:	e1 30       	cpi	r30, 0x01	; 1
    2b40:	f1 05       	cpc	r31, r1
    2b42:	31 f0       	breq	.+12     	; 0x2b50 <__stack+0xa51>
    2b44:	e2 30       	cpi	r30, 0x02	; 2
    2b46:	f1 05       	cpc	r31, r1
    2b48:	19 f0       	breq	.+6      	; 0x2b50 <__stack+0xa51>
    2b4a:	33 97       	sbiw	r30, 0x03	; 3
    2b4c:	09 f0       	breq	.+2      	; 0x2b50 <__stack+0xa51>
    2b4e:	76 c0       	rjmp	.+236    	; 0x2c3c <__stack+0xb3d>
        mouseup(KMOUSE_RIGHT);
    2b50:	84 e0       	ldi	r24, 0x04	; 4
    2b52:	90 e0       	ldi	r25, 0x00	; 0
    2b54:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_Z7mouseupi>
    2b58:	76 c0       	rjmp	.+236    	; 0x2c46 <__stack+0xb47>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2b5a:	62 17       	cp	r22, r18
    2b5c:	73 07       	cpc	r23, r19
    2b5e:	0c f4       	brge	.+2      	; 0x2b62 <__stack+0xa63>
    2b60:	6f c0       	rjmp	.+222    	; 0x2c40 <__stack+0xb41>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2b62:	f8 01       	movw	r30, r16
    2b64:	e4 0f       	add	r30, r20
    2b66:	f5 1f       	adc	r31, r21
    2b68:	01 90       	ld	r0, Z+
    2b6a:	f0 81       	ld	r31, Z
    2b6c:	e0 2d       	mov	r30, r0
        return;
    } else if ((sensors1 & KS1_J2) == KS1_J2 && (sensors2 & KS2_J2) == KS2_J2 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2b6e:	30 97       	sbiw	r30, 0x00	; 0
    2b70:	49 f0       	breq	.+18     	; 0x2b84 <__stack+0xa85>
    2b72:	e1 30       	cpi	r30, 0x01	; 1
    2b74:	f1 05       	cpc	r31, r1
    2b76:	31 f0       	breq	.+12     	; 0x2b84 <__stack+0xa85>
    2b78:	e2 30       	cpi	r30, 0x02	; 2
    2b7a:	f1 05       	cpc	r31, r1
    2b7c:	19 f0       	breq	.+6      	; 0x2b84 <__stack+0xa85>
    2b7e:	33 97       	sbiw	r30, 0x03	; 3
    2b80:	09 f0       	breq	.+2      	; 0x2b84 <__stack+0xa85>
    2b82:	5e c0       	rjmp	.+188    	; 0x2c40 <__stack+0xb41>
        mouseup(KMOUSE_MIDDLE);
    2b84:	82 e0       	ldi	r24, 0x02	; 2
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_Z7mouseupi>
    2b8c:	5c c0       	rjmp	.+184    	; 0x2c46 <__stack+0xb47>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2b8e:	62 17       	cp	r22, r18
    2b90:	73 07       	cpc	r23, r19
    2b92:	0c f4       	brge	.+2      	; 0x2b96 <__stack+0xa97>
    2b94:	58 c0       	rjmp	.+176    	; 0x2c46 <__stack+0xb47>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2b96:	f8 01       	movw	r30, r16
    2b98:	e4 0f       	add	r30, r20
    2b9a:	f5 1f       	adc	r31, r21
    2b9c:	01 90       	ld	r0, Z+
    2b9e:	f0 81       	ld	r31, Z
    2ba0:	e0 2d       	mov	r30, r0
        return;
    } else if ((sensors1 & KS1_J1) == KS1_J1 && (sensors2 & KS2_J1) == KS2_J1 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2ba2:	30 97       	sbiw	r30, 0x00	; 0
    2ba4:	41 f0       	breq	.+16     	; 0x2bb6 <__stack+0xab7>
    2ba6:	e1 30       	cpi	r30, 0x01	; 1
    2ba8:	f1 05       	cpc	r31, r1
    2baa:	29 f0       	breq	.+10     	; 0x2bb6 <__stack+0xab7>
    2bac:	e2 30       	cpi	r30, 0x02	; 2
    2bae:	f1 05       	cpc	r31, r1
    2bb0:	11 f0       	breq	.+4      	; 0x2bb6 <__stack+0xab7>
    2bb2:	33 97       	sbiw	r30, 0x03	; 3
    2bb4:	49 f4       	brne	.+18     	; 0x2bc8 <__stack+0xac9>
        mouseup(KMOUSE_LEFT);
    2bb6:	81 e0       	ldi	r24, 0x01	; 1
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_Z7mouseupi>
    2bbe:	43 c0       	rjmp	.+134    	; 0x2c46 <__stack+0xb47>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2bc0:	62 17       	cp	r22, r18
    2bc2:	73 07       	cpc	r23, r19
    2bc4:	0c f4       	brge	.+2      	; 0x2bc8 <__stack+0xac9>
    2bc6:	3f c0       	rjmp	.+126    	; 0x2c46 <__stack+0xb47>
        check_sensors_touch(sensors1, sensors2, pos + 1);
        return;
    }
}
 
void check_sensors_release(long unsigned int sensors1, long unsigned int sensors2, int pos) {
    2bc8:	f8 01       	movw	r30, r16
    2bca:	e4 0f       	add	r30, r20
    2bcc:	f5 1f       	adc	r31, r21
        mouseup(KMOUSE_LEFT);
        return;
    }
 
    /* Fall throughs */
    if (modeCheck(KMODE_GUI, pos) && modeCheck(KMODE_DEFAULT, pos + 1)) {
    2bce:	80 81       	ld	r24, Z
    2bd0:	91 81       	ldd	r25, Z+1	; 0x01
    2bd2:	04 97       	sbiw	r24, 0x04	; 4
    2bd4:	c1 f5       	brne	.+112    	; 0x2c46 <__stack+0xb47>
    2bd6:	2f 5f       	subi	r18, 0xFF	; 255
    2bd8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bda:	62 17       	cp	r22, r18
    2bdc:	73 07       	cpc	r23, r19
    2bde:	9c f1       	brlt	.+102    	; 0x2c46 <__stack+0xb47>
    2be0:	42 50       	subi	r20, 0x02	; 2
    2be2:	50 40       	sbci	r21, 0x00	; 0
    2be4:	32 97       	sbiw	r30, 0x02	; 2
    2be6:	80 81       	ld	r24, Z
    2be8:	91 81       	ldd	r25, Z+1	; 0x01
    2bea:	89 2b       	or	r24, r25
    2bec:	11 f4       	brne	.+4      	; 0x2bf2 <__stack+0xaf3>
    2bee:	0c 94 17 0b 	jmp	0x162e	; 0x162e <_Z21check_sensors_releasemmi+0x204>
    2bf2:	29 c0       	rjmp	.+82     	; 0x2c46 <__stack+0xb47>
    2bf4:	62 17       	cp	r22, r18
    2bf6:	73 07       	cpc	r23, r19
    2bf8:	14 f0       	brlt	.+4      	; 0x2bfe <__stack+0xaff>
    2bfa:	0c 94 c0 0b 	jmp	0x1780	; 0x1780 <_Z21check_sensors_releasemmi+0x356>
    2bfe:	23 c0       	rjmp	.+70     	; 0x2c46 <__stack+0xb47>
        keypress(KEY_V);
        modifierup(MODIFIERKEY_SHIFT);
        modifierup(MODIFIERKEY_CTRL);
        modifierup(MODIFIERKEY_ALT);
        return;
    } else if ((sensors1 & KS1_D8) == KS1_D8 && (sensors2 & KS2_D8) == KS2_D8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2c00:	8d a9       	ldd	r24, Y+53	; 0x35
    2c02:	9e a9       	ldd	r25, Y+54	; 0x36
    2c04:	af a9       	ldd	r26, Y+55	; 0x37
    2c06:	b8 ad       	ldd	r27, Y+56	; 0x38
    2c08:	00 97       	sbiw	r24, 0x00	; 0
    2c0a:	a1 05       	cpc	r26, r1
    2c0c:	b1 05       	cpc	r27, r1
    2c0e:	09 f0       	breq	.+2      	; 0x2c12 <__stack+0xb13>
    2c10:	3e ca       	rjmp	.-2948   	; 0x208e <_Z21check_sensors_releasemmi+0xc64>
        mouseoff(KMOUSE_SCROLL);
        return;
    } else if ((sensors1 & KS1_DY) == KS1_DY && (sensors2 & KS2_DY) == KS2_DY) {
    2c12:	89 ad       	ldd	r24, Y+57	; 0x39
    2c14:	9a ad       	ldd	r25, Y+58	; 0x3a
    2c16:	ab ad       	ldd	r26, Y+59	; 0x3b
    2c18:	bc ad       	ldd	r27, Y+60	; 0x3c
    2c1a:	00 97       	sbiw	r24, 0x00	; 0
    2c1c:	a1 05       	cpc	r26, r1
    2c1e:	b1 05       	cpc	r27, r1
    2c20:	09 f0       	breq	.+2      	; 0x2c24 <__stack+0xb25>
    2c22:	4f ca       	rjmp	.-2914   	; 0x20c2 <_Z21check_sensors_releasemmi+0xc98>
    2c24:	de ca       	rjmp	.-2628   	; 0x21e2 <__stack+0xe3>
        keypress(KEY_J);
        modifierup(MODIFIERKEY_SHIFT);
        modifierup(MODIFIERKEY_CTRL);
        modifierup(MODIFIERKEY_ALT);
        return;
    } else if ((sensors1 & KS1_A8) == KS1_A8 && (sensors2 & KS2_A8) == KS2_A8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2c26:	85 fc       	sbrc	r8, 5
    2c28:	b9 cc       	rjmp	.-1678   	; 0x259c <__stack+0x49d>
        mouseoff(KMOUSE_MOVE);
        return;
    } else if ((sensors1 & KS1_MY) == KS1_MY && (sensors2 & KS2_MY) == KS2_MY) {
    2c2a:	86 fc       	sbrc	r8, 6
    2c2c:	d1 cc       	rjmp	.-1630   	; 0x25d0 <__stack+0x4d1>
    2c2e:	19 cd       	rjmp	.-1486   	; 0x2662 <__stack+0x563>
            return;
         }
    } else if ((sensors1 & KS1_D3) == KS1_D3 && (sensors2 & KS2_D3) == KS2_D3 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
        // UNKNOWN: array (   'action' => 'togglemodifier',   'code' => 'MODIFIERKEY_ALT', )
        return;
    } else if ((sensors1 & KS1_D2) == KS1_D2 && (sensors2 & KS2_D2) == KS2_D2 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2c30:	a3 fc       	sbrc	r10, 3
    2c32:	47 cf       	rjmp	.-370    	; 0x2ac2 <__stack+0x9c3>
        // UNKNOWN: array (   'action' => 'togglemodifier',   'code' => 'MODIFIERKEY_CTRL', )
        return;
    } else if ((sensors1 & KS1_D1) == KS1_D1 && (sensors2 & KS2_D1) == KS2_D1 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2c34:	a4 fc       	sbrc	r10, 4
    2c36:	5e cf       	rjmp	.-324    	; 0x2af4 <__stack+0x9f5>
        // UNKNOWN: array (   'action' => 'togglemodifier',   'code' => 'MODIFIERKEY_SHIFT', )
        return;
    } else if ((sensors1 & KS1_J3) == KS1_J3 && (sensors2 & KS2_J3) == KS2_J3 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2c38:	b0 fc       	sbrc	r11, 0
    2c3a:	75 cf       	rjmp	.-278    	; 0x2b26 <__stack+0xa27>
        mouseup(KMOUSE_RIGHT);
        return;
    } else if ((sensors1 & KS1_J2) == KS1_J2 && (sensors2 & KS2_J2) == KS2_J2 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2c3c:	b1 fc       	sbrc	r11, 1
    2c3e:	8d cf       	rjmp	.-230    	; 0x2b5a <__stack+0xa5b>
        mouseup(KMOUSE_MIDDLE);
        return;
    } else if ((sensors1 & KS1_J1) == KS1_J1 && (sensors2 & KS2_J1) == KS2_J1 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2c40:	b2 fe       	sbrs	r11, 2
    2c42:	be cf       	rjmp	.-132    	; 0x2bc0 <__stack+0xac1>
    2c44:	a4 cf       	rjmp	.-184    	; 0x2b8e <__stack+0xa8f>
    /* Fall throughs */
    if (modeCheck(KMODE_GUI, pos) && modeCheck(KMODE_DEFAULT, pos + 1)) {
        check_sensors_release(sensors1, sensors2, pos + 1);
        return;
    }
}
    2c46:	c4 5b       	subi	r28, 0xB4	; 180
    2c48:	df 4f       	sbci	r29, 0xFF	; 255
    2c4a:	0f b6       	in	r0, 0x3f	; 63
    2c4c:	f8 94       	cli
    2c4e:	de bf       	out	0x3e, r29	; 62
    2c50:	0f be       	out	0x3f, r0	; 63
    2c52:	cd bf       	out	0x3d, r28	; 61
    2c54:	cf 91       	pop	r28
    2c56:	df 91       	pop	r29
    2c58:	1f 91       	pop	r17
    2c5a:	0f 91       	pop	r16
    2c5c:	ff 90       	pop	r15
    2c5e:	ef 90       	pop	r14
    2c60:	df 90       	pop	r13
    2c62:	cf 90       	pop	r12
    2c64:	bf 90       	pop	r11
    2c66:	af 90       	pop	r10
    2c68:	9f 90       	pop	r9
    2c6a:	8f 90       	pop	r8
    2c6c:	7f 90       	pop	r7
    2c6e:	6f 90       	pop	r6
    2c70:	5f 90       	pop	r5
    2c72:	4f 90       	pop	r4
    2c74:	08 95       	ret

00002c76 <_Z9mousedowni>:
        } else if (mode == KMOUSE_SCROLL) {
            opt_scroll_mode = 0;
        }
    }
    
    void mousedown(int button) {
    2c76:	0f 93       	push	r16
    2c78:	1f 93       	push	r17
    2c7a:	8c 01       	movw	r16, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset mousedown ");
    2c7c:	80 ef       	ldi	r24, 0xF0	; 240
    2c7e:	98 e0       	ldi	r25, 0x08	; 8
    2c80:	6c e8       	ldi	r22, 0x8C	; 140
    2c82:	72 e0       	ldi	r23, 0x02	; 2
    2c84:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(button);
    2c88:	80 ef       	ldi	r24, 0xF0	; 240
    2c8a:	98 e0       	ldi	r25, 0x08	; 8
    2c8c:	b8 01       	movw	r22, r16
    2c8e:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        mouseDown = mouseDown | button;
    2c92:	20 91 9d 08 	lds	r18, 0x089D
    2c96:	30 91 9e 08 	lds	r19, 0x089E
    2c9a:	20 2b       	or	r18, r16
    2c9c:	31 2b       	or	r19, r17
    2c9e:	30 93 9e 08 	sts	0x089E, r19
    2ca2:	20 93 9d 08 	sts	0x089D, r18
        #ifdef ENABLE_USB
            Mouse.set_buttons((mouseDown & 1) > 0 ? 1 : 0, (mouseDown & 2) > 0 ? 1 : 0, (mouseDown & 4) > 0 ? 1 : 0);
    2ca6:	60 e0       	ldi	r22, 0x00	; 0
    2ca8:	20 fd       	sbrc	r18, 0
    2caa:	61 e0       	ldi	r22, 0x01	; 1
    2cac:	36 95       	lsr	r19
    2cae:	27 95       	ror	r18
    2cb0:	42 2f       	mov	r20, r18
    2cb2:	41 70       	andi	r20, 0x01	; 1
    2cb4:	36 95       	lsr	r19
    2cb6:	27 95       	ror	r18
    2cb8:	21 70       	andi	r18, 0x01	; 1
    2cba:	80 e1       	ldi	r24, 0x10	; 16
    2cbc:	99 e0       	ldi	r25, 0x09	; 9
    2cbe:	0e 94 87 2d 	call	0x5b0e	; 0x5b0e <_ZN8USBMouse11set_buttonsEhhh>
        #endif /* ENABLE_USB */
        #ifdef ENABLE_RX400
            RX400.set_buttons((mouseDown & 1) > 0 ? 1 : 0, (mouseDown & 2) > 0 ? 1 : 0, (mouseDown & 4) > 0 ? 1 : 0);
        #endif /* ENABLE_RX400 */
    }
    2cc2:	1f 91       	pop	r17
    2cc4:	0f 91       	pop	r16
    2cc6:	08 95       	ret

00002cc8 <_Z19check_sensors_touchmmi>:
#define KS2_J2 0x2000000
 
#define KS1_J1 0x0
#define KS2_J1 0x4000000
 
void check_sensors_touch(long unsigned int sensors1, long unsigned int sensors2, int pos) {
    2cc8:	2f 92       	push	r2
    2cca:	3f 92       	push	r3
    2ccc:	4f 92       	push	r4
    2cce:	5f 92       	push	r5
    2cd0:	6f 92       	push	r6
    2cd2:	7f 92       	push	r7
    2cd4:	8f 92       	push	r8
    2cd6:	9f 92       	push	r9
    2cd8:	af 92       	push	r10
    2cda:	bf 92       	push	r11
    2cdc:	cf 92       	push	r12
    2cde:	df 92       	push	r13
    2ce0:	ef 92       	push	r14
    2ce2:	ff 92       	push	r15
    2ce4:	0f 93       	push	r16
    2ce6:	1f 93       	push	r17
    2ce8:	df 93       	push	r29
    2cea:	cf 93       	push	r28
    2cec:	cd b7       	in	r28, 0x3d	; 61
    2cee:	de b7       	in	r29, 0x3e	; 62
    2cf0:	62 97       	sbiw	r28, 0x12	; 18
    2cf2:	0f b6       	in	r0, 0x3f	; 63
    2cf4:	f8 94       	cli
    2cf6:	de bf       	out	0x3e, r29	; 62
    2cf8:	0f be       	out	0x3f, r0	; 63
    2cfa:	cd bf       	out	0x3d, r28	; 61
    2cfc:	6b 01       	movw	r12, r22
    2cfe:	7c 01       	movw	r14, r24
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2d00:	60 91 b3 08 	lds	r22, 0x08B3
    2d04:	70 91 b4 08 	lds	r23, 0x08B4
    2d08:	7a 8b       	std	Y+18, r23	; 0x12
    2d0a:	69 8b       	std	Y+17, r22	; 0x11
    2d0c:	c8 01       	movw	r24, r16
    2d0e:	80 95       	com	r24
    2d10:	90 95       	com	r25
    2d12:	86 0f       	add	r24, r22
    2d14:	97 1f       	adc	r25, r23
    2d16:	88 0f       	add	r24, r24
    2d18:	99 1f       	adc	r25, r25
    2d1a:	81 56       	subi	r24, 0x61	; 97
    2d1c:	97 4f       	sbci	r25, 0xF7	; 247
    2d1e:	98 8b       	std	Y+16, r25	; 0x10
    2d20:	8f 87       	std	Y+15, r24	; 0x0f
    2d22:	60 1b       	sub	r22, r16
    2d24:	71 0b       	sbc	r23, r17
    2d26:	66 0f       	add	r22, r22
    2d28:	77 1f       	adc	r23, r23
    2d2a:	61 56       	subi	r22, 0x61	; 97
    2d2c:	77 4f       	sbci	r23, 0xF7	; 247
    2d2e:	7e 87       	std	Y+14, r23	; 0x0e
    2d30:	6d 87       	std	Y+13, r22	; 0x0d
    2d32:	2b 01       	movw	r4, r22
    2d34:	3b 01       	movw	r6, r22
    2d36:	4b 01       	movw	r8, r22
    2d38:	5b 01       	movw	r10, r22
    2d3a:	1b 01       	movw	r2, r22
    if ((sensors1 & KS1_D8) == KS1_D8 && (sensors2 & KS2_D8) == KS2_D8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2d3c:	60 e0       	ldi	r22, 0x00	; 0
    2d3e:	70 e0       	ldi	r23, 0x00	; 0
    2d40:	80 e2       	ldi	r24, 0x20	; 32
    2d42:	90 e0       	ldi	r25, 0x00	; 0
    2d44:	c6 22       	and	r12, r22
    2d46:	d7 22       	and	r13, r23
    2d48:	e8 22       	and	r14, r24
    2d4a:	f9 22       	and	r15, r25
        mouseon(KMOUSE_SCROLL);
        return;
    } else if ((sensors1 & KS1_A8) == KS1_A8 && (sensors2 & KS2_A8) == KS2_A8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2d4c:	da 01       	movw	r26, r20
    2d4e:	c9 01       	movw	r24, r18
    2d50:	80 72       	andi	r24, 0x20	; 32
    2d52:	90 70       	andi	r25, 0x00	; 0
    2d54:	a0 70       	andi	r26, 0x00	; 0
    2d56:	b0 70       	andi	r27, 0x00	; 0
    2d58:	89 83       	std	Y+1, r24	; 0x01
    2d5a:	9a 83       	std	Y+2, r25	; 0x02
    2d5c:	ab 83       	std	Y+3, r26	; 0x03
    2d5e:	bc 83       	std	Y+4, r27	; 0x04
        mouseon(KMOUSE_MOVE);
        return;
    } else if ((sensors1 & KS1_J3) == KS1_J3 && (sensors2 & KS2_J3) == KS2_J3 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2d60:	ca 01       	movw	r24, r20
    2d62:	b9 01       	movw	r22, r18
    2d64:	60 70       	andi	r22, 0x00	; 0
    2d66:	70 70       	andi	r23, 0x00	; 0
    2d68:	80 70       	andi	r24, 0x00	; 0
    2d6a:	91 70       	andi	r25, 0x01	; 1
    2d6c:	6d 83       	std	Y+5, r22	; 0x05
    2d6e:	7e 83       	std	Y+6, r23	; 0x06
    2d70:	8f 83       	std	Y+7, r24	; 0x07
    2d72:	98 87       	std	Y+8, r25	; 0x08
        mousedown(KMOUSE_RIGHT);
        return;
    } else if ((sensors1 & KS1_J2) == KS1_J2 && (sensors2 & KS2_J2) == KS2_J2 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2d74:	da 01       	movw	r26, r20
    2d76:	c9 01       	movw	r24, r18
    2d78:	80 70       	andi	r24, 0x00	; 0
    2d7a:	90 70       	andi	r25, 0x00	; 0
    2d7c:	a0 70       	andi	r26, 0x00	; 0
    2d7e:	b2 70       	andi	r27, 0x02	; 2
    2d80:	89 87       	std	Y+9, r24	; 0x09
    2d82:	9a 87       	std	Y+10, r25	; 0x0a
    2d84:	ab 87       	std	Y+11, r26	; 0x0b
    2d86:	bc 87       	std	Y+12, r27	; 0x0c
        mousedown(KMOUSE_MIDDLE);
        return;
    } else if ((sensors1 & KS1_J1) == KS1_J1 && (sensors2 & KS2_J1) == KS2_J1 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2d88:	20 70       	andi	r18, 0x00	; 0
    2d8a:	30 70       	andi	r19, 0x00	; 0
    2d8c:	40 70       	andi	r20, 0x00	; 0
    2d8e:	54 70       	andi	r21, 0x04	; 4
 
#define KS1_J1 0x0
#define KS2_J1 0x4000000
 
void check_sensors_touch(long unsigned int sensors1, long unsigned int sensors2, int pos) {
    if ((sensors1 & KS1_D8) == KS1_D8 && (sensors2 & KS2_D8) == KS2_D8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2d90:	c1 14       	cp	r12, r1
    2d92:	d1 04       	cpc	r13, r1
    2d94:	e1 04       	cpc	r14, r1
    2d96:	f1 04       	cpc	r15, r1
    2d98:	09 f4       	brne	.+2      	; 0x2d9c <_Z19check_sensors_touchmmi+0xd4>
    2d9a:	a2 c0       	rjmp	.+324    	; 0x2ee0 <_Z19check_sensors_touchmmi+0x218>
    2d9c:	a9 89       	ldd	r26, Y+17	; 0x11
    2d9e:	ba 89       	ldd	r27, Y+18	; 0x12
    2da0:	a0 17       	cp	r26, r16
    2da2:	b1 07       	cpc	r27, r17
    2da4:	0c f4       	brge	.+2      	; 0x2da8 <_Z19check_sensors_touchmmi+0xe0>
    2da6:	9c c0       	rjmp	.+312    	; 0x2ee0 <_Z19check_sensors_touchmmi+0x218>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2da8:	f3 01       	movw	r30, r6
    2daa:	80 81       	ld	r24, Z
    2dac:	91 81       	ldd	r25, Z+1	; 0x01
    2dae:	00 97       	sbiw	r24, 0x00	; 0
    2db0:	49 f0       	breq	.+18     	; 0x2dc4 <_Z19check_sensors_touchmmi+0xfc>
    2db2:	81 30       	cpi	r24, 0x01	; 1
    2db4:	91 05       	cpc	r25, r1
    2db6:	31 f0       	breq	.+12     	; 0x2dc4 <_Z19check_sensors_touchmmi+0xfc>
    2db8:	82 30       	cpi	r24, 0x02	; 2
    2dba:	91 05       	cpc	r25, r1
    2dbc:	19 f0       	breq	.+6      	; 0x2dc4 <_Z19check_sensors_touchmmi+0xfc>
    2dbe:	03 97       	sbiw	r24, 0x03	; 3
    2dc0:	09 f0       	breq	.+2      	; 0x2dc4 <_Z19check_sensors_touchmmi+0xfc>
    2dc2:	8e c0       	rjmp	.+284    	; 0x2ee0 <_Z19check_sensors_touchmmi+0x218>
        mouseon(KMOUSE_SCROLL);
    2dc4:	81 e0       	ldi	r24, 0x01	; 1
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
    2dc8:	16 c0       	rjmp	.+44     	; 0x2df6 <_Z19check_sensors_touchmmi+0x12e>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2dca:	69 89       	ldd	r22, Y+17	; 0x11
    2dcc:	7a 89       	ldd	r23, Y+18	; 0x12
    2dce:	60 17       	cp	r22, r16
    2dd0:	71 07       	cpc	r23, r17
    2dd2:	0c f4       	brge	.+2      	; 0x2dd6 <_Z19check_sensors_touchmmi+0x10e>
    2dd4:	8e c0       	rjmp	.+284    	; 0x2ef2 <_Z19check_sensors_touchmmi+0x22a>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2dd6:	d4 01       	movw	r26, r8
    2dd8:	8d 91       	ld	r24, X+
    2dda:	9c 91       	ld	r25, X
        return;
    } else if ((sensors1 & KS1_A8) == KS1_A8 && (sensors2 & KS2_A8) == KS2_A8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2ddc:	00 97       	sbiw	r24, 0x00	; 0
    2dde:	49 f0       	breq	.+18     	; 0x2df2 <_Z19check_sensors_touchmmi+0x12a>
    2de0:	81 30       	cpi	r24, 0x01	; 1
    2de2:	91 05       	cpc	r25, r1
    2de4:	31 f0       	breq	.+12     	; 0x2df2 <_Z19check_sensors_touchmmi+0x12a>
    2de6:	82 30       	cpi	r24, 0x02	; 2
    2de8:	91 05       	cpc	r25, r1
    2dea:	19 f0       	breq	.+6      	; 0x2df2 <_Z19check_sensors_touchmmi+0x12a>
    2dec:	03 97       	sbiw	r24, 0x03	; 3
    2dee:	09 f0       	breq	.+2      	; 0x2df2 <_Z19check_sensors_touchmmi+0x12a>
    2df0:	80 c0       	rjmp	.+256    	; 0x2ef2 <_Z19check_sensors_touchmmi+0x22a>
        mouseon(KMOUSE_MOVE);
    2df2:	80 e0       	ldi	r24, 0x00	; 0
    2df4:	90 e0       	ldi	r25, 0x00	; 0
    2df6:	0e 94 1d 04 	call	0x83a	; 0x83a <_Z7mouseoni>
    2dfa:	9a c0       	rjmp	.+308    	; 0x2f30 <_Z19check_sensors_touchmmi+0x268>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2dfc:	e9 89       	ldd	r30, Y+17	; 0x11
    2dfe:	fa 89       	ldd	r31, Y+18	; 0x12
    2e00:	e0 17       	cp	r30, r16
    2e02:	f1 07       	cpc	r31, r17
    2e04:	0c f4       	brge	.+2      	; 0x2e08 <_Z19check_sensors_touchmmi+0x140>
    2e06:	7f c0       	rjmp	.+254    	; 0x2f06 <_Z19check_sensors_touchmmi+0x23e>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2e08:	ad 85       	ldd	r26, Y+13	; 0x0d
    2e0a:	be 85       	ldd	r27, Y+14	; 0x0e
    2e0c:	8d 91       	ld	r24, X+
    2e0e:	9c 91       	ld	r25, X
        return;
    } else if ((sensors1 & KS1_J3) == KS1_J3 && (sensors2 & KS2_J3) == KS2_J3 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2e10:	00 97       	sbiw	r24, 0x00	; 0
    2e12:	49 f0       	breq	.+18     	; 0x2e26 <_Z19check_sensors_touchmmi+0x15e>
    2e14:	81 30       	cpi	r24, 0x01	; 1
    2e16:	91 05       	cpc	r25, r1
    2e18:	31 f0       	breq	.+12     	; 0x2e26 <_Z19check_sensors_touchmmi+0x15e>
    2e1a:	82 30       	cpi	r24, 0x02	; 2
    2e1c:	91 05       	cpc	r25, r1
    2e1e:	19 f0       	breq	.+6      	; 0x2e26 <_Z19check_sensors_touchmmi+0x15e>
    2e20:	03 97       	sbiw	r24, 0x03	; 3
    2e22:	09 f0       	breq	.+2      	; 0x2e26 <_Z19check_sensors_touchmmi+0x15e>
    2e24:	70 c0       	rjmp	.+224    	; 0x2f06 <_Z19check_sensors_touchmmi+0x23e>
        mousedown(KMOUSE_RIGHT);
    2e26:	84 e0       	ldi	r24, 0x04	; 4
    2e28:	90 e0       	ldi	r25, 0x00	; 0
    2e2a:	2c c0       	rjmp	.+88     	; 0x2e84 <_Z19check_sensors_touchmmi+0x1bc>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2e2c:	e9 89       	ldd	r30, Y+17	; 0x11
    2e2e:	fa 89       	ldd	r31, Y+18	; 0x12
    2e30:	e0 17       	cp	r30, r16
    2e32:	f1 07       	cpc	r31, r17
    2e34:	0c f4       	brge	.+2      	; 0x2e38 <_Z19check_sensors_touchmmi+0x170>
    2e36:	70 c0       	rjmp	.+224    	; 0x2f18 <_Z19check_sensors_touchmmi+0x250>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2e38:	d5 01       	movw	r26, r10
    2e3a:	8d 91       	ld	r24, X+
    2e3c:	9c 91       	ld	r25, X
        return;
    } else if ((sensors1 & KS1_J2) == KS1_J2 && (sensors2 & KS2_J2) == KS2_J2 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2e3e:	00 97       	sbiw	r24, 0x00	; 0
    2e40:	49 f0       	breq	.+18     	; 0x2e54 <_Z19check_sensors_touchmmi+0x18c>
    2e42:	81 30       	cpi	r24, 0x01	; 1
    2e44:	91 05       	cpc	r25, r1
    2e46:	31 f0       	breq	.+12     	; 0x2e54 <_Z19check_sensors_touchmmi+0x18c>
    2e48:	82 30       	cpi	r24, 0x02	; 2
    2e4a:	91 05       	cpc	r25, r1
    2e4c:	19 f0       	breq	.+6      	; 0x2e54 <_Z19check_sensors_touchmmi+0x18c>
    2e4e:	03 97       	sbiw	r24, 0x03	; 3
    2e50:	09 f0       	breq	.+2      	; 0x2e54 <_Z19check_sensors_touchmmi+0x18c>
    2e52:	62 c0       	rjmp	.+196    	; 0x2f18 <_Z19check_sensors_touchmmi+0x250>
        mousedown(KMOUSE_MIDDLE);
    2e54:	82 e0       	ldi	r24, 0x02	; 2
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	15 c0       	rjmp	.+42     	; 0x2e84 <_Z19check_sensors_touchmmi+0x1bc>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2e5a:	e9 89       	ldd	r30, Y+17	; 0x11
    2e5c:	fa 89       	ldd	r31, Y+18	; 0x12
    2e5e:	e0 17       	cp	r30, r16
    2e60:	f1 07       	cpc	r31, r17
    2e62:	0c f4       	brge	.+2      	; 0x2e66 <_Z19check_sensors_touchmmi+0x19e>
    2e64:	65 c0       	rjmp	.+202    	; 0x2f30 <_Z19check_sensors_touchmmi+0x268>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2e66:	d1 01       	movw	r26, r2
    2e68:	8d 91       	ld	r24, X+
    2e6a:	9c 91       	ld	r25, X
        return;
    } else if ((sensors1 & KS1_J1) == KS1_J1 && (sensors2 & KS2_J1) == KS2_J1 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2e6c:	00 97       	sbiw	r24, 0x00	; 0
    2e6e:	41 f0       	breq	.+16     	; 0x2e80 <_Z19check_sensors_touchmmi+0x1b8>
    2e70:	81 30       	cpi	r24, 0x01	; 1
    2e72:	91 05       	cpc	r25, r1
    2e74:	29 f0       	breq	.+10     	; 0x2e80 <_Z19check_sensors_touchmmi+0x1b8>
    2e76:	82 30       	cpi	r24, 0x02	; 2
    2e78:	91 05       	cpc	r25, r1
    2e7a:	11 f0       	breq	.+4      	; 0x2e80 <_Z19check_sensors_touchmmi+0x1b8>
    2e7c:	03 97       	sbiw	r24, 0x03	; 3
    2e7e:	21 f4       	brne	.+8      	; 0x2e88 <_Z19check_sensors_touchmmi+0x1c0>
        mousedown(KMOUSE_LEFT);
    2e80:	81 e0       	ldi	r24, 0x01	; 1
    2e82:	90 e0       	ldi	r25, 0x00	; 0
    2e84:	f8 de       	rcall	.-528    	; 0x2c76 <_Z9mousedowni>
        return;
    }
 
    /* Fall throughs */
    if (modeCheck(KMODE_GUI, pos) && modeCheck(KMODE_DEFAULT, pos + 1)) {
    2e86:	54 c0       	rjmp	.+168    	; 0x2f30 <_Z19check_sensors_touchmmi+0x268>
    2e88:	f2 01       	movw	r30, r4
    2e8a:	80 81       	ld	r24, Z
    2e8c:	91 81       	ldd	r25, Z+1	; 0x01
    2e8e:	04 97       	sbiw	r24, 0x04	; 4
    2e90:	09 f0       	breq	.+2      	; 0x2e94 <_Z19check_sensors_touchmmi+0x1cc>
    2e92:	4e c0       	rjmp	.+156    	; 0x2f30 <_Z19check_sensors_touchmmi+0x268>
    2e94:	0f 5f       	subi	r16, 0xFF	; 255
    2e96:	1f 4f       	sbci	r17, 0xFF	; 255
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2e98:	69 89       	ldd	r22, Y+17	; 0x11
    2e9a:	7a 89       	ldd	r23, Y+18	; 0x12
    2e9c:	60 17       	cp	r22, r16
    2e9e:	71 07       	cpc	r23, r17
    2ea0:	0c f4       	brge	.+2      	; 0x2ea4 <_Z19check_sensors_touchmmi+0x1dc>
    2ea2:	46 c0       	rjmp	.+140    	; 0x2f30 <_Z19check_sensors_touchmmi+0x268>
            return false;
        }
        return modeStack[modeStackPos - pos] == mode;
    2ea4:	af 85       	ldd	r26, Y+15	; 0x0f
    2ea6:	b8 89       	ldd	r27, Y+16	; 0x10
    2ea8:	8d 91       	ld	r24, X+
    2eaa:	9c 91       	ld	r25, X
    2eac:	11 97       	sbiw	r26, 0x01	; 1
    2eae:	12 97       	sbiw	r26, 0x02	; 2
    2eb0:	b8 8b       	std	Y+16, r27	; 0x10
    2eb2:	af 87       	std	Y+15, r26	; 0x0f
    2eb4:	ee ef       	ldi	r30, 0xFE	; 254
    2eb6:	ff ef       	ldi	r31, 0xFF	; 255
    2eb8:	4e 0e       	add	r4, r30
    2eba:	5f 1e       	adc	r5, r31
    2ebc:	6e 0e       	add	r6, r30
    2ebe:	7f 1e       	adc	r7, r31
    2ec0:	8e 0e       	add	r8, r30
    2ec2:	9f 1e       	adc	r9, r31
    2ec4:	6d 85       	ldd	r22, Y+13	; 0x0d
    2ec6:	7e 85       	ldd	r23, Y+14	; 0x0e
    2ec8:	62 50       	subi	r22, 0x02	; 2
    2eca:	70 40       	sbci	r23, 0x00	; 0
    2ecc:	7e 87       	std	Y+14, r23	; 0x0e
    2ece:	6d 87       	std	Y+13, r22	; 0x0d
    2ed0:	ae 0e       	add	r10, r30
    2ed2:	bf 1e       	adc	r11, r31
    2ed4:	2e 0e       	add	r2, r30
    2ed6:	3f 1e       	adc	r3, r31
    2ed8:	89 2b       	or	r24, r25
    2eda:	09 f4       	brne	.+2      	; 0x2ede <_Z19check_sensors_touchmmi+0x216>
    2edc:	59 cf       	rjmp	.-334    	; 0x2d90 <_Z19check_sensors_touchmmi+0xc8>
    2ede:	28 c0       	rjmp	.+80     	; 0x2f30 <_Z19check_sensors_touchmmi+0x268>
 
void check_sensors_touch(long unsigned int sensors1, long unsigned int sensors2, int pos) {
    if ((sensors1 & KS1_D8) == KS1_D8 && (sensors2 & KS2_D8) == KS2_D8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
        mouseon(KMOUSE_SCROLL);
        return;
    } else if ((sensors1 & KS1_A8) == KS1_A8 && (sensors2 & KS2_A8) == KS2_A8 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2ee0:	89 81       	ldd	r24, Y+1	; 0x01
    2ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ee4:	ab 81       	ldd	r26, Y+3	; 0x03
    2ee6:	bc 81       	ldd	r27, Y+4	; 0x04
    2ee8:	00 97       	sbiw	r24, 0x00	; 0
    2eea:	a1 05       	cpc	r26, r1
    2eec:	b1 05       	cpc	r27, r1
    2eee:	09 f0       	breq	.+2      	; 0x2ef2 <_Z19check_sensors_touchmmi+0x22a>
    2ef0:	6c cf       	rjmp	.-296    	; 0x2dca <_Z19check_sensors_touchmmi+0x102>
        mouseon(KMOUSE_MOVE);
        return;
    } else if ((sensors1 & KS1_J3) == KS1_J3 && (sensors2 & KS2_J3) == KS2_J3 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2ef2:	6d 81       	ldd	r22, Y+5	; 0x05
    2ef4:	7e 81       	ldd	r23, Y+6	; 0x06
    2ef6:	8f 81       	ldd	r24, Y+7	; 0x07
    2ef8:	98 85       	ldd	r25, Y+8	; 0x08
    2efa:	61 15       	cp	r22, r1
    2efc:	71 05       	cpc	r23, r1
    2efe:	81 05       	cpc	r24, r1
    2f00:	91 05       	cpc	r25, r1
    2f02:	09 f0       	breq	.+2      	; 0x2f06 <_Z19check_sensors_touchmmi+0x23e>
    2f04:	7b cf       	rjmp	.-266    	; 0x2dfc <_Z19check_sensors_touchmmi+0x134>
        mousedown(KMOUSE_RIGHT);
        return;
    } else if ((sensors1 & KS1_J2) == KS1_J2 && (sensors2 & KS2_J2) == KS2_J2 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2f06:	89 85       	ldd	r24, Y+9	; 0x09
    2f08:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f0a:	ab 85       	ldd	r26, Y+11	; 0x0b
    2f0c:	bc 85       	ldd	r27, Y+12	; 0x0c
    2f0e:	00 97       	sbiw	r24, 0x00	; 0
    2f10:	a1 05       	cpc	r26, r1
    2f12:	b1 05       	cpc	r27, r1
    2f14:	09 f0       	breq	.+2      	; 0x2f18 <_Z19check_sensors_touchmmi+0x250>
    2f16:	8a cf       	rjmp	.-236    	; 0x2e2c <_Z19check_sensors_touchmmi+0x164>
        mousedown(KMOUSE_MIDDLE);
        return;
    } else if ((sensors1 & KS1_J1) == KS1_J1 && (sensors2 & KS2_J1) == KS2_J1 && (modeCheck(KMODE_DEFAULT, pos) || modeCheck(KMODE_NUMBERS, pos) || modeCheck(KMODE_SYMBOLS, pos) || modeCheck(KMODE_FUNCTIONS, pos))) {
    2f18:	21 15       	cp	r18, r1
    2f1a:	31 05       	cpc	r19, r1
    2f1c:	41 05       	cpc	r20, r1
    2f1e:	51 05       	cpc	r21, r1
    2f20:	09 f0       	breq	.+2      	; 0x2f24 <_Z19check_sensors_touchmmi+0x25c>
    2f22:	9b cf       	rjmp	.-202    	; 0x2e5a <_Z19check_sensors_touchmmi+0x192>
    // declare these here so setmode() etc. have some context
    void activate_mode(int mode);
    void deactivate_mode(int mode);

    boolean modeCheck(int mode, int pos) {
        if (modeStackPos < pos) {
    2f24:	a9 89       	ldd	r26, Y+17	; 0x11
    2f26:	ba 89       	ldd	r27, Y+18	; 0x12
    2f28:	a0 17       	cp	r26, r16
    2f2a:	b1 07       	cpc	r27, r17
    2f2c:	0c f0       	brlt	.+2      	; 0x2f30 <_Z19check_sensors_touchmmi+0x268>
    2f2e:	ac cf       	rjmp	.-168    	; 0x2e88 <_Z19check_sensors_touchmmi+0x1c0>
    /* Fall throughs */
    if (modeCheck(KMODE_GUI, pos) && modeCheck(KMODE_DEFAULT, pos + 1)) {
        check_sensors_touch(sensors1, sensors2, pos + 1);
        return;
    }
}
    2f30:	62 96       	adiw	r28, 0x12	; 18
    2f32:	0f b6       	in	r0, 0x3f	; 63
    2f34:	f8 94       	cli
    2f36:	de bf       	out	0x3e, r29	; 62
    2f38:	0f be       	out	0x3f, r0	; 63
    2f3a:	cd bf       	out	0x3d, r28	; 61
    2f3c:	cf 91       	pop	r28
    2f3e:	df 91       	pop	r29
    2f40:	1f 91       	pop	r17
    2f42:	0f 91       	pop	r16
    2f44:	ff 90       	pop	r15
    2f46:	ef 90       	pop	r14
    2f48:	df 90       	pop	r13
    2f4a:	cf 90       	pop	r12
    2f4c:	bf 90       	pop	r11
    2f4e:	af 90       	pop	r10
    2f50:	9f 90       	pop	r9
    2f52:	8f 90       	pop	r8
    2f54:	7f 90       	pop	r7
    2f56:	6f 90       	pop	r6
    2f58:	5f 90       	pop	r5
    2f5a:	4f 90       	pop	r4
    2f5c:	3f 90       	pop	r3
    2f5e:	2f 90       	pop	r2
    2f60:	08 95       	ret

00002f62 <loop>:

void loop() {
    2f62:	2f 92       	push	r2
    2f64:	3f 92       	push	r3
    2f66:	4f 92       	push	r4
    2f68:	5f 92       	push	r5
    2f6a:	6f 92       	push	r6
    2f6c:	7f 92       	push	r7
    2f6e:	8f 92       	push	r8
    2f70:	9f 92       	push	r9
    2f72:	af 92       	push	r10
    2f74:	bf 92       	push	r11
    2f76:	cf 92       	push	r12
    2f78:	df 92       	push	r13
    2f7a:	ef 92       	push	r14
    2f7c:	ff 92       	push	r15
    2f7e:	0f 93       	push	r16
    2f80:	1f 93       	push	r17
    2f82:	df 93       	push	r29
    2f84:	cf 93       	push	r28
    2f86:	cd b7       	in	r28, 0x3d	; 61
    2f88:	de b7       	in	r29, 0x3e	; 62
    2f8a:	28 97       	sbiw	r28, 0x08	; 8
    2f8c:	0f b6       	in	r0, 0x3f	; 63
    2f8e:	f8 94       	cli
    2f90:	de bf       	out	0x3e, r29	; 62
    2f92:	0f be       	out	0x3f, r0	; 63
    2f94:	cd bf       	out	0x3d, r28	; 61
    moveMouse = false;
    2f96:	10 92 ac 06 	sts	0x06AC, r1
    scrollMouse = false;
    2f9a:	10 92 ad 06 	sts	0x06AD, r1
    if (counter % opt_motion_sampling_div == 0) {
    2f9e:	60 91 29 04 	lds	r22, 0x0429
    2fa2:	70 91 2a 04 	lds	r23, 0x042A
    2fa6:	80 91 a0 06 	lds	r24, 0x06A0
    2faa:	90 91 a1 06 	lds	r25, 0x06A1
    2fae:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    2fb2:	89 2b       	or	r24, r25
    2fb4:	11 f0       	breq	.+4      	; 0x2fba <loop+0x58>
    2fb6:	0c 94 86 23 	jmp	0x470c	; 0x470c <loop+0x17aa>
        if (opt_mouse_mode > 0 || opt_scroll_mode > 0) {
    2fba:	80 91 d1 06 	lds	r24, 0x06D1
    2fbe:	88 23       	and	r24, r24
    2fc0:	29 f4       	brne	.+10     	; 0x2fcc <loop+0x6a>
    2fc2:	80 91 d2 06 	lds	r24, 0x06D2
    2fc6:	88 23       	and	r24, r24
    2fc8:	09 f4       	brne	.+2      	; 0x2fcc <loop+0x6a>
    2fca:	59 c7       	rjmp	.+3762   	; 0x3e7e <loop+0xf1c>
            /* ===============================================
             * READ AND PROCESS ACCELEROMETER DATA
            =============================================== */
            #ifdef ENABLE_ACCEL
                x00 = x0;
    2fcc:	80 91 ef 06 	lds	r24, 0x06EF
    2fd0:	90 91 f0 06 	lds	r25, 0x06F0
    2fd4:	90 93 f6 06 	sts	0x06F6, r25
    2fd8:	80 93 f5 06 	sts	0x06F5, r24
                y00 = y0;
    2fdc:	80 91 f1 06 	lds	r24, 0x06F1
    2fe0:	90 91 f2 06 	lds	r25, 0x06F2
    2fe4:	90 93 f8 06 	sts	0x06F8, r25
    2fe8:	80 93 f7 06 	sts	0x06F7, r24
                z00 = z0;
    2fec:	80 91 f3 06 	lds	r24, 0x06F3
    2ff0:	90 91 f4 06 	lds	r25, 0x06F4
    2ff4:	90 93 fa 06 	sts	0x06FA, r25
    2ff8:	80 93 f9 06 	sts	0x06F9, r24
                x0 = x;
    2ffc:	80 91 e9 06 	lds	r24, 0x06E9
    3000:	90 91 ea 06 	lds	r25, 0x06EA
    3004:	90 93 f0 06 	sts	0x06F0, r25
    3008:	80 93 ef 06 	sts	0x06EF, r24
                y0 = y;
    300c:	80 91 eb 06 	lds	r24, 0x06EB
    3010:	90 91 ec 06 	lds	r25, 0x06EC
    3014:	90 93 f2 06 	sts	0x06F2, r25
    3018:	80 93 f1 06 	sts	0x06F1, r24
                z0 = z;
    301c:	80 91 ed 06 	lds	r24, 0x06ED
    3020:	90 91 ee 06 	lds	r25, 0x06EE
    3024:	90 93 f4 06 	sts	0x06F4, r25
    3028:	80 93 f3 06 	sts	0x06F3, r24
                
                // read accelerometer with correct rotation settings
                if      (opt_accel_rot90 == 0) { // no rotation:            x = +x, y = +y, z = +z
    302c:	80 91 cf 06 	lds	r24, 0x06CF
    3030:	88 23       	and	r24, r24
    3032:	59 f4       	brne	.+22     	; 0x304a <loop+0xe8>
                    accel.readAccel(&xRaw, &yRaw, &zRaw);
    3034:	83 ed       	ldi	r24, 0xD3	; 211
    3036:	96 e0       	ldi	r25, 0x06	; 6
    3038:	63 ee       	ldi	r22, 0xE3	; 227
    303a:	76 e0       	ldi	r23, 0x06	; 6
    303c:	45 ee       	ldi	r20, 0xE5	; 229
    303e:	56 e0       	ldi	r21, 0x06	; 6
    3040:	27 ee       	ldi	r18, 0xE7	; 231
    3042:	36 e0       	ldi	r19, 0x06	; 6
    3044:	0e 94 54 33 	call	0x66a8	; 0x66a8 <_ZN13Accelerometer9readAccelEPiS0_S0_>
    3048:	78 c0       	rjmp	.+240    	; 0x313a <loop+0x1d8>
                }
                else if (opt_accel_rot90 == 1) { // 90 around x axis:       x = +x, y = -z, z = +y
    304a:	81 30       	cpi	r24, 0x01	; 1
    304c:	49 f4       	brne	.+18     	; 0x3060 <loop+0xfe>
                    accel.readAccel(&xRaw, &zRaw, &yRaw);
    304e:	83 ed       	ldi	r24, 0xD3	; 211
    3050:	96 e0       	ldi	r25, 0x06	; 6
    3052:	63 ee       	ldi	r22, 0xE3	; 227
    3054:	76 e0       	ldi	r23, 0x06	; 6
    3056:	47 ee       	ldi	r20, 0xE7	; 231
    3058:	56 e0       	ldi	r21, 0x06	; 6
    305a:	25 ee       	ldi	r18, 0xE5	; 229
    305c:	36 e0       	ldi	r19, 0x06	; 6
    305e:	60 c0       	rjmp	.+192    	; 0x3120 <loop+0x1be>
                    zRaw = -zRaw;
                }
                else if (opt_accel_rot90 == 2) { // 90 around y axis:       x = -z, y = +y, z = +x
    3060:	82 30       	cpi	r24, 0x02	; 2
    3062:	09 f4       	brne	.+2      	; 0x3066 <loop+0x104>
    3064:	55 c0       	rjmp	.+170    	; 0x3110 <loop+0x1ae>
                    accel.readAccel(&zRaw, &yRaw, &xRaw);
                    zRaw = -zRaw;
                }
                else if (opt_accel_rot90 == 4) { // 90 around z axis;       x = -y, y = +x, z = +z
    3066:	84 30       	cpi	r24, 0x04	; 4
    3068:	b1 f4       	brne	.+44     	; 0x3096 <loop+0x134>
                    accel.readAccel(&yRaw, &xRaw, &zRaw);
    306a:	83 ed       	ldi	r24, 0xD3	; 211
    306c:	96 e0       	ldi	r25, 0x06	; 6
    306e:	65 ee       	ldi	r22, 0xE5	; 229
    3070:	76 e0       	ldi	r23, 0x06	; 6
    3072:	43 ee       	ldi	r20, 0xE3	; 227
    3074:	56 e0       	ldi	r21, 0x06	; 6
    3076:	27 ee       	ldi	r18, 0xE7	; 231
    3078:	36 e0       	ldi	r19, 0x06	; 6
    307a:	0e 94 54 33 	call	0x66a8	; 0x66a8 <_ZN13Accelerometer9readAccelEPiS0_S0_>
                    yRaw = -yRaw;
    307e:	80 91 e5 06 	lds	r24, 0x06E5
    3082:	90 91 e6 06 	lds	r25, 0x06E6
    3086:	90 95       	com	r25
    3088:	81 95       	neg	r24
    308a:	9f 4f       	sbci	r25, 0xFF	; 255
    308c:	90 93 e6 06 	sts	0x06E6, r25
    3090:	80 93 e5 06 	sts	0x06E5, r24
    3094:	52 c0       	rjmp	.+164    	; 0x313a <loop+0x1d8>
                }
                else if (opt_accel_rot90 == 3) { // 90 around x, y axes:    x = -z, y = -x, z = +y
    3096:	83 30       	cpi	r24, 0x03	; 3
    3098:	b1 f4       	brne	.+44     	; 0x30c6 <loop+0x164>
                    accel.readAccel(&zRaw, &xRaw, &yRaw);
    309a:	83 ed       	ldi	r24, 0xD3	; 211
    309c:	96 e0       	ldi	r25, 0x06	; 6
    309e:	67 ee       	ldi	r22, 0xE7	; 231
    30a0:	76 e0       	ldi	r23, 0x06	; 6
    30a2:	43 ee       	ldi	r20, 0xE3	; 227
    30a4:	56 e0       	ldi	r21, 0x06	; 6
    30a6:	25 ee       	ldi	r18, 0xE5	; 229
    30a8:	36 e0       	ldi	r19, 0x06	; 6
    30aa:	0e 94 54 33 	call	0x66a8	; 0x66a8 <_ZN13Accelerometer9readAccelEPiS0_S0_>
                    xRaw = -xRaw;
    30ae:	80 91 e3 06 	lds	r24, 0x06E3
    30b2:	90 91 e4 06 	lds	r25, 0x06E4
    30b6:	90 95       	com	r25
    30b8:	81 95       	neg	r24
    30ba:	9f 4f       	sbci	r25, 0xFF	; 255
    30bc:	90 93 e4 06 	sts	0x06E4, r25
    30c0:	80 93 e3 06 	sts	0x06E3, r24
    30c4:	2f c0       	rjmp	.+94     	; 0x3124 <loop+0x1c2>
                    zRaw = -zRaw;
                }
                else if (opt_accel_rot90 == 5) { // 90 around x, z axes:    x = -y, y = -z, z = +x
    30c6:	85 30       	cpi	r24, 0x05	; 5
    30c8:	49 f4       	brne	.+18     	; 0x30dc <loop+0x17a>
                    accel.readAccel(&yRaw, &zRaw, &xRaw);
    30ca:	83 ed       	ldi	r24, 0xD3	; 211
    30cc:	96 e0       	ldi	r25, 0x06	; 6
    30ce:	65 ee       	ldi	r22, 0xE5	; 229
    30d0:	76 e0       	ldi	r23, 0x06	; 6
    30d2:	47 ee       	ldi	r20, 0xE7	; 231
    30d4:	56 e0       	ldi	r21, 0x06	; 6
    30d6:	23 ee       	ldi	r18, 0xE3	; 227
    30d8:	36 e0       	ldi	r19, 0x06	; 6
    30da:	0a c0       	rjmp	.+20     	; 0x30f0 <loop+0x18e>
                    yRaw = -yRaw;
                    zRaw = -zRaw;
                }
                else if (opt_accel_rot90 == 6) { // 90 around y, z axes:    x = -z, y = +x, z = -y
    30dc:	86 30       	cpi	r24, 0x06	; 6
    30de:	b1 f4       	brne	.+44     	; 0x310c <loop+0x1aa>
                    accel.readAccel(&zRaw, &xRaw, &yRaw);
    30e0:	83 ed       	ldi	r24, 0xD3	; 211
    30e2:	96 e0       	ldi	r25, 0x06	; 6
    30e4:	67 ee       	ldi	r22, 0xE7	; 231
    30e6:	76 e0       	ldi	r23, 0x06	; 6
    30e8:	43 ee       	ldi	r20, 0xE3	; 227
    30ea:	56 e0       	ldi	r21, 0x06	; 6
    30ec:	25 ee       	ldi	r18, 0xE5	; 229
    30ee:	36 e0       	ldi	r19, 0x06	; 6
    30f0:	0e 94 54 33 	call	0x66a8	; 0x66a8 <_ZN13Accelerometer9readAccelEPiS0_S0_>
                    yRaw = -yRaw;
    30f4:	80 91 e5 06 	lds	r24, 0x06E5
    30f8:	90 91 e6 06 	lds	r25, 0x06E6
    30fc:	90 95       	com	r25
    30fe:	81 95       	neg	r24
    3100:	9f 4f       	sbci	r25, 0xFF	; 255
    3102:	90 93 e6 06 	sts	0x06E6, r25
    3106:	80 93 e5 06 	sts	0x06E5, r24
    310a:	0c c0       	rjmp	.+24     	; 0x3124 <loop+0x1c2>
                    zRaw = -zRaw;
                }
                else if (opt_accel_rot90 == 7) { // 90 around x, y, z axes: x = -z, y = +y, z = +x
    310c:	87 30       	cpi	r24, 0x07	; 7
    310e:	a9 f4       	brne	.+42     	; 0x313a <loop+0x1d8>
                    accel.readAccel(&zRaw, &yRaw, &xRaw);
    3110:	83 ed       	ldi	r24, 0xD3	; 211
    3112:	96 e0       	ldi	r25, 0x06	; 6
    3114:	67 ee       	ldi	r22, 0xE7	; 231
    3116:	76 e0       	ldi	r23, 0x06	; 6
    3118:	45 ee       	ldi	r20, 0xE5	; 229
    311a:	56 e0       	ldi	r21, 0x06	; 6
    311c:	23 ee       	ldi	r18, 0xE3	; 227
    311e:	36 e0       	ldi	r19, 0x06	; 6
    3120:	0e 94 54 33 	call	0x66a8	; 0x66a8 <_ZN13Accelerometer9readAccelEPiS0_S0_>
                    zRaw = -zRaw;
    3124:	80 91 e7 06 	lds	r24, 0x06E7
    3128:	90 91 e8 06 	lds	r25, 0x06E8
    312c:	90 95       	com	r25
    312e:	81 95       	neg	r24
    3130:	9f 4f       	sbci	r25, 0xFF	; 255
    3132:	90 93 e8 06 	sts	0x06E8, r25
    3136:	80 93 e7 06 	sts	0x06E7, r24
                }
                
                // calculate reading time difference
                accelDiff = accelMicros > 0 ? (micros() - accelMicros) : 1; // eliminate error from large gaps of inactivity
    313a:	80 91 d9 06 	lds	r24, 0x06D9
    313e:	90 91 da 06 	lds	r25, 0x06DA
    3142:	a0 91 db 06 	lds	r26, 0x06DB
    3146:	b0 91 dc 06 	lds	r27, 0x06DC
    314a:	00 97       	sbiw	r24, 0x00	; 0
    314c:	a1 05       	cpc	r26, r1
    314e:	b1 05       	cpc	r27, r1
    3150:	29 f4       	brne	.+10     	; 0x315c <loop+0x1fa>
    3152:	21 e0       	ldi	r18, 0x01	; 1
    3154:	30 e0       	ldi	r19, 0x00	; 0
    3156:	40 e0       	ldi	r20, 0x00	; 0
    3158:	50 e0       	ldi	r21, 0x00	; 0
    315a:	10 c0       	rjmp	.+32     	; 0x317c <loop+0x21a>
    315c:	0e 94 c4 39 	call	0x7388	; 0x7388 <micros>
    3160:	9b 01       	movw	r18, r22
    3162:	ac 01       	movw	r20, r24
    3164:	80 91 d9 06 	lds	r24, 0x06D9
    3168:	90 91 da 06 	lds	r25, 0x06DA
    316c:	a0 91 db 06 	lds	r26, 0x06DB
    3170:	b0 91 dc 06 	lds	r27, 0x06DC
    3174:	28 1b       	sub	r18, r24
    3176:	39 0b       	sbc	r19, r25
    3178:	4a 0b       	sbc	r20, r26
    317a:	5b 0b       	sbc	r21, r27
    317c:	20 93 dd 06 	sts	0x06DD, r18
    3180:	30 93 de 06 	sts	0x06DE, r19
    3184:	40 93 df 06 	sts	0x06DF, r20
    3188:	50 93 e0 06 	sts	0x06E0, r21
                accelMicros = micros();
    318c:	0e 94 c4 39 	call	0x7388	; 0x7388 <micros>
    3190:	60 93 d9 06 	sts	0x06D9, r22
    3194:	70 93 da 06 	sts	0x06DA, r23
    3198:	80 93 db 06 	sts	0x06DB, r24
    319c:	90 93 dc 06 	sts	0x06DC, r25
                
                // offset
                xRaw += opt_accel_offset[0];
    31a0:	60 91 e3 06 	lds	r22, 0x06E3
    31a4:	70 91 e4 06 	lds	r23, 0x06E4
    31a8:	20 91 0b 04 	lds	r18, 0x040B
    31ac:	30 91 0c 04 	lds	r19, 0x040C
    31b0:	62 0f       	add	r22, r18
    31b2:	73 1f       	adc	r23, r19
                yRaw += opt_accel_offset[1];
    31b4:	e0 90 e5 06 	lds	r14, 0x06E5
    31b8:	f0 90 e6 06 	lds	r15, 0x06E6
    31bc:	20 91 0d 04 	lds	r18, 0x040D
    31c0:	30 91 0e 04 	lds	r19, 0x040E
    31c4:	e2 0e       	add	r14, r18
    31c6:	f3 1e       	adc	r15, r19
                zRaw += opt_accel_offset[2];
    31c8:	a0 90 e7 06 	lds	r10, 0x06E7
    31cc:	b0 90 e8 06 	lds	r11, 0x06E8
    31d0:	20 91 0f 04 	lds	r18, 0x040F
    31d4:	30 91 10 04 	lds	r19, 0x0410
    31d8:	a2 0e       	add	r10, r18
    31da:	b3 1e       	adc	r11, r19
                
                // calibrate
                xRaw = (float)xRaw * opt_accel_calibrate[0];
    31dc:	88 27       	eor	r24, r24
    31de:	77 fd       	sbrc	r23, 7
    31e0:	80 95       	com	r24
    31e2:	98 2f       	mov	r25, r24
    31e4:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    31e8:	20 91 11 04 	lds	r18, 0x0411
    31ec:	30 91 12 04 	lds	r19, 0x0412
    31f0:	40 91 13 04 	lds	r20, 0x0413
    31f4:	50 91 14 04 	lds	r21, 0x0414
    31f8:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    31fc:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3200:	3b 01       	movw	r6, r22
    3202:	4c 01       	movw	r8, r24
    3204:	70 93 e4 06 	sts	0x06E4, r23
    3208:	60 93 e3 06 	sts	0x06E3, r22
                yRaw = (float)yRaw * opt_accel_calibrate[1];
    320c:	00 27       	eor	r16, r16
    320e:	f7 fc       	sbrc	r15, 7
    3210:	00 95       	com	r16
    3212:	10 2f       	mov	r17, r16
    3214:	c8 01       	movw	r24, r16
    3216:	b7 01       	movw	r22, r14
    3218:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    321c:	20 91 15 04 	lds	r18, 0x0415
    3220:	30 91 16 04 	lds	r19, 0x0416
    3224:	40 91 17 04 	lds	r20, 0x0417
    3228:	50 91 18 04 	lds	r21, 0x0418
    322c:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3230:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3234:	1b 01       	movw	r2, r22
    3236:	2c 01       	movw	r4, r24
    3238:	70 93 e6 06 	sts	0x06E6, r23
    323c:	60 93 e5 06 	sts	0x06E5, r22
                zRaw = (float)zRaw * opt_accel_calibrate[2];
    3240:	cc 24       	eor	r12, r12
    3242:	b7 fc       	sbrc	r11, 7
    3244:	c0 94       	com	r12
    3246:	dc 2c       	mov	r13, r12
    3248:	c6 01       	movw	r24, r12
    324a:	b5 01       	movw	r22, r10
    324c:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3250:	20 91 19 04 	lds	r18, 0x0419
    3254:	30 91 1a 04 	lds	r19, 0x041A
    3258:	40 91 1b 04 	lds	r20, 0x041B
    325c:	50 91 1c 04 	lds	r21, 0x041C
    3260:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3264:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3268:	4b 01       	movw	r8, r22
    326a:	5c 01       	movw	r10, r24
    326c:	70 93 e8 06 	sts	0x06E8, r23
    3270:	60 93 e7 06 	sts	0x06E7, r22
                
                // Kalman filtering
                x = x0 + (opt_accel_kalman_constant * (xRaw - x0));
    3274:	00 91 ef 06 	lds	r16, 0x06EF
    3278:	10 91 f0 06 	lds	r17, 0x06F0
    327c:	b8 01       	movw	r22, r16
    327e:	88 27       	eor	r24, r24
    3280:	77 fd       	sbrc	r23, 7
    3282:	80 95       	com	r24
    3284:	98 2f       	mov	r25, r24
    3286:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    328a:	6b 01       	movw	r12, r22
    328c:	7c 01       	movw	r14, r24
    328e:	60 1a       	sub	r6, r16
    3290:	71 0a       	sbc	r7, r17
    3292:	b3 01       	movw	r22, r6
    3294:	88 27       	eor	r24, r24
    3296:	77 fd       	sbrc	r23, 7
    3298:	80 95       	com	r24
    329a:	98 2f       	mov	r25, r24
    329c:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    32a0:	20 91 2b 04 	lds	r18, 0x042B
    32a4:	30 91 2c 04 	lds	r19, 0x042C
    32a8:	40 91 2d 04 	lds	r20, 0x042D
    32ac:	50 91 2e 04 	lds	r21, 0x042E
    32b0:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    32b4:	9b 01       	movw	r18, r22
    32b6:	ac 01       	movw	r20, r24
    32b8:	c7 01       	movw	r24, r14
    32ba:	b6 01       	movw	r22, r12
    32bc:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    32c0:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    32c4:	70 93 ea 06 	sts	0x06EA, r23
    32c8:	60 93 e9 06 	sts	0x06E9, r22
                y = y0 + (opt_accel_kalman_constant * (yRaw - y0));
    32cc:	00 91 f1 06 	lds	r16, 0x06F1
    32d0:	10 91 f2 06 	lds	r17, 0x06F2
    32d4:	b8 01       	movw	r22, r16
    32d6:	88 27       	eor	r24, r24
    32d8:	77 fd       	sbrc	r23, 7
    32da:	80 95       	com	r24
    32dc:	98 2f       	mov	r25, r24
    32de:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    32e2:	6b 01       	movw	r12, r22
    32e4:	7c 01       	movw	r14, r24
    32e6:	20 1a       	sub	r2, r16
    32e8:	31 0a       	sbc	r3, r17
    32ea:	b1 01       	movw	r22, r2
    32ec:	88 27       	eor	r24, r24
    32ee:	77 fd       	sbrc	r23, 7
    32f0:	80 95       	com	r24
    32f2:	98 2f       	mov	r25, r24
    32f4:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    32f8:	20 91 2b 04 	lds	r18, 0x042B
    32fc:	30 91 2c 04 	lds	r19, 0x042C
    3300:	40 91 2d 04 	lds	r20, 0x042D
    3304:	50 91 2e 04 	lds	r21, 0x042E
    3308:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    330c:	9b 01       	movw	r18, r22
    330e:	ac 01       	movw	r20, r24
    3310:	c7 01       	movw	r24, r14
    3312:	b6 01       	movw	r22, r12
    3314:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    3318:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    331c:	70 93 ec 06 	sts	0x06EC, r23
    3320:	60 93 eb 06 	sts	0x06EB, r22
                z = z0 + (opt_accel_kalman_constant * (zRaw - z0));
    3324:	00 91 f3 06 	lds	r16, 0x06F3
    3328:	10 91 f4 06 	lds	r17, 0x06F4
    332c:	b8 01       	movw	r22, r16
    332e:	88 27       	eor	r24, r24
    3330:	77 fd       	sbrc	r23, 7
    3332:	80 95       	com	r24
    3334:	98 2f       	mov	r25, r24
    3336:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    333a:	6b 01       	movw	r12, r22
    333c:	7c 01       	movw	r14, r24
    333e:	94 01       	movw	r18, r8
    3340:	20 1b       	sub	r18, r16
    3342:	31 0b       	sbc	r19, r17
    3344:	b9 01       	movw	r22, r18
    3346:	88 27       	eor	r24, r24
    3348:	77 fd       	sbrc	r23, 7
    334a:	80 95       	com	r24
    334c:	98 2f       	mov	r25, r24
    334e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3352:	20 91 2b 04 	lds	r18, 0x042B
    3356:	30 91 2c 04 	lds	r19, 0x042C
    335a:	40 91 2d 04 	lds	r20, 0x042D
    335e:	50 91 2e 04 	lds	r21, 0x042E
    3362:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3366:	9b 01       	movw	r18, r22
    3368:	ac 01       	movw	r20, r24
    336a:	c7 01       	movw	r24, r14
    336c:	b6 01       	movw	r22, r12
    336e:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    3372:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3376:	70 93 ee 06 	sts	0x06EE, r23
    337a:	60 93 ed 06 	sts	0x06ED, r22

                // averaging
                if (opt_accel_smooth_average > 0) {
    337e:	80 91 33 04 	lds	r24, 0x0433
    3382:	88 23       	and	r24, r24
    3384:	09 f4       	brne	.+2      	; 0x3388 <loop+0x426>
    3386:	b0 c0       	rjmp	.+352    	; 0x34e8 <loop+0x586>
                    for (i = 1; i < opt_accel_smooth_average; i++) {
    3388:	81 e0       	ldi	r24, 0x01	; 1
    338a:	90 e0       	ldi	r25, 0x00	; 0
    338c:	a0 e0       	ldi	r26, 0x00	; 0
    338e:	b0 e0       	ldi	r27, 0x00	; 0
    3390:	80 93 a8 06 	sts	0x06A8, r24
    3394:	90 93 a9 06 	sts	0x06A9, r25
    3398:	a0 93 aa 06 	sts	0x06AA, r26
    339c:	b0 93 ab 06 	sts	0x06AB, r27
    33a0:	3d c0       	rjmp	.+122    	; 0x341c <loop+0x4ba>
                        x += xHist[(accelTick + i) % opt_accel_smooth_average];
    33a2:	b3 01       	movw	r22, r6
    33a4:	88 27       	eor	r24, r24
    33a6:	77 fd       	sbrc	r23, 7
    33a8:	80 95       	com	r24
    33aa:	98 2f       	mov	r25, r24
    33ac:	6c 0d       	add	r22, r12
    33ae:	7d 1d       	adc	r23, r13
    33b0:	8e 1d       	adc	r24, r14
    33b2:	9f 1d       	adc	r25, r15
    33b4:	0e 94 af 43 	call	0x875e	; 0x875e <__divmodsi4>
    33b8:	dc 01       	movw	r26, r24
    33ba:	cb 01       	movw	r24, r22
    33bc:	88 0f       	add	r24, r24
    33be:	99 1f       	adc	r25, r25
    33c0:	fc 01       	movw	r30, r24
    33c2:	ed 5e       	subi	r30, 0xED	; 237
    33c4:	f8 4f       	sbci	r31, 0xF8	; 248
    33c6:	20 81       	ld	r18, Z
    33c8:	31 81       	ldd	r19, Z+1	; 0x01
    33ca:	02 0f       	add	r16, r18
    33cc:	13 1f       	adc	r17, r19
    33ce:	10 93 ea 06 	sts	0x06EA, r17
    33d2:	00 93 e9 06 	sts	0x06E9, r16
                        y += yHist[(accelTick + i) % opt_accel_smooth_average];
    33d6:	fc 01       	movw	r30, r24
    33d8:	e5 5c       	subi	r30, 0xC5	; 197
    33da:	f8 4f       	sbci	r31, 0xF8	; 248
    33dc:	20 81       	ld	r18, Z
    33de:	31 81       	ldd	r19, Z+1	; 0x01
    33e0:	a2 0e       	add	r10, r18
    33e2:	b3 1e       	adc	r11, r19
    33e4:	b0 92 ec 06 	sts	0x06EC, r11
    33e8:	a0 92 eb 06 	sts	0x06EB, r10
                        z += zHist[(accelTick + i) % opt_accel_smooth_average];
    33ec:	8d 59       	subi	r24, 0x9D	; 157
    33ee:	98 4f       	sbci	r25, 0xF8	; 248
    33f0:	dc 01       	movw	r26, r24
    33f2:	8d 91       	ld	r24, X+
    33f4:	9c 91       	ld	r25, X
    33f6:	48 0e       	add	r4, r24
    33f8:	59 1e       	adc	r5, r25
    33fa:	50 92 ee 06 	sts	0x06EE, r5
    33fe:	40 92 ed 06 	sts	0x06ED, r4
                y = y0 + (opt_accel_kalman_constant * (yRaw - y0));
                z = z0 + (opt_accel_kalman_constant * (zRaw - z0));

                // averaging
                if (opt_accel_smooth_average > 0) {
                    for (i = 1; i < opt_accel_smooth_average; i++) {
    3402:	08 94       	sec
    3404:	c1 1c       	adc	r12, r1
    3406:	d1 1c       	adc	r13, r1
    3408:	e1 1c       	adc	r14, r1
    340a:	f1 1c       	adc	r15, r1
    340c:	c0 92 a8 06 	sts	0x06A8, r12
    3410:	d0 92 a9 06 	sts	0x06A9, r13
    3414:	e0 92 aa 06 	sts	0x06AA, r14
    3418:	f0 92 ab 06 	sts	0x06AB, r15
    341c:	c0 90 a8 06 	lds	r12, 0x06A8
    3420:	d0 90 a9 06 	lds	r13, 0x06A9
    3424:	e0 90 aa 06 	lds	r14, 0x06AA
    3428:	f0 90 ab 06 	lds	r15, 0x06AB
    342c:	90 90 33 04 	lds	r9, 0x0433
    3430:	29 2d       	mov	r18, r9
    3432:	30 e0       	ldi	r19, 0x00	; 0
    3434:	40 e0       	ldi	r20, 0x00	; 0
    3436:	50 e0       	ldi	r21, 0x00	; 0
    3438:	00 91 e9 06 	lds	r16, 0x06E9
    343c:	10 91 ea 06 	lds	r17, 0x06EA
    3440:	a0 90 eb 06 	lds	r10, 0x06EB
    3444:	b0 90 ec 06 	lds	r11, 0x06EC
    3448:	40 90 ed 06 	lds	r4, 0x06ED
    344c:	50 90 ee 06 	lds	r5, 0x06EE
    3450:	60 90 e1 06 	lds	r6, 0x06E1
    3454:	70 90 e2 06 	lds	r7, 0x06E2
    3458:	c2 16       	cp	r12, r18
    345a:	d3 06       	cpc	r13, r19
    345c:	e4 06       	cpc	r14, r20
    345e:	f5 06       	cpc	r15, r21
    3460:	0c f4       	brge	.+2      	; 0x3464 <loop+0x502>
    3462:	9f cf       	rjmp	.-194    	; 0x33a2 <loop+0x440>
                        x += xHist[(accelTick + i) % opt_accel_smooth_average];
                        y += yHist[(accelTick + i) % opt_accel_smooth_average];
                        z += zHist[(accelTick + i) % opt_accel_smooth_average];
                    }
                    x /= opt_accel_smooth_average;
    3464:	c8 01       	movw	r24, r16
    3466:	69 2d       	mov	r22, r9
    3468:	70 e0       	ldi	r23, 0x00	; 0
    346a:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    346e:	9b 01       	movw	r18, r22
    3470:	70 93 ea 06 	sts	0x06EA, r23
    3474:	60 93 e9 06 	sts	0x06E9, r22
                    y /= opt_accel_smooth_average;
    3478:	c5 01       	movw	r24, r10
    347a:	69 2d       	mov	r22, r9
    347c:	70 e0       	ldi	r23, 0x00	; 0
    347e:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3482:	8b 01       	movw	r16, r22
    3484:	70 93 ec 06 	sts	0x06EC, r23
    3488:	60 93 eb 06 	sts	0x06EB, r22
                    z /= opt_accel_smooth_average;
    348c:	c2 01       	movw	r24, r4
    348e:	69 2d       	mov	r22, r9
    3490:	70 e0       	ldi	r23, 0x00	; 0
    3492:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3496:	7b 01       	movw	r14, r22
    3498:	70 93 ee 06 	sts	0x06EE, r23
    349c:	60 93 ed 06 	sts	0x06ED, r22
                    xHist[accelTick % opt_accel_smooth_average] = x;
    34a0:	c3 01       	movw	r24, r6
    34a2:	69 2d       	mov	r22, r9
    34a4:	70 e0       	ldi	r23, 0x00	; 0
    34a6:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    34aa:	fc 01       	movw	r30, r24
    34ac:	ee 0f       	add	r30, r30
    34ae:	ff 1f       	adc	r31, r31
    34b0:	ed 5e       	subi	r30, 0xED	; 237
    34b2:	f8 4f       	sbci	r31, 0xF8	; 248
    34b4:	31 83       	std	Z+1, r19	; 0x01
    34b6:	20 83       	st	Z, r18
                    yHist[accelTick % opt_accel_smooth_average] = y;
    34b8:	c3 01       	movw	r24, r6
    34ba:	69 2d       	mov	r22, r9
    34bc:	70 e0       	ldi	r23, 0x00	; 0
    34be:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    34c2:	fc 01       	movw	r30, r24
    34c4:	ee 0f       	add	r30, r30
    34c6:	ff 1f       	adc	r31, r31
    34c8:	e5 5c       	subi	r30, 0xC5	; 197
    34ca:	f8 4f       	sbci	r31, 0xF8	; 248
    34cc:	11 83       	std	Z+1, r17	; 0x01
    34ce:	00 83       	st	Z, r16
                    zHist[accelTick % opt_accel_smooth_average] = z;
    34d0:	c3 01       	movw	r24, r6
    34d2:	69 2d       	mov	r22, r9
    34d4:	70 e0       	ldi	r23, 0x00	; 0
    34d6:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    34da:	fc 01       	movw	r30, r24
    34dc:	ee 0f       	add	r30, r30
    34de:	ff 1f       	adc	r31, r31
    34e0:	ed 59       	subi	r30, 0x9D	; 157
    34e2:	f8 4f       	sbci	r31, 0xF8	; 248
    34e4:	f1 82       	std	Z+1, r15	; 0x01
    34e6:	e0 82       	st	Z, r14
                }
                
                // calculate linear velocity (INACCURATE SO FAR)
                xv += (x - x0) - (x0 - x00);
    34e8:	40 91 ef 06 	lds	r20, 0x06EF
    34ec:	50 91 f0 06 	lds	r21, 0x06F0
    34f0:	60 91 e9 06 	lds	r22, 0x06E9
    34f4:	70 91 ea 06 	lds	r23, 0x06EA
    34f8:	80 91 fb 06 	lds	r24, 0x06FB
    34fc:	90 91 fc 06 	lds	r25, 0x06FC
    3500:	86 0f       	add	r24, r22
    3502:	97 1f       	adc	r25, r23
    3504:	20 91 f5 06 	lds	r18, 0x06F5
    3508:	30 91 f6 06 	lds	r19, 0x06F6
    350c:	82 0f       	add	r24, r18
    350e:	93 1f       	adc	r25, r19
    3510:	84 1b       	sub	r24, r20
    3512:	95 0b       	sbc	r25, r21
    3514:	84 1b       	sub	r24, r20
    3516:	95 0b       	sbc	r25, r21
    3518:	90 93 fc 06 	sts	0x06FC, r25
    351c:	80 93 fb 06 	sts	0x06FB, r24
                yv += (y - y0) - (y0 - y00);
    3520:	40 91 f1 06 	lds	r20, 0x06F1
    3524:	50 91 f2 06 	lds	r21, 0x06F2
    3528:	80 91 eb 06 	lds	r24, 0x06EB
    352c:	90 91 ec 06 	lds	r25, 0x06EC
    3530:	20 91 fd 06 	lds	r18, 0x06FD
    3534:	30 91 fe 06 	lds	r19, 0x06FE
    3538:	82 0f       	add	r24, r18
    353a:	93 1f       	adc	r25, r19
    353c:	20 91 f7 06 	lds	r18, 0x06F7
    3540:	30 91 f8 06 	lds	r19, 0x06F8
    3544:	82 0f       	add	r24, r18
    3546:	93 1f       	adc	r25, r19
    3548:	84 1b       	sub	r24, r20
    354a:	95 0b       	sbc	r25, r21
    354c:	84 1b       	sub	r24, r20
    354e:	95 0b       	sbc	r25, r21
    3550:	90 93 fe 06 	sts	0x06FE, r25
    3554:	80 93 fd 06 	sts	0x06FD, r24
                zv += (z - z0) - (z0 - z00);
    3558:	40 91 f3 06 	lds	r20, 0x06F3
    355c:	50 91 f4 06 	lds	r21, 0x06F4
    3560:	80 91 ed 06 	lds	r24, 0x06ED
    3564:	90 91 ee 06 	lds	r25, 0x06EE
    3568:	20 91 ff 06 	lds	r18, 0x06FF
    356c:	30 91 00 07 	lds	r19, 0x0700
    3570:	82 0f       	add	r24, r18
    3572:	93 1f       	adc	r25, r19
    3574:	20 91 f9 06 	lds	r18, 0x06F9
    3578:	30 91 fa 06 	lds	r19, 0x06FA
    357c:	82 0f       	add	r24, r18
    357e:	93 1f       	adc	r25, r19
    3580:	84 1b       	sub	r24, r20
    3582:	95 0b       	sbc	r25, r21
    3584:	84 1b       	sub	r24, r20
    3586:	95 0b       	sbc	r25, r21
    3588:	90 93 00 07 	sts	0x0700, r25
    358c:	80 93 ff 06 	sts	0x06FF, r24
    
                if (opt_enable_calibration) {
    3590:	80 91 c6 06 	lds	r24, 0x06C6
    3594:	90 91 c7 06 	lds	r25, 0x06C7
    3598:	89 2b       	or	r24, r25
    359a:	09 f4       	brne	.+2      	; 0x359e <loop+0x63c>
    359c:	5d c0       	rjmp	.+186    	; 0x3658 <loop+0x6f6>
                    xMin = min(xMin, x);
    359e:	20 91 8b 07 	lds	r18, 0x078B
    35a2:	30 91 8c 07 	lds	r19, 0x078C
    35a6:	cb 01       	movw	r24, r22
    35a8:	26 17       	cp	r18, r22
    35aa:	37 07       	cpc	r19, r23
    35ac:	0c f4       	brge	.+2      	; 0x35b0 <loop+0x64e>
    35ae:	c9 01       	movw	r24, r18
    35b0:	90 93 8c 07 	sts	0x078C, r25
    35b4:	80 93 8b 07 	sts	0x078B, r24
                    yMin = min(yMin, y);
    35b8:	20 91 8d 07 	lds	r18, 0x078D
    35bc:	30 91 8e 07 	lds	r19, 0x078E
    35c0:	80 91 eb 06 	lds	r24, 0x06EB
    35c4:	90 91 ec 06 	lds	r25, 0x06EC
    35c8:	28 17       	cp	r18, r24
    35ca:	39 07       	cpc	r19, r25
    35cc:	0c f4       	brge	.+2      	; 0x35d0 <loop+0x66e>
    35ce:	c9 01       	movw	r24, r18
    35d0:	90 93 8e 07 	sts	0x078E, r25
    35d4:	80 93 8d 07 	sts	0x078D, r24
                    zMin = min(zMin, z);
    35d8:	20 91 8f 07 	lds	r18, 0x078F
    35dc:	30 91 90 07 	lds	r19, 0x0790
    35e0:	80 91 ed 06 	lds	r24, 0x06ED
    35e4:	90 91 ee 06 	lds	r25, 0x06EE
    35e8:	28 17       	cp	r18, r24
    35ea:	39 07       	cpc	r19, r25
    35ec:	0c f4       	brge	.+2      	; 0x35f0 <loop+0x68e>
    35ee:	c9 01       	movw	r24, r18
    35f0:	90 93 90 07 	sts	0x0790, r25
    35f4:	80 93 8f 07 	sts	0x078F, r24
                    xMax = max(xMax, x);
    35f8:	20 91 91 07 	lds	r18, 0x0791
    35fc:	30 91 92 07 	lds	r19, 0x0792
    3600:	80 91 e9 06 	lds	r24, 0x06E9
    3604:	90 91 ea 06 	lds	r25, 0x06EA
    3608:	82 17       	cp	r24, r18
    360a:	93 07       	cpc	r25, r19
    360c:	0c f4       	brge	.+2      	; 0x3610 <loop+0x6ae>
    360e:	c9 01       	movw	r24, r18
    3610:	90 93 92 07 	sts	0x0792, r25
    3614:	80 93 91 07 	sts	0x0791, r24
                    yMax = max(yMax, y);
    3618:	20 91 93 07 	lds	r18, 0x0793
    361c:	30 91 94 07 	lds	r19, 0x0794
    3620:	80 91 eb 06 	lds	r24, 0x06EB
    3624:	90 91 ec 06 	lds	r25, 0x06EC
    3628:	82 17       	cp	r24, r18
    362a:	93 07       	cpc	r25, r19
    362c:	0c f4       	brge	.+2      	; 0x3630 <loop+0x6ce>
    362e:	c9 01       	movw	r24, r18
    3630:	90 93 94 07 	sts	0x0794, r25
    3634:	80 93 93 07 	sts	0x0793, r24
                    zMax = max(zMax, z);
    3638:	20 91 95 07 	lds	r18, 0x0795
    363c:	30 91 96 07 	lds	r19, 0x0796
    3640:	80 91 ed 06 	lds	r24, 0x06ED
    3644:	90 91 ee 06 	lds	r25, 0x06EE
    3648:	82 17       	cp	r24, r18
    364a:	93 07       	cpc	r25, r19
    364c:	0c f4       	brge	.+2      	; 0x3650 <loop+0x6ee>
    364e:	c9 01       	movw	r24, r18
    3650:	90 93 96 07 	sts	0x0796, r25
    3654:	80 93 95 07 	sts	0x0795, r24
                        Serial.println(zMax);
                    #endif
                }
        
                // calculate tilt angle and angular velocity
                ax00 = ax0; // 2x-last-iteration
    3658:	80 91 9d 07 	lds	r24, 0x079D
    365c:	90 91 9e 07 	lds	r25, 0x079E
    3660:	90 93 a4 07 	sts	0x07A4, r25
    3664:	80 93 a3 07 	sts	0x07A3, r24
                ay00 = ay0;
    3668:	80 91 9f 07 	lds	r24, 0x079F
    366c:	90 91 a0 07 	lds	r25, 0x07A0
    3670:	90 93 a6 07 	sts	0x07A6, r25
    3674:	80 93 a5 07 	sts	0x07A5, r24
                az00 = az0;
    3678:	80 91 a1 07 	lds	r24, 0x07A1
    367c:	90 91 a2 07 	lds	r25, 0x07A2
    3680:	90 93 a8 07 	sts	0x07A8, r25
    3684:	80 93 a7 07 	sts	0x07A7, r24
                ax0 = ax; // last-iteration
    3688:	80 91 97 07 	lds	r24, 0x0797
    368c:	90 91 98 07 	lds	r25, 0x0798
    3690:	90 93 9e 07 	sts	0x079E, r25
    3694:	80 93 9d 07 	sts	0x079D, r24
                ay0 = ay;
    3698:	80 91 99 07 	lds	r24, 0x0799
    369c:	90 91 9a 07 	lds	r25, 0x079A
    36a0:	90 93 a0 07 	sts	0x07A0, r25
    36a4:	80 93 9f 07 	sts	0x079F, r24
                az0 = az;
    36a8:	80 91 9b 07 	lds	r24, 0x079B
    36ac:	90 91 9c 07 	lds	r25, 0x079C
    36b0:	90 93 a2 07 	sts	0x07A2, r25
    36b4:	80 93 a1 07 	sts	0x07A1, r24
                
                float xc = (float)x/256, yc = (float)y/256, zc = (float)z/256;
    36b8:	60 91 e9 06 	lds	r22, 0x06E9
    36bc:	70 91 ea 06 	lds	r23, 0x06EA
    36c0:	88 27       	eor	r24, r24
    36c2:	77 fd       	sbrc	r23, 7
    36c4:	80 95       	com	r24
    36c6:	98 2f       	mov	r25, r24
    36c8:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    36cc:	20 e0       	ldi	r18, 0x00	; 0
    36ce:	30 e0       	ldi	r19, 0x00	; 0
    36d0:	40 e8       	ldi	r20, 0x80	; 128
    36d2:	5b e3       	ldi	r21, 0x3B	; 59
    36d4:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    36d8:	7b 01       	movw	r14, r22
    36da:	8c 01       	movw	r16, r24
    36dc:	60 91 eb 06 	lds	r22, 0x06EB
    36e0:	70 91 ec 06 	lds	r23, 0x06EC
    36e4:	88 27       	eor	r24, r24
    36e6:	77 fd       	sbrc	r23, 7
    36e8:	80 95       	com	r24
    36ea:	98 2f       	mov	r25, r24
    36ec:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    36f0:	20 e0       	ldi	r18, 0x00	; 0
    36f2:	30 e0       	ldi	r19, 0x00	; 0
    36f4:	40 e8       	ldi	r20, 0x80	; 128
    36f6:	5b e3       	ldi	r21, 0x3B	; 59
    36f8:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    36fc:	5b 01       	movw	r10, r22
    36fe:	6c 01       	movw	r12, r24
    3700:	60 91 ed 06 	lds	r22, 0x06ED
    3704:	70 91 ee 06 	lds	r23, 0x06EE
    3708:	88 27       	eor	r24, r24
    370a:	77 fd       	sbrc	r23, 7
    370c:	80 95       	com	r24
    370e:	98 2f       	mov	r25, r24
    3710:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3714:	20 e0       	ldi	r18, 0x00	; 0
    3716:	30 e0       	ldi	r19, 0x00	; 0
    3718:	40 e8       	ldi	r20, 0x80	; 128
    371a:	5b e3       	ldi	r21, 0x3B	; 59
    371c:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3720:	1b 01       	movw	r2, r22
    3722:	2c 01       	movw	r4, r24
                
                // regular atan method, more work and does not adjust for quadrants automatically
                ax = degrees(atan(xc / sqrt(yc*yc + zc*zc)));
    3724:	c6 01       	movw	r24, r12
    3726:	b5 01       	movw	r22, r10
    3728:	a6 01       	movw	r20, r12
    372a:	95 01       	movw	r18, r10
    372c:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3730:	69 83       	std	Y+1, r22	; 0x01
    3732:	7a 83       	std	Y+2, r23	; 0x02
    3734:	8b 83       	std	Y+3, r24	; 0x03
    3736:	9c 83       	std	Y+4, r25	; 0x04
    3738:	c2 01       	movw	r24, r4
    373a:	b1 01       	movw	r22, r2
    373c:	a2 01       	movw	r20, r4
    373e:	91 01       	movw	r18, r2
    3740:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3744:	6d 83       	std	Y+5, r22	; 0x05
    3746:	7e 83       	std	Y+6, r23	; 0x06
    3748:	8f 83       	std	Y+7, r24	; 0x07
    374a:	98 87       	std	Y+8, r25	; 0x08
    374c:	69 81       	ldd	r22, Y+1	; 0x01
    374e:	7a 81       	ldd	r23, Y+2	; 0x02
    3750:	8b 81       	ldd	r24, Y+3	; 0x03
    3752:	9c 81       	ldd	r25, Y+4	; 0x04
    3754:	2d 81       	ldd	r18, Y+5	; 0x05
    3756:	3e 81       	ldd	r19, Y+6	; 0x06
    3758:	4f 81       	ldd	r20, Y+7	; 0x07
    375a:	58 85       	ldd	r21, Y+8	; 0x08
    375c:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    3760:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    3764:	9b 01       	movw	r18, r22
    3766:	ac 01       	movw	r20, r24
    3768:	c8 01       	movw	r24, r16
    376a:	b7 01       	movw	r22, r14
    376c:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    3770:	0e 94 f8 3f 	call	0x7ff0	; 0x7ff0 <atan>
    3774:	21 ee       	ldi	r18, 0xE1	; 225
    3776:	3e e2       	ldi	r19, 0x2E	; 46
    3778:	45 e6       	ldi	r20, 0x65	; 101
    377a:	52 e4       	ldi	r21, 0x42	; 66
    377c:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3780:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3784:	3b 01       	movw	r6, r22
    3786:	4c 01       	movw	r8, r24
    3788:	70 93 98 07 	sts	0x0798, r23
    378c:	60 93 97 07 	sts	0x0797, r22
                ay = degrees(atan(yc / sqrt(xc*xc + zc*zc)));
    3790:	c8 01       	movw	r24, r16
    3792:	b7 01       	movw	r22, r14
    3794:	a8 01       	movw	r20, r16
    3796:	97 01       	movw	r18, r14
    3798:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    379c:	7b 01       	movw	r14, r22
    379e:	8c 01       	movw	r16, r24
    37a0:	2d 81       	ldd	r18, Y+5	; 0x05
    37a2:	3e 81       	ldd	r19, Y+6	; 0x06
    37a4:	4f 81       	ldd	r20, Y+7	; 0x07
    37a6:	58 85       	ldd	r21, Y+8	; 0x08
    37a8:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    37ac:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    37b0:	9b 01       	movw	r18, r22
    37b2:	ac 01       	movw	r20, r24
    37b4:	c6 01       	movw	r24, r12
    37b6:	b5 01       	movw	r22, r10
    37b8:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    37bc:	0e 94 f8 3f 	call	0x7ff0	; 0x7ff0 <atan>
    37c0:	21 ee       	ldi	r18, 0xE1	; 225
    37c2:	3e e2       	ldi	r19, 0x2E	; 46
    37c4:	45 e6       	ldi	r20, 0x65	; 101
    37c6:	52 e4       	ldi	r21, 0x42	; 66
    37c8:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    37cc:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    37d0:	70 93 9a 07 	sts	0x079A, r23
    37d4:	60 93 99 07 	sts	0x0799, r22
                //az = degrees(atan(sqrt(xc*xc + yc*yc) / zc));
                az = degrees(atan(zc / sqrt(xc*xc + yc*yc)));
    37d8:	c8 01       	movw	r24, r16
    37da:	b7 01       	movw	r22, r14
    37dc:	29 81       	ldd	r18, Y+1	; 0x01
    37de:	3a 81       	ldd	r19, Y+2	; 0x02
    37e0:	4b 81       	ldd	r20, Y+3	; 0x03
    37e2:	5c 81       	ldd	r21, Y+4	; 0x04
    37e4:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    37e8:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    37ec:	9b 01       	movw	r18, r22
    37ee:	ac 01       	movw	r20, r24
    37f0:	c2 01       	movw	r24, r4
    37f2:	b1 01       	movw	r22, r2
    37f4:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    37f8:	0e 94 f8 3f 	call	0x7ff0	; 0x7ff0 <atan>
    37fc:	21 ee       	ldi	r18, 0xE1	; 225
    37fe:	3e e2       	ldi	r19, 0x2E	; 46
    3800:	45 e6       	ldi	r20, 0x65	; 101
    3802:	52 e4       	ldi	r21, 0x42	; 66
    3804:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3808:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    380c:	ab 01       	movw	r20, r22
    380e:	70 93 9c 07 	sts	0x079C, r23
    3812:	60 93 9b 07 	sts	0x079B, r22
                // atan2 is definitely very simple
                //ax = degrees(atan2(yc, zc));
                //ay = degrees(atan2(xc, zc));
                //az = degrees(atan(sqrt(xc*xc + yc*yc) / zc));

                int axa = abs(ax), aya = abs(ay); //, aza = abs(az);
    3816:	20 91 99 07 	lds	r18, 0x0799
    381a:	30 91 9a 07 	lds	r19, 0x079A
                if (axa > 90 || aya > 90) az += 180;
    381e:	c3 01       	movw	r24, r6
    3820:	77 fe       	sbrs	r7, 7
    3822:	03 c0       	rjmp	.+6      	; 0x382a <loop+0x8c8>
    3824:	90 95       	com	r25
    3826:	81 95       	neg	r24
    3828:	9f 4f       	sbci	r25, 0xFF	; 255
    382a:	8b 35       	cpi	r24, 0x5B	; 91
    382c:	91 05       	cpc	r25, r1
    382e:	44 f4       	brge	.+16     	; 0x3840 <loop+0x8de>
    3830:	37 ff       	sbrs	r19, 7
    3832:	03 c0       	rjmp	.+6      	; 0x383a <loop+0x8d8>
    3834:	30 95       	com	r19
    3836:	21 95       	neg	r18
    3838:	3f 4f       	sbci	r19, 0xFF	; 255
    383a:	2b 35       	cpi	r18, 0x5B	; 91
    383c:	31 05       	cpc	r19, r1
    383e:	34 f0       	brlt	.+12     	; 0x384c <loop+0x8ea>
    3840:	4c 54       	subi	r20, 0x4C	; 76
    3842:	5f 4f       	sbci	r21, 0xFF	; 255
    3844:	50 93 9c 07 	sts	0x079C, r21
    3848:	40 93 9b 07 	sts	0x079B, r20
                    Serial.print(ax); Serial.print(" ");
                    Serial.print(ay); Serial.print(" ");
                    Serial.println(az);
                #endif /* SERIAL_DEBUG_ACCEL */
        
                accelTick++;
    384c:	80 91 e1 06 	lds	r24, 0x06E1
    3850:	90 91 e2 06 	lds	r25, 0x06E2
    3854:	01 96       	adiw	r24, 0x01	; 1
    3856:	90 93 e2 06 	sts	0x06E2, r25
    385a:	80 93 e1 06 	sts	0x06E1, r24
        
            /* ===============================================
             * READ AND PROCESS GYROSCOPE DATA
            =============================================== */
            #ifdef ENABLE_GYRO
                gx00 = gx0;
    385e:	80 91 e2 07 	lds	r24, 0x07E2
    3862:	90 91 e3 07 	lds	r25, 0x07E3
    3866:	90 93 e9 07 	sts	0x07E9, r25
    386a:	80 93 e8 07 	sts	0x07E8, r24
                gy00 = gy0;
    386e:	80 91 e4 07 	lds	r24, 0x07E4
    3872:	90 91 e5 07 	lds	r25, 0x07E5
    3876:	90 93 eb 07 	sts	0x07EB, r25
    387a:	80 93 ea 07 	sts	0x07EA, r24
                gz00 = gz0;
    387e:	80 91 e6 07 	lds	r24, 0x07E6
    3882:	90 91 e7 07 	lds	r25, 0x07E7
    3886:	90 93 ed 07 	sts	0x07ED, r25
    388a:	80 93 ec 07 	sts	0x07EC, r24
                gx0 = gx;
    388e:	80 91 dc 07 	lds	r24, 0x07DC
    3892:	90 91 dd 07 	lds	r25, 0x07DD
    3896:	90 93 e3 07 	sts	0x07E3, r25
    389a:	80 93 e2 07 	sts	0x07E2, r24
                gy0 = gy;
    389e:	80 91 de 07 	lds	r24, 0x07DE
    38a2:	90 91 df 07 	lds	r25, 0x07DF
    38a6:	90 93 e5 07 	sts	0x07E5, r25
    38aa:	80 93 e4 07 	sts	0x07E4, r24
                gz0 = gz;
    38ae:	80 91 e0 07 	lds	r24, 0x07E0
    38b2:	90 91 e1 07 	lds	r25, 0x07E1
    38b6:	90 93 e7 07 	sts	0x07E7, r25
    38ba:	80 93 e6 07 	sts	0x07E6, r24

                // read gyroscope with correct rotation settings
                if      (opt_gyro_rot90 == 0) { // no rotation:            x = +x, y = +y, z = +z
    38be:	80 91 34 04 	lds	r24, 0x0434
    38c2:	88 23       	and	r24, r24
    38c4:	59 f4       	brne	.+22     	; 0x38dc <loop+0x97a>
                    gyro.readGyroRaw(&gxRaw, &gyRaw, &gzRaw);
    38c6:	83 eb       	ldi	r24, 0xB3	; 179
    38c8:	97 e0       	ldi	r25, 0x07	; 7
    38ca:	66 ed       	ldi	r22, 0xD6	; 214
    38cc:	77 e0       	ldi	r23, 0x07	; 7
    38ce:	48 ed       	ldi	r20, 0xD8	; 216
    38d0:	57 e0       	ldi	r21, 0x07	; 7
    38d2:	2a ed       	ldi	r18, 0xDA	; 218
    38d4:	37 e0       	ldi	r19, 0x07	; 7
    38d6:	0e 94 b8 35 	call	0x6b70	; 0x6b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>
    38da:	78 c0       	rjmp	.+240    	; 0x39cc <loop+0xa6a>
                }
                else if (opt_gyro_rot90 == 1) { // 90 around x axis:       x = +x, y = -z, z = +y
    38dc:	81 30       	cpi	r24, 0x01	; 1
    38de:	49 f4       	brne	.+18     	; 0x38f2 <loop+0x990>
                    gyro.readGyroRaw(&gxRaw, &gzRaw, &gyRaw);
    38e0:	83 eb       	ldi	r24, 0xB3	; 179
    38e2:	97 e0       	ldi	r25, 0x07	; 7
    38e4:	66 ed       	ldi	r22, 0xD6	; 214
    38e6:	77 e0       	ldi	r23, 0x07	; 7
    38e8:	4a ed       	ldi	r20, 0xDA	; 218
    38ea:	57 e0       	ldi	r21, 0x07	; 7
    38ec:	28 ed       	ldi	r18, 0xD8	; 216
    38ee:	37 e0       	ldi	r19, 0x07	; 7
    38f0:	60 c0       	rjmp	.+192    	; 0x39b2 <loop+0xa50>
                    gzRaw = -gzRaw;
                }
                else if (opt_gyro_rot90 == 2) { // 90 around y axis:       x = -z, y = +y, z = +x
    38f2:	82 30       	cpi	r24, 0x02	; 2
    38f4:	09 f4       	brne	.+2      	; 0x38f8 <loop+0x996>
    38f6:	55 c0       	rjmp	.+170    	; 0x39a2 <loop+0xa40>
                    gyro.readGyroRaw(&gzRaw, &gyRaw, &gxRaw);
                    gzRaw = -gzRaw;
                }
                else if (opt_gyro_rot90 == 4) { // 90 around z axis;       x = -y, y = +x, z = +z
    38f8:	84 30       	cpi	r24, 0x04	; 4
    38fa:	b1 f4       	brne	.+44     	; 0x3928 <loop+0x9c6>
                    gyro.readGyroRaw(&gyRaw, &gxRaw, &gzRaw);
    38fc:	83 eb       	ldi	r24, 0xB3	; 179
    38fe:	97 e0       	ldi	r25, 0x07	; 7
    3900:	68 ed       	ldi	r22, 0xD8	; 216
    3902:	77 e0       	ldi	r23, 0x07	; 7
    3904:	46 ed       	ldi	r20, 0xD6	; 214
    3906:	57 e0       	ldi	r21, 0x07	; 7
    3908:	2a ed       	ldi	r18, 0xDA	; 218
    390a:	37 e0       	ldi	r19, 0x07	; 7
    390c:	0e 94 b8 35 	call	0x6b70	; 0x6b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>
                    gyRaw = -gyRaw;
    3910:	80 91 d8 07 	lds	r24, 0x07D8
    3914:	90 91 d9 07 	lds	r25, 0x07D9
    3918:	90 95       	com	r25
    391a:	81 95       	neg	r24
    391c:	9f 4f       	sbci	r25, 0xFF	; 255
    391e:	90 93 d9 07 	sts	0x07D9, r25
    3922:	80 93 d8 07 	sts	0x07D8, r24
    3926:	52 c0       	rjmp	.+164    	; 0x39cc <loop+0xa6a>
                }
                else if (opt_gyro_rot90 == 3) { // 90 around x, y axes:    x = -z, y = -x, z = +y
    3928:	83 30       	cpi	r24, 0x03	; 3
    392a:	b1 f4       	brne	.+44     	; 0x3958 <loop+0x9f6>
                    gyro.readGyroRaw(&gzRaw, &gxRaw, &gyRaw);
    392c:	83 eb       	ldi	r24, 0xB3	; 179
    392e:	97 e0       	ldi	r25, 0x07	; 7
    3930:	6a ed       	ldi	r22, 0xDA	; 218
    3932:	77 e0       	ldi	r23, 0x07	; 7
    3934:	46 ed       	ldi	r20, 0xD6	; 214
    3936:	57 e0       	ldi	r21, 0x07	; 7
    3938:	28 ed       	ldi	r18, 0xD8	; 216
    393a:	37 e0       	ldi	r19, 0x07	; 7
    393c:	0e 94 b8 35 	call	0x6b70	; 0x6b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>
                    gxRaw = -gxRaw;
    3940:	80 91 d6 07 	lds	r24, 0x07D6
    3944:	90 91 d7 07 	lds	r25, 0x07D7
    3948:	90 95       	com	r25
    394a:	81 95       	neg	r24
    394c:	9f 4f       	sbci	r25, 0xFF	; 255
    394e:	90 93 d7 07 	sts	0x07D7, r25
    3952:	80 93 d6 07 	sts	0x07D6, r24
    3956:	2f c0       	rjmp	.+94     	; 0x39b6 <loop+0xa54>
                    gzRaw = -gzRaw;
                }
                else if (opt_gyro_rot90 == 5) { // 90 around x, z axes:    x = -y, y = -z, z = +x
    3958:	85 30       	cpi	r24, 0x05	; 5
    395a:	49 f4       	brne	.+18     	; 0x396e <loop+0xa0c>
                    gyro.readGyroRaw(&gyRaw, &gzRaw, &gxRaw);
    395c:	83 eb       	ldi	r24, 0xB3	; 179
    395e:	97 e0       	ldi	r25, 0x07	; 7
    3960:	68 ed       	ldi	r22, 0xD8	; 216
    3962:	77 e0       	ldi	r23, 0x07	; 7
    3964:	4a ed       	ldi	r20, 0xDA	; 218
    3966:	57 e0       	ldi	r21, 0x07	; 7
    3968:	26 ed       	ldi	r18, 0xD6	; 214
    396a:	37 e0       	ldi	r19, 0x07	; 7
    396c:	0a c0       	rjmp	.+20     	; 0x3982 <loop+0xa20>
                    gyRaw = -gyRaw;
                    gzRaw = -gzRaw;
                }
                else if (opt_gyro_rot90 == 6) { // 90 around y, z axes:    x = -z, y = +x, z = -y
    396e:	86 30       	cpi	r24, 0x06	; 6
    3970:	b1 f4       	brne	.+44     	; 0x399e <loop+0xa3c>
                    gyro.readGyroRaw(&gzRaw, &gxRaw, &gyRaw);
    3972:	83 eb       	ldi	r24, 0xB3	; 179
    3974:	97 e0       	ldi	r25, 0x07	; 7
    3976:	6a ed       	ldi	r22, 0xDA	; 218
    3978:	77 e0       	ldi	r23, 0x07	; 7
    397a:	46 ed       	ldi	r20, 0xD6	; 214
    397c:	57 e0       	ldi	r21, 0x07	; 7
    397e:	28 ed       	ldi	r18, 0xD8	; 216
    3980:	37 e0       	ldi	r19, 0x07	; 7
    3982:	0e 94 b8 35 	call	0x6b70	; 0x6b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>
                    gyRaw = -gyRaw;
    3986:	80 91 d8 07 	lds	r24, 0x07D8
    398a:	90 91 d9 07 	lds	r25, 0x07D9
    398e:	90 95       	com	r25
    3990:	81 95       	neg	r24
    3992:	9f 4f       	sbci	r25, 0xFF	; 255
    3994:	90 93 d9 07 	sts	0x07D9, r25
    3998:	80 93 d8 07 	sts	0x07D8, r24
    399c:	0c c0       	rjmp	.+24     	; 0x39b6 <loop+0xa54>
                    gzRaw = -gzRaw;
                }
                else if (opt_gyro_rot90 == 7) { // 90 around x, y, z axes: x = -z, y = +y, z = +x
    399e:	87 30       	cpi	r24, 0x07	; 7
    39a0:	a9 f4       	brne	.+42     	; 0x39cc <loop+0xa6a>
                    gyro.readGyroRaw(&gzRaw, &gyRaw, &gxRaw);
    39a2:	83 eb       	ldi	r24, 0xB3	; 179
    39a4:	97 e0       	ldi	r25, 0x07	; 7
    39a6:	6a ed       	ldi	r22, 0xDA	; 218
    39a8:	77 e0       	ldi	r23, 0x07	; 7
    39aa:	48 ed       	ldi	r20, 0xD8	; 216
    39ac:	57 e0       	ldi	r21, 0x07	; 7
    39ae:	26 ed       	ldi	r18, 0xD6	; 214
    39b0:	37 e0       	ldi	r19, 0x07	; 7
    39b2:	0e 94 b8 35 	call	0x6b70	; 0x6b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>
                    gzRaw = -gzRaw;
    39b6:	80 91 da 07 	lds	r24, 0x07DA
    39ba:	90 91 db 07 	lds	r25, 0x07DB
    39be:	90 95       	com	r25
    39c0:	81 95       	neg	r24
    39c2:	9f 4f       	sbci	r25, 0xFF	; 255
    39c4:	90 93 db 07 	sts	0x07DB, r25
    39c8:	80 93 da 07 	sts	0x07DA, r24
                }
                
                // calculate reading time difference
                gyroDiff = gyroMicros > 0 ? (micros() - gyroMicros) : 1; // eliminate error from large gaps of inactivity
    39cc:	80 91 cc 07 	lds	r24, 0x07CC
    39d0:	90 91 cd 07 	lds	r25, 0x07CD
    39d4:	a0 91 ce 07 	lds	r26, 0x07CE
    39d8:	b0 91 cf 07 	lds	r27, 0x07CF
    39dc:	00 97       	sbiw	r24, 0x00	; 0
    39de:	a1 05       	cpc	r26, r1
    39e0:	b1 05       	cpc	r27, r1
    39e2:	29 f4       	brne	.+10     	; 0x39ee <loop+0xa8c>
    39e4:	21 e0       	ldi	r18, 0x01	; 1
    39e6:	30 e0       	ldi	r19, 0x00	; 0
    39e8:	40 e0       	ldi	r20, 0x00	; 0
    39ea:	50 e0       	ldi	r21, 0x00	; 0
    39ec:	10 c0       	rjmp	.+32     	; 0x3a0e <loop+0xaac>
    39ee:	0e 94 c4 39 	call	0x7388	; 0x7388 <micros>
    39f2:	9b 01       	movw	r18, r22
    39f4:	ac 01       	movw	r20, r24
    39f6:	80 91 cc 07 	lds	r24, 0x07CC
    39fa:	90 91 cd 07 	lds	r25, 0x07CD
    39fe:	a0 91 ce 07 	lds	r26, 0x07CE
    3a02:	b0 91 cf 07 	lds	r27, 0x07CF
    3a06:	28 1b       	sub	r18, r24
    3a08:	39 0b       	sbc	r19, r25
    3a0a:	4a 0b       	sbc	r20, r26
    3a0c:	5b 0b       	sbc	r21, r27
    3a0e:	20 93 d0 07 	sts	0x07D0, r18
    3a12:	30 93 d1 07 	sts	0x07D1, r19
    3a16:	40 93 d2 07 	sts	0x07D2, r20
    3a1a:	50 93 d3 07 	sts	0x07D3, r21
                gyroMicros = micros();
    3a1e:	0e 94 c4 39 	call	0x7388	; 0x7388 <micros>
    3a22:	60 93 cc 07 	sts	0x07CC, r22
    3a26:	70 93 cd 07 	sts	0x07CD, r23
    3a2a:	80 93 ce 07 	sts	0x07CE, r24
    3a2e:	90 93 cf 07 	sts	0x07CF, r25

                // offset
                gxRaw += opt_gyro_offset[0];
    3a32:	60 91 d6 07 	lds	r22, 0x07D6
    3a36:	70 91 d7 07 	lds	r23, 0x07D7
    3a3a:	20 91 c8 06 	lds	r18, 0x06C8
    3a3e:	30 91 c9 06 	lds	r19, 0x06C9
    3a42:	62 0f       	add	r22, r18
    3a44:	73 1f       	adc	r23, r19
                gyRaw += opt_gyro_offset[1];
    3a46:	e0 90 d8 07 	lds	r14, 0x07D8
    3a4a:	f0 90 d9 07 	lds	r15, 0x07D9
    3a4e:	20 91 ca 06 	lds	r18, 0x06CA
    3a52:	30 91 cb 06 	lds	r19, 0x06CB
    3a56:	e2 0e       	add	r14, r18
    3a58:	f3 1e       	adc	r15, r19
                gzRaw += opt_gyro_offset[2];
    3a5a:	a0 90 da 07 	lds	r10, 0x07DA
    3a5e:	b0 90 db 07 	lds	r11, 0x07DB
    3a62:	20 91 cc 06 	lds	r18, 0x06CC
    3a66:	30 91 cd 06 	lds	r19, 0x06CD
    3a6a:	a2 0e       	add	r10, r18
    3a6c:	b3 1e       	adc	r11, r19
                
                // calibrate
                gxRaw = (float)gxRaw * opt_gyro_calibrate[0] / 15; //14.375;
    3a6e:	88 27       	eor	r24, r24
    3a70:	77 fd       	sbrc	r23, 7
    3a72:	80 95       	com	r24
    3a74:	98 2f       	mov	r25, r24
    3a76:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3a7a:	20 91 1d 04 	lds	r18, 0x041D
    3a7e:	30 91 1e 04 	lds	r19, 0x041E
    3a82:	40 91 1f 04 	lds	r20, 0x041F
    3a86:	50 91 20 04 	lds	r21, 0x0420
    3a8a:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3a8e:	20 e0       	ldi	r18, 0x00	; 0
    3a90:	30 e0       	ldi	r19, 0x00	; 0
    3a92:	40 e7       	ldi	r20, 0x70	; 112
    3a94:	51 e4       	ldi	r21, 0x41	; 65
    3a96:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    3a9a:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3a9e:	3b 01       	movw	r6, r22
    3aa0:	4c 01       	movw	r8, r24
    3aa2:	70 93 d7 07 	sts	0x07D7, r23
    3aa6:	60 93 d6 07 	sts	0x07D6, r22
                gyRaw = (float)gyRaw * opt_gyro_calibrate[1] / 15; //14.375;
    3aaa:	00 27       	eor	r16, r16
    3aac:	f7 fc       	sbrc	r15, 7
    3aae:	00 95       	com	r16
    3ab0:	10 2f       	mov	r17, r16
    3ab2:	c8 01       	movw	r24, r16
    3ab4:	b7 01       	movw	r22, r14
    3ab6:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3aba:	20 91 21 04 	lds	r18, 0x0421
    3abe:	30 91 22 04 	lds	r19, 0x0422
    3ac2:	40 91 23 04 	lds	r20, 0x0423
    3ac6:	50 91 24 04 	lds	r21, 0x0424
    3aca:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3ace:	20 e0       	ldi	r18, 0x00	; 0
    3ad0:	30 e0       	ldi	r19, 0x00	; 0
    3ad2:	40 e7       	ldi	r20, 0x70	; 112
    3ad4:	51 e4       	ldi	r21, 0x41	; 65
    3ad6:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    3ada:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3ade:	1b 01       	movw	r2, r22
    3ae0:	2c 01       	movw	r4, r24
    3ae2:	70 93 d9 07 	sts	0x07D9, r23
    3ae6:	60 93 d8 07 	sts	0x07D8, r22
                gzRaw = (float)gzRaw * opt_gyro_calibrate[2] / 15; //14.375;
    3aea:	cc 24       	eor	r12, r12
    3aec:	b7 fc       	sbrc	r11, 7
    3aee:	c0 94       	com	r12
    3af0:	dc 2c       	mov	r13, r12
    3af2:	c6 01       	movw	r24, r12
    3af4:	b5 01       	movw	r22, r10
    3af6:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3afa:	20 91 25 04 	lds	r18, 0x0425
    3afe:	30 91 26 04 	lds	r19, 0x0426
    3b02:	40 91 27 04 	lds	r20, 0x0427
    3b06:	50 91 28 04 	lds	r21, 0x0428
    3b0a:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3b0e:	20 e0       	ldi	r18, 0x00	; 0
    3b10:	30 e0       	ldi	r19, 0x00	; 0
    3b12:	40 e7       	ldi	r20, 0x70	; 112
    3b14:	51 e4       	ldi	r21, 0x41	; 65
    3b16:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    3b1a:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3b1e:	4b 01       	movw	r8, r22
    3b20:	5c 01       	movw	r10, r24
    3b22:	70 93 db 07 	sts	0x07DB, r23
    3b26:	60 93 da 07 	sts	0x07DA, r22
                
                // Kalman filtering
                gx = gx0 + (opt_gyro_kalman_constant * (gxRaw - gx0));
    3b2a:	00 91 e2 07 	lds	r16, 0x07E2
    3b2e:	10 91 e3 07 	lds	r17, 0x07E3
    3b32:	b8 01       	movw	r22, r16
    3b34:	88 27       	eor	r24, r24
    3b36:	77 fd       	sbrc	r23, 7
    3b38:	80 95       	com	r24
    3b3a:	98 2f       	mov	r25, r24
    3b3c:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3b40:	6b 01       	movw	r12, r22
    3b42:	7c 01       	movw	r14, r24
    3b44:	60 1a       	sub	r6, r16
    3b46:	71 0a       	sbc	r7, r17
    3b48:	b3 01       	movw	r22, r6
    3b4a:	88 27       	eor	r24, r24
    3b4c:	77 fd       	sbrc	r23, 7
    3b4e:	80 95       	com	r24
    3b50:	98 2f       	mov	r25, r24
    3b52:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3b56:	20 91 2f 04 	lds	r18, 0x042F
    3b5a:	30 91 30 04 	lds	r19, 0x0430
    3b5e:	40 91 31 04 	lds	r20, 0x0431
    3b62:	50 91 32 04 	lds	r21, 0x0432
    3b66:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3b6a:	9b 01       	movw	r18, r22
    3b6c:	ac 01       	movw	r20, r24
    3b6e:	c7 01       	movw	r24, r14
    3b70:	b6 01       	movw	r22, r12
    3b72:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    3b76:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3b7a:	70 93 dd 07 	sts	0x07DD, r23
    3b7e:	60 93 dc 07 	sts	0x07DC, r22
                gy = gy0 + (opt_gyro_kalman_constant * (gyRaw - gy0));
    3b82:	00 91 e4 07 	lds	r16, 0x07E4
    3b86:	10 91 e5 07 	lds	r17, 0x07E5
    3b8a:	b8 01       	movw	r22, r16
    3b8c:	88 27       	eor	r24, r24
    3b8e:	77 fd       	sbrc	r23, 7
    3b90:	80 95       	com	r24
    3b92:	98 2f       	mov	r25, r24
    3b94:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3b98:	6b 01       	movw	r12, r22
    3b9a:	7c 01       	movw	r14, r24
    3b9c:	20 1a       	sub	r2, r16
    3b9e:	31 0a       	sbc	r3, r17
    3ba0:	b1 01       	movw	r22, r2
    3ba2:	88 27       	eor	r24, r24
    3ba4:	77 fd       	sbrc	r23, 7
    3ba6:	80 95       	com	r24
    3ba8:	98 2f       	mov	r25, r24
    3baa:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3bae:	20 91 2f 04 	lds	r18, 0x042F
    3bb2:	30 91 30 04 	lds	r19, 0x0430
    3bb6:	40 91 31 04 	lds	r20, 0x0431
    3bba:	50 91 32 04 	lds	r21, 0x0432
    3bbe:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3bc2:	9b 01       	movw	r18, r22
    3bc4:	ac 01       	movw	r20, r24
    3bc6:	c7 01       	movw	r24, r14
    3bc8:	b6 01       	movw	r22, r12
    3bca:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    3bce:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3bd2:	70 93 df 07 	sts	0x07DF, r23
    3bd6:	60 93 de 07 	sts	0x07DE, r22
                gz = gz0 + (opt_gyro_kalman_constant * (gzRaw - gz0));
    3bda:	00 91 e6 07 	lds	r16, 0x07E6
    3bde:	10 91 e7 07 	lds	r17, 0x07E7
    3be2:	b8 01       	movw	r22, r16
    3be4:	88 27       	eor	r24, r24
    3be6:	77 fd       	sbrc	r23, 7
    3be8:	80 95       	com	r24
    3bea:	98 2f       	mov	r25, r24
    3bec:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3bf0:	6b 01       	movw	r12, r22
    3bf2:	7c 01       	movw	r14, r24
    3bf4:	94 01       	movw	r18, r8
    3bf6:	20 1b       	sub	r18, r16
    3bf8:	31 0b       	sbc	r19, r17
    3bfa:	b9 01       	movw	r22, r18
    3bfc:	88 27       	eor	r24, r24
    3bfe:	77 fd       	sbrc	r23, 7
    3c00:	80 95       	com	r24
    3c02:	98 2f       	mov	r25, r24
    3c04:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3c08:	20 91 2f 04 	lds	r18, 0x042F
    3c0c:	30 91 30 04 	lds	r19, 0x0430
    3c10:	40 91 31 04 	lds	r20, 0x0431
    3c14:	50 91 32 04 	lds	r21, 0x0432
    3c18:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    3c1c:	9b 01       	movw	r18, r22
    3c1e:	ac 01       	movw	r20, r24
    3c20:	c7 01       	movw	r24, r14
    3c22:	b6 01       	movw	r22, r12
    3c24:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    3c28:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3c2c:	70 93 e1 07 	sts	0x07E1, r23
    3c30:	60 93 e0 07 	sts	0x07E0, r22
                
                // averaging
                if (opt_gyro_smooth_average > 0) {
    3c34:	80 91 ce 06 	lds	r24, 0x06CE
    3c38:	88 23       	and	r24, r24
    3c3a:	09 f4       	brne	.+2      	; 0x3c3e <loop+0xcdc>
    3c3c:	b0 c0       	rjmp	.+352    	; 0x3d9e <loop+0xe3c>
                    for (i = 1; i < opt_gyro_smooth_average; i++) {
    3c3e:	81 e0       	ldi	r24, 0x01	; 1
    3c40:	90 e0       	ldi	r25, 0x00	; 0
    3c42:	a0 e0       	ldi	r26, 0x00	; 0
    3c44:	b0 e0       	ldi	r27, 0x00	; 0
    3c46:	80 93 a8 06 	sts	0x06A8, r24
    3c4a:	90 93 a9 06 	sts	0x06A9, r25
    3c4e:	a0 93 aa 06 	sts	0x06AA, r26
    3c52:	b0 93 ab 06 	sts	0x06AB, r27
    3c56:	3d c0       	rjmp	.+122    	; 0x3cd2 <loop+0xd70>
                        gx += gxHist[(gyroTick + i) % opt_gyro_smooth_average];
    3c58:	b4 01       	movw	r22, r8
    3c5a:	88 27       	eor	r24, r24
    3c5c:	77 fd       	sbrc	r23, 7
    3c5e:	80 95       	com	r24
    3c60:	98 2f       	mov	r25, r24
    3c62:	6e 0d       	add	r22, r14
    3c64:	7f 1d       	adc	r23, r15
    3c66:	80 1f       	adc	r24, r16
    3c68:	91 1f       	adc	r25, r17
    3c6a:	0e 94 af 43 	call	0x875e	; 0x875e <__divmodsi4>
    3c6e:	dc 01       	movw	r26, r24
    3c70:	cb 01       	movw	r24, r22
    3c72:	88 0f       	add	r24, r24
    3c74:	99 1f       	adc	r25, r25
    3c76:	fc 01       	movw	r30, r24
    3c78:	e0 50       	subi	r30, 0x00	; 0
    3c7a:	f8 4f       	sbci	r31, 0xF8	; 248
    3c7c:	20 81       	ld	r18, Z
    3c7e:	31 81       	ldd	r19, Z+1	; 0x01
    3c80:	42 0e       	add	r4, r18
    3c82:	53 1e       	adc	r5, r19
    3c84:	50 92 dd 07 	sts	0x07DD, r5
    3c88:	40 92 dc 07 	sts	0x07DC, r4
                        gy += gyHist[(gyroTick + i) % opt_gyro_smooth_average];
    3c8c:	fc 01       	movw	r30, r24
    3c8e:	e8 5d       	subi	r30, 0xD8	; 216
    3c90:	f7 4f       	sbci	r31, 0xF7	; 247
    3c92:	20 81       	ld	r18, Z
    3c94:	31 81       	ldd	r19, Z+1	; 0x01
    3c96:	c2 0e       	add	r12, r18
    3c98:	d3 1e       	adc	r13, r19
    3c9a:	d0 92 df 07 	sts	0x07DF, r13
    3c9e:	c0 92 de 07 	sts	0x07DE, r12
                        gz += gzHist[(gyroTick + i) % opt_gyro_smooth_average];
    3ca2:	80 5b       	subi	r24, 0xB0	; 176
    3ca4:	97 4f       	sbci	r25, 0xF7	; 247
    3ca6:	fc 01       	movw	r30, r24
    3ca8:	80 81       	ld	r24, Z
    3caa:	91 81       	ldd	r25, Z+1	; 0x01
    3cac:	68 0e       	add	r6, r24
    3cae:	79 1e       	adc	r7, r25
    3cb0:	70 92 e1 07 	sts	0x07E1, r7
    3cb4:	60 92 e0 07 	sts	0x07E0, r6
                gy = gy0 + (opt_gyro_kalman_constant * (gyRaw - gy0));
                gz = gz0 + (opt_gyro_kalman_constant * (gzRaw - gz0));
                
                // averaging
                if (opt_gyro_smooth_average > 0) {
                    for (i = 1; i < opt_gyro_smooth_average; i++) {
    3cb8:	08 94       	sec
    3cba:	e1 1c       	adc	r14, r1
    3cbc:	f1 1c       	adc	r15, r1
    3cbe:	01 1d       	adc	r16, r1
    3cc0:	11 1d       	adc	r17, r1
    3cc2:	e0 92 a8 06 	sts	0x06A8, r14
    3cc6:	f0 92 a9 06 	sts	0x06A9, r15
    3cca:	00 93 aa 06 	sts	0x06AA, r16
    3cce:	10 93 ab 06 	sts	0x06AB, r17
    3cd2:	e0 90 a8 06 	lds	r14, 0x06A8
    3cd6:	f0 90 a9 06 	lds	r15, 0x06A9
    3cda:	00 91 aa 06 	lds	r16, 0x06AA
    3cde:	10 91 ab 06 	lds	r17, 0x06AB
    3ce2:	b0 90 ce 06 	lds	r11, 0x06CE
    3ce6:	2b 2d       	mov	r18, r11
    3ce8:	30 e0       	ldi	r19, 0x00	; 0
    3cea:	40 e0       	ldi	r20, 0x00	; 0
    3cec:	50 e0       	ldi	r21, 0x00	; 0
    3cee:	40 90 dc 07 	lds	r4, 0x07DC
    3cf2:	50 90 dd 07 	lds	r5, 0x07DD
    3cf6:	c0 90 de 07 	lds	r12, 0x07DE
    3cfa:	d0 90 df 07 	lds	r13, 0x07DF
    3cfe:	60 90 e0 07 	lds	r6, 0x07E0
    3d02:	70 90 e1 07 	lds	r7, 0x07E1
    3d06:	80 90 d4 07 	lds	r8, 0x07D4
    3d0a:	90 90 d5 07 	lds	r9, 0x07D5
    3d0e:	e2 16       	cp	r14, r18
    3d10:	f3 06       	cpc	r15, r19
    3d12:	04 07       	cpc	r16, r20
    3d14:	15 07       	cpc	r17, r21
    3d16:	0c f4       	brge	.+2      	; 0x3d1a <loop+0xdb8>
    3d18:	9f cf       	rjmp	.-194    	; 0x3c58 <loop+0xcf6>
                        gx += gxHist[(gyroTick + i) % opt_gyro_smooth_average];
                        gy += gyHist[(gyroTick + i) % opt_gyro_smooth_average];
                        gz += gzHist[(gyroTick + i) % opt_gyro_smooth_average];
                    }
                    gx /= opt_gyro_smooth_average;
    3d1a:	c2 01       	movw	r24, r4
    3d1c:	6b 2d       	mov	r22, r11
    3d1e:	70 e0       	ldi	r23, 0x00	; 0
    3d20:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3d24:	9b 01       	movw	r18, r22
    3d26:	70 93 dd 07 	sts	0x07DD, r23
    3d2a:	60 93 dc 07 	sts	0x07DC, r22
                    gy /= opt_gyro_smooth_average;
    3d2e:	c6 01       	movw	r24, r12
    3d30:	6b 2d       	mov	r22, r11
    3d32:	70 e0       	ldi	r23, 0x00	; 0
    3d34:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3d38:	8b 01       	movw	r16, r22
    3d3a:	70 93 df 07 	sts	0x07DF, r23
    3d3e:	60 93 de 07 	sts	0x07DE, r22
                    gz /= opt_gyro_smooth_average;
    3d42:	c3 01       	movw	r24, r6
    3d44:	6b 2d       	mov	r22, r11
    3d46:	70 e0       	ldi	r23, 0x00	; 0
    3d48:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3d4c:	7b 01       	movw	r14, r22
    3d4e:	70 93 e1 07 	sts	0x07E1, r23
    3d52:	60 93 e0 07 	sts	0x07E0, r22
                    gxHist[gyroTick % opt_gyro_smooth_average] = gx;
    3d56:	c4 01       	movw	r24, r8
    3d58:	6b 2d       	mov	r22, r11
    3d5a:	70 e0       	ldi	r23, 0x00	; 0
    3d5c:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3d60:	fc 01       	movw	r30, r24
    3d62:	ee 0f       	add	r30, r30
    3d64:	ff 1f       	adc	r31, r31
    3d66:	e0 50       	subi	r30, 0x00	; 0
    3d68:	f8 4f       	sbci	r31, 0xF8	; 248
    3d6a:	31 83       	std	Z+1, r19	; 0x01
    3d6c:	20 83       	st	Z, r18
                    gyHist[gyroTick % opt_gyro_smooth_average] = gy;
    3d6e:	c4 01       	movw	r24, r8
    3d70:	6b 2d       	mov	r22, r11
    3d72:	70 e0       	ldi	r23, 0x00	; 0
    3d74:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3d78:	fc 01       	movw	r30, r24
    3d7a:	ee 0f       	add	r30, r30
    3d7c:	ff 1f       	adc	r31, r31
    3d7e:	e8 5d       	subi	r30, 0xD8	; 216
    3d80:	f7 4f       	sbci	r31, 0xF7	; 247
    3d82:	11 83       	std	Z+1, r17	; 0x01
    3d84:	00 83       	st	Z, r16
                    gzHist[gyroTick % opt_gyro_smooth_average] = gz;
    3d86:	c4 01       	movw	r24, r8
    3d88:	6b 2d       	mov	r22, r11
    3d8a:	70 e0       	ldi	r23, 0x00	; 0
    3d8c:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    3d90:	fc 01       	movw	r30, r24
    3d92:	ee 0f       	add	r30, r30
    3d94:	ff 1f       	adc	r31, r31
    3d96:	e0 5b       	subi	r30, 0xB0	; 176
    3d98:	f7 4f       	sbci	r31, 0xF7	; 247
    3d9a:	f1 82       	std	Z+1, r15	; 0x01
    3d9c:	e0 82       	st	Z, r14
                }
                
                if (opt_enable_calibration) {
    3d9e:	80 91 c6 06 	lds	r24, 0x06C6
    3da2:	90 91 c7 06 	lds	r25, 0x06C7
    3da6:	89 2b       	or	r24, r25
    3da8:	09 f4       	brne	.+2      	; 0x3dac <loop+0xe4a>
    3daa:	60 c0       	rjmp	.+192    	; 0x3e6c <loop+0xf0a>
                    gxMin = min(gxMin, gx);
    3dac:	20 91 78 08 	lds	r18, 0x0878
    3db0:	30 91 79 08 	lds	r19, 0x0879
    3db4:	80 91 dc 07 	lds	r24, 0x07DC
    3db8:	90 91 dd 07 	lds	r25, 0x07DD
    3dbc:	28 17       	cp	r18, r24
    3dbe:	39 07       	cpc	r19, r25
    3dc0:	0c f4       	brge	.+2      	; 0x3dc4 <loop+0xe62>
    3dc2:	c9 01       	movw	r24, r18
    3dc4:	90 93 79 08 	sts	0x0879, r25
    3dc8:	80 93 78 08 	sts	0x0878, r24
                    gyMin = min(gyMin, gy);
    3dcc:	20 91 7a 08 	lds	r18, 0x087A
    3dd0:	30 91 7b 08 	lds	r19, 0x087B
    3dd4:	80 91 de 07 	lds	r24, 0x07DE
    3dd8:	90 91 df 07 	lds	r25, 0x07DF
    3ddc:	28 17       	cp	r18, r24
    3dde:	39 07       	cpc	r19, r25
    3de0:	0c f4       	brge	.+2      	; 0x3de4 <loop+0xe82>
    3de2:	c9 01       	movw	r24, r18
    3de4:	90 93 7b 08 	sts	0x087B, r25
    3de8:	80 93 7a 08 	sts	0x087A, r24
                    gzMin = min(gzMin, gz);
    3dec:	20 91 7c 08 	lds	r18, 0x087C
    3df0:	30 91 7d 08 	lds	r19, 0x087D
    3df4:	80 91 e0 07 	lds	r24, 0x07E0
    3df8:	90 91 e1 07 	lds	r25, 0x07E1
    3dfc:	28 17       	cp	r18, r24
    3dfe:	39 07       	cpc	r19, r25
    3e00:	0c f4       	brge	.+2      	; 0x3e04 <loop+0xea2>
    3e02:	c9 01       	movw	r24, r18
    3e04:	90 93 7d 08 	sts	0x087D, r25
    3e08:	80 93 7c 08 	sts	0x087C, r24
                    gxMax = max(gxMax, gx);
    3e0c:	20 91 7e 08 	lds	r18, 0x087E
    3e10:	30 91 7f 08 	lds	r19, 0x087F
    3e14:	80 91 dc 07 	lds	r24, 0x07DC
    3e18:	90 91 dd 07 	lds	r25, 0x07DD
    3e1c:	82 17       	cp	r24, r18
    3e1e:	93 07       	cpc	r25, r19
    3e20:	0c f4       	brge	.+2      	; 0x3e24 <loop+0xec2>
    3e22:	c9 01       	movw	r24, r18
    3e24:	90 93 7f 08 	sts	0x087F, r25
    3e28:	80 93 7e 08 	sts	0x087E, r24
                    gyMax = max(gyMax, gy);
    3e2c:	20 91 80 08 	lds	r18, 0x0880
    3e30:	30 91 81 08 	lds	r19, 0x0881
    3e34:	80 91 de 07 	lds	r24, 0x07DE
    3e38:	90 91 df 07 	lds	r25, 0x07DF
    3e3c:	82 17       	cp	r24, r18
    3e3e:	93 07       	cpc	r25, r19
    3e40:	0c f4       	brge	.+2      	; 0x3e44 <loop+0xee2>
    3e42:	c9 01       	movw	r24, r18
    3e44:	90 93 81 08 	sts	0x0881, r25
    3e48:	80 93 80 08 	sts	0x0880, r24
                    gzMax = max(gzMax, gz);
    3e4c:	20 91 82 08 	lds	r18, 0x0882
    3e50:	30 91 83 08 	lds	r19, 0x0883
    3e54:	80 91 e0 07 	lds	r24, 0x07E0
    3e58:	90 91 e1 07 	lds	r25, 0x07E1
    3e5c:	82 17       	cp	r24, r18
    3e5e:	93 07       	cpc	r25, r19
    3e60:	0c f4       	brge	.+2      	; 0x3e64 <loop+0xf02>
    3e62:	c9 01       	movw	r24, r18
    3e64:	90 93 83 08 	sts	0x0883, r25
    3e68:	80 93 82 08 	sts	0x0882, r24
                    Serial.print(gx); Serial.print(" ");
                    Serial.print(gy); Serial.print(" ");
                    Serial.println(gz);
                #endif /* SERIAL_DEBUG_GYRO */
        
                gyroTick++;
    3e6c:	80 91 d4 07 	lds	r24, 0x07D4
    3e70:	90 91 d5 07 	lds	r25, 0x07D5
    3e74:	01 96       	adiw	r24, 0x01	; 1
    3e76:	90 93 d5 07 	sts	0x07D5, r25
    3e7a:	80 93 d4 07 	sts	0x07D4, r24
            #endif /* ENABLE_GYRO */
        }
    
        #ifdef ENABLE_MOUSE
            switch (opt_mouse_mode) {
    3e7e:	90 90 d1 06 	lds	r9, 0x06D1
    3e82:	f2 e0       	ldi	r31, 0x02	; 2
    3e84:	9f 16       	cp	r9, r31
    3e86:	09 f4       	brne	.+2      	; 0x3e8a <loop+0xf28>
    3e88:	9b c0       	rjmp	.+310    	; 0x3fc0 <loop+0x105e>
    3e8a:	f9 15       	cp	r31, r9
    3e8c:	28 f0       	brcs	.+10     	; 0x3e98 <loop+0xf36>
    3e8e:	21 e0       	ldi	r18, 0x01	; 1
    3e90:	92 16       	cp	r9, r18
    3e92:	09 f0       	breq	.+2      	; 0x3e96 <loop+0xf34>
    3e94:	37 c2       	rjmp	.+1134   	; 0x4304 <loop+0x13a2>
    3e96:	09 c0       	rjmp	.+18     	; 0x3eaa <loop+0xf48>
    3e98:	33 e0       	ldi	r19, 0x03	; 3
    3e9a:	93 16       	cp	r9, r19
    3e9c:	09 f4       	brne	.+2      	; 0x3ea0 <loop+0xf3e>
    3e9e:	09 c1       	rjmp	.+530    	; 0x40b2 <loop+0x1150>
    3ea0:	84 e0       	ldi	r24, 0x04	; 4
    3ea2:	98 16       	cp	r9, r24
    3ea4:	09 f0       	breq	.+2      	; 0x3ea8 <loop+0xf46>
    3ea6:	2e c2       	rjmp	.+1116   	; 0x4304 <loop+0x13a2>
    3ea8:	96 c1       	rjmp	.+812    	; 0x41d6 <loop+0x1274>
                case MOUSE_MODE_TILT_VELOCITY:
                    if (aset) {
    3eaa:	80 91 af 07 	lds	r24, 0x07AF
    3eae:	00 91 97 07 	lds	r16, 0x0797
    3eb2:	10 91 98 07 	lds	r17, 0x0798
    3eb6:	60 90 99 07 	lds	r6, 0x0799
    3eba:	70 90 9a 07 	lds	r7, 0x079A
    3ebe:	88 23       	and	r24, r24
    3ec0:	09 f4       	brne	.+2      	; 0x3ec4 <loop+0xf62>
    3ec2:	6b c0       	rjmp	.+214    	; 0x3f9a <loop+0x1038>
                        mx0 = mx;
    3ec4:	60 91 ae 06 	lds	r22, 0x06AE
    3ec8:	70 91 af 06 	lds	r23, 0x06AF
    3ecc:	70 93 b7 06 	sts	0x06B7, r23
    3ed0:	60 93 b6 06 	sts	0x06B6, r22
                        my0 = my;
    3ed4:	e0 90 b0 06 	lds	r14, 0x06B0
    3ed8:	f0 90 b1 06 	lds	r15, 0x06B1
    3edc:	f0 92 b9 06 	sts	0x06B9, r15
    3ee0:	e0 92 b8 06 	sts	0x06B8, r14
                        mx -= (float)(ax - axBase) / opt_mouse_scale_mode1[0];
    3ee4:	88 27       	eor	r24, r24
    3ee6:	77 fd       	sbrc	r23, 7
    3ee8:	80 95       	com	r24
    3eea:	98 2f       	mov	r25, r24
    3eec:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3ef0:	5b 01       	movw	r10, r22
    3ef2:	6c 01       	movw	r12, r24
    3ef4:	80 91 a9 07 	lds	r24, 0x07A9
    3ef8:	90 91 aa 07 	lds	r25, 0x07AA
    3efc:	08 1b       	sub	r16, r24
    3efe:	19 0b       	sbc	r17, r25
    3f00:	b8 01       	movw	r22, r16
    3f02:	88 27       	eor	r24, r24
    3f04:	77 fd       	sbrc	r23, 7
    3f06:	80 95       	com	r24
    3f08:	98 2f       	mov	r25, r24
    3f0a:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3f0e:	20 91 37 04 	lds	r18, 0x0437
    3f12:	30 91 38 04 	lds	r19, 0x0438
    3f16:	40 91 39 04 	lds	r20, 0x0439
    3f1a:	50 91 3a 04 	lds	r21, 0x043A
    3f1e:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    3f22:	9b 01       	movw	r18, r22
    3f24:	ac 01       	movw	r20, r24
    3f26:	c6 01       	movw	r24, r12
    3f28:	b5 01       	movw	r22, r10
    3f2a:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    3f2e:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3f32:	70 93 af 06 	sts	0x06AF, r23
    3f36:	60 93 ae 06 	sts	0x06AE, r22
                        my -= (float)(ay - ayBase) / opt_mouse_scale_mode1[1];
    3f3a:	00 27       	eor	r16, r16
    3f3c:	f7 fc       	sbrc	r15, 7
    3f3e:	00 95       	com	r16
    3f40:	10 2f       	mov	r17, r16
    3f42:	c8 01       	movw	r24, r16
    3f44:	b7 01       	movw	r22, r14
    3f46:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3f4a:	7b 01       	movw	r14, r22
    3f4c:	8c 01       	movw	r16, r24
    3f4e:	80 91 ab 07 	lds	r24, 0x07AB
    3f52:	90 91 ac 07 	lds	r25, 0x07AC
    3f56:	68 1a       	sub	r6, r24
    3f58:	79 0a       	sbc	r7, r25
    3f5a:	b3 01       	movw	r22, r6
    3f5c:	88 27       	eor	r24, r24
    3f5e:	77 fd       	sbrc	r23, 7
    3f60:	80 95       	com	r24
    3f62:	98 2f       	mov	r25, r24
    3f64:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    3f68:	20 91 3b 04 	lds	r18, 0x043B
    3f6c:	30 91 3c 04 	lds	r19, 0x043C
    3f70:	40 91 3d 04 	lds	r20, 0x043D
    3f74:	50 91 3e 04 	lds	r21, 0x043E
    3f78:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    3f7c:	9b 01       	movw	r18, r22
    3f7e:	ac 01       	movw	r20, r24
    3f80:	c8 01       	movw	r24, r16
    3f82:	b7 01       	movw	r22, r14
    3f84:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    3f88:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    3f8c:	70 93 b1 06 	sts	0x06B1, r23
    3f90:	60 93 b0 06 	sts	0x06B0, r22
                        moveMouse = true;
    3f94:	90 92 ac 06 	sts	0x06AC, r9
    3f98:	b5 c1       	rjmp	.+874    	; 0x4304 <loop+0x13a2>
                    } else {
                        axBase = ax;
    3f9a:	10 93 aa 07 	sts	0x07AA, r17
    3f9e:	00 93 a9 07 	sts	0x07A9, r16
                        ayBase = ay;
    3fa2:	70 92 ac 07 	sts	0x07AC, r7
    3fa6:	60 92 ab 07 	sts	0x07AB, r6
                        azBase = az;
    3faa:	80 91 9b 07 	lds	r24, 0x079B
    3fae:	90 91 9c 07 	lds	r25, 0x079C
    3fb2:	90 93 ae 07 	sts	0x07AE, r25
    3fb6:	80 93 ad 07 	sts	0x07AD, r24
                        aset = true;
    3fba:	90 92 af 07 	sts	0x07AF, r9
    3fbe:	a2 c1       	rjmp	.+836    	; 0x4304 <loop+0x13a2>
                    ayBase = ay;
                    azBase = az;
                    aset = true;
                    break;*/
                case MOUSE_MODE_TILT_POSITION:
                    mx0 = mx;
    3fc0:	c0 90 ae 06 	lds	r12, 0x06AE
    3fc4:	d0 90 af 06 	lds	r13, 0x06AF
    3fc8:	d0 92 b7 06 	sts	0x06B7, r13
    3fcc:	c0 92 b6 06 	sts	0x06B6, r12
                    my0 = my;
    3fd0:	80 91 b0 06 	lds	r24, 0x06B0
    3fd4:	90 91 b1 06 	lds	r25, 0x06B1
    3fd8:	90 93 b9 06 	sts	0x06B9, r25
    3fdc:	80 93 b8 06 	sts	0x06B8, r24
                    mx += (gx < 0) ? -sqrt(-gx) : sqrt(gx);
    3fe0:	20 91 dc 07 	lds	r18, 0x07DC
    3fe4:	30 91 dd 07 	lds	r19, 0x07DD
    3fe8:	37 ff       	sbrs	r19, 7
    3fea:	13 c0       	rjmp	.+38     	; 0x4012 <loop+0x10b0>
    3fec:	66 27       	eor	r22, r22
    3fee:	77 27       	eor	r23, r23
    3ff0:	62 1b       	sub	r22, r18
    3ff2:	73 0b       	sbc	r23, r19
    3ff4:	88 27       	eor	r24, r24
    3ff6:	77 fd       	sbrc	r23, 7
    3ff8:	80 95       	com	r24
    3ffa:	98 2f       	mov	r25, r24
    3ffc:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4000:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    4004:	7b 01       	movw	r14, r22
    4006:	8c 01       	movw	r16, r24
    4008:	17 fb       	bst	r17, 7
    400a:	10 95       	com	r17
    400c:	17 f9       	bld	r17, 7
    400e:	10 95       	com	r17
    4010:	0b c0       	rjmp	.+22     	; 0x4028 <loop+0x10c6>
    4012:	b9 01       	movw	r22, r18
    4014:	88 27       	eor	r24, r24
    4016:	77 fd       	sbrc	r23, 7
    4018:	80 95       	com	r24
    401a:	98 2f       	mov	r25, r24
    401c:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4020:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    4024:	7b 01       	movw	r14, r22
    4026:	8c 01       	movw	r16, r24
    4028:	b6 01       	movw	r22, r12
    402a:	88 27       	eor	r24, r24
    402c:	77 fd       	sbrc	r23, 7
    402e:	80 95       	com	r24
    4030:	98 2f       	mov	r25, r24
    4032:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4036:	a8 01       	movw	r20, r16
    4038:	97 01       	movw	r18, r14
    403a:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    403e:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    4042:	70 93 af 06 	sts	0x06AF, r23
    4046:	60 93 ae 06 	sts	0x06AE, r22
                    my += (gy < 0) ? -sqrt(-gy) : sqrt(gy);
    404a:	c0 90 b0 06 	lds	r12, 0x06B0
    404e:	d0 90 b1 06 	lds	r13, 0x06B1
    4052:	20 91 de 07 	lds	r18, 0x07DE
    4056:	30 91 df 07 	lds	r19, 0x07DF
    405a:	37 ff       	sbrs	r19, 7
    405c:	13 c0       	rjmp	.+38     	; 0x4084 <loop+0x1122>
    405e:	66 27       	eor	r22, r22
    4060:	77 27       	eor	r23, r23
    4062:	62 1b       	sub	r22, r18
    4064:	73 0b       	sbc	r23, r19
    4066:	88 27       	eor	r24, r24
    4068:	77 fd       	sbrc	r23, 7
    406a:	80 95       	com	r24
    406c:	98 2f       	mov	r25, r24
    406e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4072:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    4076:	7b 01       	movw	r14, r22
    4078:	8c 01       	movw	r16, r24
    407a:	17 fb       	bst	r17, 7
    407c:	10 95       	com	r17
    407e:	17 f9       	bld	r17, 7
    4080:	10 95       	com	r17
    4082:	0b c0       	rjmp	.+22     	; 0x409a <loop+0x1138>
    4084:	b9 01       	movw	r22, r18
    4086:	88 27       	eor	r24, r24
    4088:	77 fd       	sbrc	r23, 7
    408a:	80 95       	com	r24
    408c:	98 2f       	mov	r25, r24
    408e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4092:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    4096:	7b 01       	movw	r14, r22
    4098:	8c 01       	movw	r16, r24
    409a:	b6 01       	movw	r22, r12
    409c:	88 27       	eor	r24, r24
    409e:	77 fd       	sbrc	r23, 7
    40a0:	80 95       	com	r24
    40a2:	98 2f       	mov	r25, r24
    40a4:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    40a8:	a8 01       	movw	r20, r16
    40aa:	97 01       	movw	r18, r14
    40ac:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    40b0:	73 c0       	rjmp	.+230    	; 0x4198 <loop+0x1236>
                    moveMouse = true;
                    break;
                case MOUSE_MODE_MOVEMENT_POSITION:
                    if (aset) {
    40b2:	80 91 af 07 	lds	r24, 0x07AF
    40b6:	00 91 e9 06 	lds	r16, 0x06E9
    40ba:	10 91 ea 06 	lds	r17, 0x06EA
    40be:	40 90 ed 06 	lds	r4, 0x06ED
    40c2:	50 90 ee 06 	lds	r5, 0x06EE
    40c6:	88 23       	and	r24, r24
    40c8:	09 f4       	brne	.+2      	; 0x40cc <loop+0x116a>
    40ca:	6d c0       	rjmp	.+218    	; 0x41a6 <loop+0x1244>
                        mx0 = mx;
    40cc:	60 91 ae 06 	lds	r22, 0x06AE
    40d0:	70 91 af 06 	lds	r23, 0x06AF
    40d4:	70 93 b7 06 	sts	0x06B7, r23
    40d8:	60 93 b6 06 	sts	0x06B6, r22
                        my0 = my;
    40dc:	e0 90 b0 06 	lds	r14, 0x06B0
    40e0:	f0 90 b1 06 	lds	r15, 0x06B1
    40e4:	f0 92 b9 06 	sts	0x06B9, r15
    40e8:	e0 92 b8 06 	sts	0x06B8, r14
                        mx -= (float)(x - xBase) / opt_mouse_scale_mode3[0];
    40ec:	88 27       	eor	r24, r24
    40ee:	77 fd       	sbrc	r23, 7
    40f0:	80 95       	com	r24
    40f2:	98 2f       	mov	r25, r24
    40f4:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    40f8:	5b 01       	movw	r10, r22
    40fa:	6c 01       	movw	r12, r24
    40fc:	80 91 0d 07 	lds	r24, 0x070D
    4100:	90 91 0e 07 	lds	r25, 0x070E
    4104:	08 1b       	sub	r16, r24
    4106:	19 0b       	sbc	r17, r25
    4108:	b8 01       	movw	r22, r16
    410a:	88 27       	eor	r24, r24
    410c:	77 fd       	sbrc	r23, 7
    410e:	80 95       	com	r24
    4110:	98 2f       	mov	r25, r24
    4112:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4116:	20 91 47 04 	lds	r18, 0x0447
    411a:	30 91 48 04 	lds	r19, 0x0448
    411e:	40 91 49 04 	lds	r20, 0x0449
    4122:	50 91 4a 04 	lds	r21, 0x044A
    4126:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    412a:	9b 01       	movw	r18, r22
    412c:	ac 01       	movw	r20, r24
    412e:	c6 01       	movw	r24, r12
    4130:	b5 01       	movw	r22, r10
    4132:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    4136:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    413a:	70 93 af 06 	sts	0x06AF, r23
    413e:	60 93 ae 06 	sts	0x06AE, r22
                        my -= (float)((z - 256) - zBase) / opt_mouse_scale_mode3[1];
    4142:	00 27       	eor	r16, r16
    4144:	f7 fc       	sbrc	r15, 7
    4146:	00 95       	com	r16
    4148:	10 2f       	mov	r17, r16
    414a:	c8 01       	movw	r24, r16
    414c:	b7 01       	movw	r22, r14
    414e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4152:	7b 01       	movw	r14, r22
    4154:	8c 01       	movw	r16, r24
    4156:	a0 e0       	ldi	r26, 0x00	; 0
    4158:	bf ef       	ldi	r27, 0xFF	; 255
    415a:	4a 0e       	add	r4, r26
    415c:	5b 1e       	adc	r5, r27
    415e:	80 91 11 07 	lds	r24, 0x0711
    4162:	90 91 12 07 	lds	r25, 0x0712
    4166:	48 1a       	sub	r4, r24
    4168:	59 0a       	sbc	r5, r25
    416a:	b2 01       	movw	r22, r4
    416c:	88 27       	eor	r24, r24
    416e:	77 fd       	sbrc	r23, 7
    4170:	80 95       	com	r24
    4172:	98 2f       	mov	r25, r24
    4174:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4178:	20 91 4b 04 	lds	r18, 0x044B
    417c:	30 91 4c 04 	lds	r19, 0x044C
    4180:	40 91 4d 04 	lds	r20, 0x044D
    4184:	50 91 4e 04 	lds	r21, 0x044E
    4188:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    418c:	9b 01       	movw	r18, r22
    418e:	ac 01       	movw	r20, r24
    4190:	c8 01       	movw	r24, r16
    4192:	b7 01       	movw	r22, r14
    4194:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    4198:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    419c:	70 93 b1 06 	sts	0x06B1, r23
    41a0:	60 93 b0 06 	sts	0x06B0, r22
    41a4:	ac c0       	rjmp	.+344    	; 0x42fe <loop+0x139c>
                        moveMouse = true;
                    } else {
                        xBase = x;
    41a6:	10 93 0e 07 	sts	0x070E, r17
    41aa:	00 93 0d 07 	sts	0x070D, r16
                        yBase = y;
    41ae:	80 91 eb 06 	lds	r24, 0x06EB
    41b2:	90 91 ec 06 	lds	r25, 0x06EC
    41b6:	90 93 10 07 	sts	0x0710, r25
    41ba:	80 93 0f 07 	sts	0x070F, r24
                        zBase = z - 256;
    41be:	e0 e0       	ldi	r30, 0x00	; 0
    41c0:	ff ef       	ldi	r31, 0xFF	; 255
    41c2:	4e 0e       	add	r4, r30
    41c4:	5f 1e       	adc	r5, r31
    41c6:	50 92 12 07 	sts	0x0712, r5
    41ca:	40 92 11 07 	sts	0x0711, r4
                        aset = true;
    41ce:	81 e0       	ldi	r24, 0x01	; 1
    41d0:	80 93 af 07 	sts	0x07AF, r24
    41d4:	97 c0       	rjmp	.+302    	; 0x4304 <loop+0x13a2>
                    }
                    break;
                case MOUSE_MODE_3D:
                    mx0 = mx;
    41d6:	60 91 ae 06 	lds	r22, 0x06AE
    41da:	70 91 af 06 	lds	r23, 0x06AF
    41de:	70 93 b7 06 	sts	0x06B7, r23
    41e2:	60 93 b6 06 	sts	0x06B6, r22
                    my0 = my;
    41e6:	e0 90 b0 06 	lds	r14, 0x06B0
    41ea:	f0 90 b1 06 	lds	r15, 0x06B1
    41ee:	f0 92 b9 06 	sts	0x06B9, r15
    41f2:	e0 92 b8 06 	sts	0x06B8, r14
                    mz0 = mz;
    41f6:	a0 90 b2 06 	lds	r10, 0x06B2
    41fa:	b0 90 b3 06 	lds	r11, 0x06B3
    41fe:	b0 92 bb 06 	sts	0x06BB, r11
    4202:	a0 92 ba 06 	sts	0x06BA, r10
                    mx -= xv / opt_mouse_scale_mode4[0];
    4206:	88 27       	eor	r24, r24
    4208:	77 fd       	sbrc	r23, 7
    420a:	80 95       	com	r24
    420c:	98 2f       	mov	r25, r24
    420e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4212:	3b 01       	movw	r6, r22
    4214:	4c 01       	movw	r8, r24
    4216:	60 91 fb 06 	lds	r22, 0x06FB
    421a:	70 91 fc 06 	lds	r23, 0x06FC
    421e:	88 27       	eor	r24, r24
    4220:	77 fd       	sbrc	r23, 7
    4222:	80 95       	com	r24
    4224:	98 2f       	mov	r25, r24
    4226:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    422a:	20 91 4f 04 	lds	r18, 0x044F
    422e:	30 91 50 04 	lds	r19, 0x0450
    4232:	40 91 51 04 	lds	r20, 0x0451
    4236:	50 91 52 04 	lds	r21, 0x0452
    423a:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    423e:	9b 01       	movw	r18, r22
    4240:	ac 01       	movw	r20, r24
    4242:	c4 01       	movw	r24, r8
    4244:	b3 01       	movw	r22, r6
    4246:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    424a:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    424e:	70 93 af 06 	sts	0x06AF, r23
    4252:	60 93 ae 06 	sts	0x06AE, r22
                    my -= zv / opt_mouse_scale_mode4[1];
    4256:	00 27       	eor	r16, r16
    4258:	f7 fc       	sbrc	r15, 7
    425a:	00 95       	com	r16
    425c:	10 2f       	mov	r17, r16
    425e:	c8 01       	movw	r24, r16
    4260:	b7 01       	movw	r22, r14
    4262:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4266:	7b 01       	movw	r14, r22
    4268:	8c 01       	movw	r16, r24
    426a:	60 91 ff 06 	lds	r22, 0x06FF
    426e:	70 91 00 07 	lds	r23, 0x0700
    4272:	88 27       	eor	r24, r24
    4274:	77 fd       	sbrc	r23, 7
    4276:	80 95       	com	r24
    4278:	98 2f       	mov	r25, r24
    427a:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    427e:	20 91 53 04 	lds	r18, 0x0453
    4282:	30 91 54 04 	lds	r19, 0x0454
    4286:	40 91 55 04 	lds	r20, 0x0455
    428a:	50 91 56 04 	lds	r21, 0x0456
    428e:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    4292:	9b 01       	movw	r18, r22
    4294:	ac 01       	movw	r20, r24
    4296:	c8 01       	movw	r24, r16
    4298:	b7 01       	movw	r22, r14
    429a:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    429e:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    42a2:	70 93 b1 06 	sts	0x06B1, r23
    42a6:	60 93 b0 06 	sts	0x06B0, r22
                    mz -= yv / opt_mouse_scale_mode4[2];
    42aa:	cc 24       	eor	r12, r12
    42ac:	b7 fc       	sbrc	r11, 7
    42ae:	c0 94       	com	r12
    42b0:	dc 2c       	mov	r13, r12
    42b2:	c6 01       	movw	r24, r12
    42b4:	b5 01       	movw	r22, r10
    42b6:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    42ba:	7b 01       	movw	r14, r22
    42bc:	8c 01       	movw	r16, r24
    42be:	60 91 fd 06 	lds	r22, 0x06FD
    42c2:	70 91 fe 06 	lds	r23, 0x06FE
    42c6:	88 27       	eor	r24, r24
    42c8:	77 fd       	sbrc	r23, 7
    42ca:	80 95       	com	r24
    42cc:	98 2f       	mov	r25, r24
    42ce:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    42d2:	20 91 57 04 	lds	r18, 0x0457
    42d6:	30 91 58 04 	lds	r19, 0x0458
    42da:	40 91 59 04 	lds	r20, 0x0459
    42de:	50 91 5a 04 	lds	r21, 0x045A
    42e2:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    42e6:	9b 01       	movw	r18, r22
    42e8:	ac 01       	movw	r20, r24
    42ea:	c8 01       	movw	r24, r16
    42ec:	b7 01       	movw	r22, r14
    42ee:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    42f2:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    42f6:	70 93 b3 06 	sts	0x06B3, r23
    42fa:	60 93 b2 06 	sts	0x06B2, r22
                    moveMouse = true;
    42fe:	81 e0       	ldi	r24, 0x01	; 1
    4300:	80 93 ac 06 	sts	0x06AC, r24
                    break;
            }
            switch (opt_scroll_mode) {
    4304:	90 90 d2 06 	lds	r9, 0x06D2
    4308:	f2 e0       	ldi	r31, 0x02	; 2
    430a:	9f 16       	cp	r9, r31
    430c:	09 f4       	brne	.+2      	; 0x4310 <loop+0x13ae>
    430e:	93 c0       	rjmp	.+294    	; 0x4436 <loop+0x14d4>
    4310:	23 e0       	ldi	r18, 0x03	; 3
    4312:	92 16       	cp	r9, r18
    4314:	09 f4       	brne	.+2      	; 0x4318 <loop+0x13b6>
    4316:	d0 c0       	rjmp	.+416    	; 0x44b8 <loop+0x1556>
    4318:	31 e0       	ldi	r19, 0x01	; 1
    431a:	93 16       	cp	r9, r19
    431c:	09 f0       	breq	.+2      	; 0x4320 <loop+0x13be>
    431e:	60 c1       	rjmp	.+704    	; 0x45e0 <loop+0x167e>
                case SCROLL_MODE_TILT_VELOCITY: // gyro
                    if (aset) {
    4320:	80 91 af 07 	lds	r24, 0x07AF
    4324:	00 91 97 07 	lds	r16, 0x0797
    4328:	10 91 98 07 	lds	r17, 0x0798
    432c:	60 90 99 07 	lds	r6, 0x0799
    4330:	70 90 9a 07 	lds	r7, 0x079A
    4334:	88 23       	and	r24, r24
    4336:	09 f4       	brne	.+2      	; 0x433a <loop+0x13d8>
    4338:	6b c0       	rjmp	.+214    	; 0x4410 <loop+0x14ae>
                        mx0 = mx;
    433a:	60 91 ae 06 	lds	r22, 0x06AE
    433e:	70 91 af 06 	lds	r23, 0x06AF
    4342:	70 93 b7 06 	sts	0x06B7, r23
    4346:	60 93 b6 06 	sts	0x06B6, r22
                        my0 = my;
    434a:	e0 90 b0 06 	lds	r14, 0x06B0
    434e:	f0 90 b1 06 	lds	r15, 0x06B1
    4352:	f0 92 b9 06 	sts	0x06B9, r15
    4356:	e0 92 b8 06 	sts	0x06B8, r14
                        mx -= (float)(ax - axBase) / opt_mouse_scale_mode1[0];
    435a:	88 27       	eor	r24, r24
    435c:	77 fd       	sbrc	r23, 7
    435e:	80 95       	com	r24
    4360:	98 2f       	mov	r25, r24
    4362:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4366:	5b 01       	movw	r10, r22
    4368:	6c 01       	movw	r12, r24
    436a:	80 91 a9 07 	lds	r24, 0x07A9
    436e:	90 91 aa 07 	lds	r25, 0x07AA
    4372:	08 1b       	sub	r16, r24
    4374:	19 0b       	sbc	r17, r25
    4376:	b8 01       	movw	r22, r16
    4378:	88 27       	eor	r24, r24
    437a:	77 fd       	sbrc	r23, 7
    437c:	80 95       	com	r24
    437e:	98 2f       	mov	r25, r24
    4380:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4384:	20 91 37 04 	lds	r18, 0x0437
    4388:	30 91 38 04 	lds	r19, 0x0438
    438c:	40 91 39 04 	lds	r20, 0x0439
    4390:	50 91 3a 04 	lds	r21, 0x043A
    4394:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    4398:	9b 01       	movw	r18, r22
    439a:	ac 01       	movw	r20, r24
    439c:	c6 01       	movw	r24, r12
    439e:	b5 01       	movw	r22, r10
    43a0:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    43a4:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    43a8:	70 93 af 06 	sts	0x06AF, r23
    43ac:	60 93 ae 06 	sts	0x06AE, r22
                        my -= (float)(ay - ayBase) / opt_mouse_scale_mode1[1];
    43b0:	00 27       	eor	r16, r16
    43b2:	f7 fc       	sbrc	r15, 7
    43b4:	00 95       	com	r16
    43b6:	10 2f       	mov	r17, r16
    43b8:	c8 01       	movw	r24, r16
    43ba:	b7 01       	movw	r22, r14
    43bc:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    43c0:	7b 01       	movw	r14, r22
    43c2:	8c 01       	movw	r16, r24
    43c4:	80 91 ab 07 	lds	r24, 0x07AB
    43c8:	90 91 ac 07 	lds	r25, 0x07AC
    43cc:	68 1a       	sub	r6, r24
    43ce:	79 0a       	sbc	r7, r25
    43d0:	b3 01       	movw	r22, r6
    43d2:	88 27       	eor	r24, r24
    43d4:	77 fd       	sbrc	r23, 7
    43d6:	80 95       	com	r24
    43d8:	98 2f       	mov	r25, r24
    43da:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    43de:	20 91 3b 04 	lds	r18, 0x043B
    43e2:	30 91 3c 04 	lds	r19, 0x043C
    43e6:	40 91 3d 04 	lds	r20, 0x043D
    43ea:	50 91 3e 04 	lds	r21, 0x043E
    43ee:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    43f2:	9b 01       	movw	r18, r22
    43f4:	ac 01       	movw	r20, r24
    43f6:	c8 01       	movw	r24, r16
    43f8:	b7 01       	movw	r22, r14
    43fa:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    43fe:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    4402:	70 93 b1 06 	sts	0x06B1, r23
    4406:	60 93 b0 06 	sts	0x06B0, r22
                        scrollMouse = true;
    440a:	90 92 ad 06 	sts	0x06AD, r9
    440e:	e8 c0       	rjmp	.+464    	; 0x45e0 <loop+0x167e>
                    } else {
                        axBase = ax;
    4410:	10 93 aa 07 	sts	0x07AA, r17
    4414:	00 93 a9 07 	sts	0x07A9, r16
                        ayBase = ay;
    4418:	70 92 ac 07 	sts	0x07AC, r7
    441c:	60 92 ab 07 	sts	0x07AB, r6
                        azBase = az;
    4420:	80 91 9b 07 	lds	r24, 0x079B
    4424:	90 91 9c 07 	lds	r25, 0x079C
    4428:	90 93 ae 07 	sts	0x07AE, r25
    442c:	80 93 ad 07 	sts	0x07AD, r24
                        aset = true;
    4430:	90 92 af 07 	sts	0x07AF, r9
    4434:	d5 c0       	rjmp	.+426    	; 0x45e0 <loop+0x167e>
                    }
                    break;
                case SCROLL_MODE_TILT_POSITION: // gyro
                    sy0 = sy;
    4436:	c0 90 b4 06 	lds	r12, 0x06B4
    443a:	d0 90 b5 06 	lds	r13, 0x06B5
    443e:	d0 92 bd 06 	sts	0x06BD, r13
    4442:	c0 92 bc 06 	sts	0x06BC, r12
                    sy -= (gx < 0) ? -sqrt(-gx / 30) : sqrt(gx / 30);
    4446:	80 91 dc 07 	lds	r24, 0x07DC
    444a:	90 91 dd 07 	lds	r25, 0x07DD
    444e:	97 ff       	sbrs	r25, 7
    4450:	13 c0       	rjmp	.+38     	; 0x4478 <loop+0x1516>
    4452:	62 ee       	ldi	r22, 0xE2	; 226
    4454:	7f ef       	ldi	r23, 0xFF	; 255
    4456:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    445a:	88 27       	eor	r24, r24
    445c:	77 fd       	sbrc	r23, 7
    445e:	80 95       	com	r24
    4460:	98 2f       	mov	r25, r24
    4462:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4466:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    446a:	7b 01       	movw	r14, r22
    446c:	8c 01       	movw	r16, r24
    446e:	17 fb       	bst	r17, 7
    4470:	10 95       	com	r17
    4472:	17 f9       	bld	r17, 7
    4474:	10 95       	com	r17
    4476:	0e c0       	rjmp	.+28     	; 0x4494 <loop+0x1532>
    4478:	6e e1       	ldi	r22, 0x1E	; 30
    447a:	70 e0       	ldi	r23, 0x00	; 0
    447c:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4480:	88 27       	eor	r24, r24
    4482:	77 fd       	sbrc	r23, 7
    4484:	80 95       	com	r24
    4486:	98 2f       	mov	r25, r24
    4488:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    448c:	0e 94 26 42 	call	0x844c	; 0x844c <sqrt>
    4490:	7b 01       	movw	r14, r22
    4492:	8c 01       	movw	r16, r24
    4494:	b6 01       	movw	r22, r12
    4496:	88 27       	eor	r24, r24
    4498:	77 fd       	sbrc	r23, 7
    449a:	80 95       	com	r24
    449c:	98 2f       	mov	r25, r24
    449e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    44a2:	a8 01       	movw	r20, r16
    44a4:	97 01       	movw	r18, r14
    44a6:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    44aa:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    44ae:	70 93 b5 06 	sts	0x06B5, r23
    44b2:	60 93 b4 06 	sts	0x06B4, r22
    44b6:	79 c0       	rjmp	.+242    	; 0x45aa <loop+0x1648>
                    scrollMouse = true;
                    break;
                case SCROLL_MODE_MOVEMENT_POSITION: // accel
                    if (aset) {
    44b8:	80 91 af 07 	lds	r24, 0x07AF
    44bc:	00 91 e9 06 	lds	r16, 0x06E9
    44c0:	10 91 ea 06 	lds	r17, 0x06EA
    44c4:	40 90 ed 06 	lds	r4, 0x06ED
    44c8:	50 90 ee 06 	lds	r5, 0x06EE
    44cc:	88 23       	and	r24, r24
    44ce:	09 f4       	brne	.+2      	; 0x44d2 <loop+0x1570>
    44d0:	70 c0       	rjmp	.+224    	; 0x45b2 <loop+0x1650>
                        mx0 = mx;
    44d2:	60 91 ae 06 	lds	r22, 0x06AE
    44d6:	70 91 af 06 	lds	r23, 0x06AF
    44da:	70 93 b7 06 	sts	0x06B7, r23
    44de:	60 93 b6 06 	sts	0x06B6, r22
                        my0 = my;
    44e2:	e0 90 b0 06 	lds	r14, 0x06B0
    44e6:	f0 90 b1 06 	lds	r15, 0x06B1
    44ea:	f0 92 b9 06 	sts	0x06B9, r15
    44ee:	e0 92 b8 06 	sts	0x06B8, r14
                        mx -= (float)(x - xBase) / opt_mouse_scale_mode3[0];
    44f2:	88 27       	eor	r24, r24
    44f4:	77 fd       	sbrc	r23, 7
    44f6:	80 95       	com	r24
    44f8:	98 2f       	mov	r25, r24
    44fa:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    44fe:	5b 01       	movw	r10, r22
    4500:	6c 01       	movw	r12, r24
    4502:	80 91 0d 07 	lds	r24, 0x070D
    4506:	90 91 0e 07 	lds	r25, 0x070E
    450a:	08 1b       	sub	r16, r24
    450c:	19 0b       	sbc	r17, r25
    450e:	b8 01       	movw	r22, r16
    4510:	88 27       	eor	r24, r24
    4512:	77 fd       	sbrc	r23, 7
    4514:	80 95       	com	r24
    4516:	98 2f       	mov	r25, r24
    4518:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    451c:	20 91 47 04 	lds	r18, 0x0447
    4520:	30 91 48 04 	lds	r19, 0x0448
    4524:	40 91 49 04 	lds	r20, 0x0449
    4528:	50 91 4a 04 	lds	r21, 0x044A
    452c:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    4530:	9b 01       	movw	r18, r22
    4532:	ac 01       	movw	r20, r24
    4534:	c6 01       	movw	r24, r12
    4536:	b5 01       	movw	r22, r10
    4538:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    453c:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    4540:	70 93 af 06 	sts	0x06AF, r23
    4544:	60 93 ae 06 	sts	0x06AE, r22
                        my -= (float)((z - 256) - zBase) / opt_mouse_scale_mode3[1];
    4548:	00 27       	eor	r16, r16
    454a:	f7 fc       	sbrc	r15, 7
    454c:	00 95       	com	r16
    454e:	10 2f       	mov	r17, r16
    4550:	c8 01       	movw	r24, r16
    4552:	b7 01       	movw	r22, r14
    4554:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    4558:	7b 01       	movw	r14, r22
    455a:	8c 01       	movw	r16, r24
    455c:	80 e0       	ldi	r24, 0x00	; 0
    455e:	9f ef       	ldi	r25, 0xFF	; 255
    4560:	48 0e       	add	r4, r24
    4562:	59 1e       	adc	r5, r25
    4564:	80 91 11 07 	lds	r24, 0x0711
    4568:	90 91 12 07 	lds	r25, 0x0712
    456c:	48 1a       	sub	r4, r24
    456e:	59 0a       	sbc	r5, r25
    4570:	b2 01       	movw	r22, r4
    4572:	88 27       	eor	r24, r24
    4574:	77 fd       	sbrc	r23, 7
    4576:	80 95       	com	r24
    4578:	98 2f       	mov	r25, r24
    457a:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    457e:	20 91 4b 04 	lds	r18, 0x044B
    4582:	30 91 4c 04 	lds	r19, 0x044C
    4586:	40 91 4d 04 	lds	r20, 0x044D
    458a:	50 91 4e 04 	lds	r21, 0x044E
    458e:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    4592:	9b 01       	movw	r18, r22
    4594:	ac 01       	movw	r20, r24
    4596:	c8 01       	movw	r24, r16
    4598:	b7 01       	movw	r22, r14
    459a:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <__subsf3>
    459e:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    45a2:	70 93 b1 06 	sts	0x06B1, r23
    45a6:	60 93 b0 06 	sts	0x06B0, r22
                        scrollMouse = true;
    45aa:	81 e0       	ldi	r24, 0x01	; 1
    45ac:	80 93 ad 06 	sts	0x06AD, r24
    45b0:	17 c0       	rjmp	.+46     	; 0x45e0 <loop+0x167e>
                    } else {
                        xBase = x;
    45b2:	10 93 0e 07 	sts	0x070E, r17
    45b6:	00 93 0d 07 	sts	0x070D, r16
                        yBase = y;
    45ba:	80 91 eb 06 	lds	r24, 0x06EB
    45be:	90 91 ec 06 	lds	r25, 0x06EC
    45c2:	90 93 10 07 	sts	0x0710, r25
    45c6:	80 93 0f 07 	sts	0x070F, r24
                        zBase = z - 256;
    45ca:	a0 e0       	ldi	r26, 0x00	; 0
    45cc:	bf ef       	ldi	r27, 0xFF	; 255
    45ce:	4a 0e       	add	r4, r26
    45d0:	5b 1e       	adc	r5, r27
    45d2:	50 92 12 07 	sts	0x0712, r5
    45d6:	40 92 11 07 	sts	0x0711, r4
                        aset = true;
    45da:	81 e0       	ldi	r24, 0x01	; 1
    45dc:	80 93 af 07 	sts	0x07AF, r24
    
        //if (BOUND_MOUSEX > 0 && abs(mx) > BOUND_MOUSEX) mx = mx < 0 ? -BOUND_MOUSEX : BOUND_MOUSEX;
        //if (BOUND_MOUSEY > 0 && abs(my) > BOUND_MOUSEY) my = my < 0 ? -BOUND_MOUSEY : BOUND_MOUSEY;
    
        // get relative movement amounts
        mdx = mx - mx0;
    45e0:	40 91 ae 06 	lds	r20, 0x06AE
    45e4:	50 91 af 06 	lds	r21, 0x06AF
    45e8:	80 91 b6 06 	lds	r24, 0x06B6
    45ec:	90 91 b7 06 	lds	r25, 0x06B7
    45f0:	48 1b       	sub	r20, r24
    45f2:	59 0b       	sbc	r21, r25
    45f4:	50 93 bf 06 	sts	0x06BF, r21
    45f8:	40 93 be 06 	sts	0x06BE, r20
        mdy = my - my0;
    45fc:	80 91 b0 06 	lds	r24, 0x06B0
    4600:	90 91 b1 06 	lds	r25, 0x06B1
    4604:	20 91 b8 06 	lds	r18, 0x06B8
    4608:	30 91 b9 06 	lds	r19, 0x06B9
    460c:	82 1b       	sub	r24, r18
    460e:	93 0b       	sbc	r25, r19
    4610:	90 93 c1 06 	sts	0x06C1, r25
    4614:	80 93 c0 06 	sts	0x06C0, r24
        mdz = mz - mz0;
    4618:	80 91 b2 06 	lds	r24, 0x06B2
    461c:	90 91 b3 06 	lds	r25, 0x06B3
    4620:	20 91 ba 06 	lds	r18, 0x06BA
    4624:	30 91 bb 06 	lds	r19, 0x06BB
    4628:	82 1b       	sub	r24, r18
    462a:	93 0b       	sbc	r25, r19
    462c:	90 93 c3 06 	sts	0x06C3, r25
    4630:	80 93 c2 06 	sts	0x06C2, r24

        if (opt_mouse_invert_x == 1) mdx = -mdx;
    4634:	80 91 35 04 	lds	r24, 0x0435
    4638:	81 30       	cpi	r24, 0x01	; 1
    463a:	41 f4       	brne	.+16     	; 0x464c <loop+0x16ea>
    463c:	88 27       	eor	r24, r24
    463e:	99 27       	eor	r25, r25
    4640:	84 1b       	sub	r24, r20
    4642:	95 0b       	sbc	r25, r21
    4644:	90 93 bf 06 	sts	0x06BF, r25
    4648:	80 93 be 06 	sts	0x06BE, r24
        if (opt_mouse_invert_y == 1) mdy = -mdy;
    464c:	80 91 36 04 	lds	r24, 0x0436
    4650:	81 30       	cpi	r24, 0x01	; 1
    4652:	59 f4       	brne	.+22     	; 0x466a <loop+0x1708>
    4654:	80 91 c0 06 	lds	r24, 0x06C0
    4658:	90 91 c1 06 	lds	r25, 0x06C1
    465c:	90 95       	com	r25
    465e:	81 95       	neg	r24
    4660:	9f 4f       	sbci	r25, 0xFF	; 255
    4662:	90 93 c1 06 	sts	0x06C1, r25
    4666:	80 93 c0 06 	sts	0x06C0, r24
        if (opt_mouse_invert_z == 1) mdz = -mdz;
    466a:	80 91 d0 06 	lds	r24, 0x06D0
    466e:	81 30       	cpi	r24, 0x01	; 1
    4670:	59 f4       	brne	.+22     	; 0x4688 <loop+0x1726>
    4672:	80 91 c2 06 	lds	r24, 0x06C2
    4676:	90 91 c3 06 	lds	r25, 0x06C3
    467a:	90 95       	com	r25
    467c:	81 95       	neg	r24
    467e:	9f 4f       	sbci	r25, 0xFF	; 255
    4680:	90 93 c3 06 	sts	0x06C3, r25
    4684:	80 93 c2 06 	sts	0x06C2, r24
        if (moveMouse && opt_mouse_mode > 0 && (mdx != 0 || mdy != 0 || mdz != 0)) {
    4688:	80 91 ac 06 	lds	r24, 0x06AC
    468c:	88 23       	and	r24, r24
    468e:	59 f1       	breq	.+86     	; 0x46e6 <loop+0x1784>
    4690:	80 91 d1 06 	lds	r24, 0x06D1
    4694:	88 23       	and	r24, r24
    4696:	39 f1       	breq	.+78     	; 0x46e6 <loop+0x1784>
    4698:	60 91 be 06 	lds	r22, 0x06BE
    469c:	70 91 bf 06 	lds	r23, 0x06BF
    46a0:	61 15       	cp	r22, r1
    46a2:	71 05       	cpc	r23, r1
    46a4:	61 f4       	brne	.+24     	; 0x46be <loop+0x175c>
    46a6:	80 91 c0 06 	lds	r24, 0x06C0
    46aa:	90 91 c1 06 	lds	r25, 0x06C1
    46ae:	89 2b       	or	r24, r25
    46b0:	31 f4       	brne	.+12     	; 0x46be <loop+0x175c>
    46b2:	80 91 c2 06 	lds	r24, 0x06C2
    46b6:	90 91 c3 06 	lds	r25, 0x06C3
    46ba:	89 2b       	or	r24, r25
    46bc:	a1 f0       	breq	.+40     	; 0x46e6 <loop+0x1784>
            #ifdef ENABLE_USB
                if (mdz > 0) Mouse.move(mdx, mdy, mdz);
    46be:	20 91 c2 06 	lds	r18, 0x06C2
    46c2:	30 91 c3 06 	lds	r19, 0x06C3
    46c6:	12 16       	cp	r1, r18
    46c8:	13 06       	cpc	r1, r19
    46ca:	3c f4       	brge	.+14     	; 0x46da <loop+0x1778>
    46cc:	80 e1       	ldi	r24, 0x10	; 16
    46ce:	99 e0       	ldi	r25, 0x09	; 9
    46d0:	40 91 c0 06 	lds	r20, 0x06C0
    46d4:	0e 94 9a 2d 	call	0x5b34	; 0x5b34 <_ZN8USBMouse4moveEhhh>
    46d8:	06 c0       	rjmp	.+12     	; 0x46e6 <loop+0x1784>
                else Mouse.move(mdx, mdy);
    46da:	80 e1       	ldi	r24, 0x10	; 16
    46dc:	99 e0       	ldi	r25, 0x09	; 9
    46de:	40 91 c0 06 	lds	r20, 0x06C0
    46e2:	0e 94 aa 2d 	call	0x5b54	; 0x5b54 <_ZN8USBMouse4moveEhh>
                Serial.print(mdy); Serial.print(" ");
                Serial.print(mdz); Serial.print(" ");
                Serial.println(mdz);
            #endif /* SERIAL_DEBUG_MOUSE */
        }
        if (scrollMouse && opt_scroll_mode > 0 && sdy != 0) {
    46e6:	80 91 ad 06 	lds	r24, 0x06AD
    46ea:	88 23       	and	r24, r24
    46ec:	79 f0       	breq	.+30     	; 0x470c <loop+0x17aa>
    46ee:	80 91 d2 06 	lds	r24, 0x06D2
    46f2:	88 23       	and	r24, r24
    46f4:	59 f0       	breq	.+22     	; 0x470c <loop+0x17aa>
    46f6:	60 91 c4 06 	lds	r22, 0x06C4
    46fa:	70 91 c5 06 	lds	r23, 0x06C5
    46fe:	61 15       	cp	r22, r1
    4700:	71 05       	cpc	r23, r1
    4702:	21 f0       	breq	.+8      	; 0x470c <loop+0x17aa>
            #ifdef ENABLE_USB
                Mouse.scroll(sdy);
    4704:	80 e1       	ldi	r24, 0x10	; 16
    4706:	99 e0       	ldi	r25, 0x09	; 9
    4708:	0e 94 77 2d 	call	0x5aee	; 0x5aee <_ZN8USBMouse6scrollEh>

    /* ===============================================
     * READ AND PROCESS TOUCH DATA
    =============================================== */
    #ifdef ENABLE_TOUCH
        detect1 = 0;
    470c:	10 92 bb 08 	sts	0x08BB, r1
    4710:	10 92 bc 08 	sts	0x08BC, r1
    4714:	10 92 bd 08 	sts	0x08BD, r1
    4718:	10 92 be 08 	sts	0x08BE, r1
        detect2 = 0;
    471c:	10 92 bf 08 	sts	0x08BF, r1
    4720:	10 92 c0 08 	sts	0x08C0, r1
    4724:	10 92 c1 08 	sts	0x08C1, r1
    4728:	10 92 c2 08 	sts	0x08C2, r1
        removing = false;
    472c:	10 92 ba 08 	sts	0x08BA, r1
    
        // loop through every possible 1-to-1 sensor combination and record levels
        for (i = 0; i < KG_BASE_COMBINATIONS; i++) {
    4730:	10 92 a8 06 	sts	0x06A8, r1
    4734:	10 92 a9 06 	sts	0x06A9, r1
    4738:	10 92 aa 06 	sts	0x06AA, r1
    473c:	10 92 ab 06 	sts	0x06AB, r1
            if (i < 32) {
                // write value to sensors1
                if (digitalRead(p2) == LOW) bitSet(detect1, i);
            } else {
                // write value to sensors2
                if (digitalRead(p2) == LOW) bitSet(detect2, i - 32);
    4740:	11 e0       	ldi	r17, 0x01	; 1
    4742:	c1 2e       	mov	r12, r17
    4744:	d1 2c       	mov	r13, r1
    4746:	e1 2c       	mov	r14, r1
    4748:	f1 2c       	mov	r15, r1
    474a:	87 c0       	rjmp	.+270    	; 0x485a <loop+0x18f8>
        removing = false;
    
        // loop through every possible 1-to-1 sensor combination and record levels
        for (i = 0; i < KG_BASE_COMBINATIONS; i++) {
            int p1 = combinations[i][0];
            int p2 = combinations[i][1];
    474c:	fc 01       	movw	r30, r24
    474e:	ee 0f       	add	r30, r30
    4750:	ff 1f       	adc	r31, r31
    4752:	ee 0f       	add	r30, r30
    4754:	ff 1f       	adc	r31, r31
    4756:	df 01       	movw	r26, r30
    4758:	a5 5e       	subi	r26, 0xE5	; 229
    475a:	bc 4f       	sbci	r27, 0xFC	; 252
    475c:	0c 91       	ld	r16, X
    
            pinMode(p1, OUTPUT);    // change to OUTPUT mode
    475e:	e7 5e       	subi	r30, 0xE7	; 231
    4760:	fc 4f       	sbci	r31, 0xFC	; 252
    4762:	10 81       	ld	r17, Z
    4764:	81 2f       	mov	r24, r17
    4766:	61 e0       	ldi	r22, 0x01	; 1
    4768:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
            digitalWrite(p1, LOW);  // bring LOW (default input level is HIGH)
    476c:	81 2f       	mov	r24, r17
    476e:	60 e0       	ldi	r22, 0x00	; 0
    4770:	9f d7       	rcall	.+3902   	; 0x56b0 <digitalWrite>
            if (i < 32) {
    4772:	80 91 a8 06 	lds	r24, 0x06A8
    4776:	90 91 a9 06 	lds	r25, 0x06A9
    477a:	a0 91 aa 06 	lds	r26, 0x06AA
    477e:	b0 91 ab 06 	lds	r27, 0x06AB
    4782:	80 97       	sbiw	r24, 0x20	; 32
    4784:	a1 05       	cpc	r26, r1
    4786:	b1 05       	cpc	r27, r1
    4788:	2c f5       	brge	.+74     	; 0x47d4 <loop+0x1872>
                // write value to sensors1
                if (digitalRead(p2) == LOW) bitSet(detect1, i);
    478a:	80 2f       	mov	r24, r16
    478c:	36 d7       	rcall	.+3692   	; 0x55fa <digitalRead>
    478e:	89 2b       	or	r24, r25
    4790:	09 f0       	breq	.+2      	; 0x4794 <loop+0x1832>
    4792:	49 c0       	rjmp	.+146    	; 0x4826 <loop+0x18c4>
    4794:	a7 01       	movw	r20, r14
    4796:	96 01       	movw	r18, r12
    4798:	00 90 a8 06 	lds	r0, 0x06A8
    479c:	04 c0       	rjmp	.+8      	; 0x47a6 <loop+0x1844>
    479e:	22 0f       	add	r18, r18
    47a0:	33 1f       	adc	r19, r19
    47a2:	44 1f       	adc	r20, r20
    47a4:	55 1f       	adc	r21, r21
    47a6:	0a 94       	dec	r0
    47a8:	d2 f7       	brpl	.-12     	; 0x479e <loop+0x183c>
    47aa:	80 91 bb 08 	lds	r24, 0x08BB
    47ae:	90 91 bc 08 	lds	r25, 0x08BC
    47b2:	a0 91 bd 08 	lds	r26, 0x08BD
    47b6:	b0 91 be 08 	lds	r27, 0x08BE
    47ba:	82 2b       	or	r24, r18
    47bc:	93 2b       	or	r25, r19
    47be:	a4 2b       	or	r26, r20
    47c0:	b5 2b       	or	r27, r21
    47c2:	80 93 bb 08 	sts	0x08BB, r24
    47c6:	90 93 bc 08 	sts	0x08BC, r25
    47ca:	a0 93 bd 08 	sts	0x08BD, r26
    47ce:	b0 93 be 08 	sts	0x08BE, r27
    47d2:	29 c0       	rjmp	.+82     	; 0x4826 <loop+0x18c4>
            } else {
                // write value to sensors2
                if (digitalRead(p2) == LOW) bitSet(detect2, i - 32);
    47d4:	80 2f       	mov	r24, r16
    47d6:	11 d7       	rcall	.+3618   	; 0x55fa <digitalRead>
    47d8:	89 2b       	or	r24, r25
    47da:	29 f5       	brne	.+74     	; 0x4826 <loop+0x18c4>
    47dc:	20 91 a8 06 	lds	r18, 0x06A8
    47e0:	30 91 a9 06 	lds	r19, 0x06A9
    47e4:	20 52       	subi	r18, 0x20	; 32
    47e6:	30 40       	sbci	r19, 0x00	; 0
    47e8:	d7 01       	movw	r26, r14
    47ea:	c6 01       	movw	r24, r12
    47ec:	04 c0       	rjmp	.+8      	; 0x47f6 <loop+0x1894>
    47ee:	88 0f       	add	r24, r24
    47f0:	99 1f       	adc	r25, r25
    47f2:	aa 1f       	adc	r26, r26
    47f4:	bb 1f       	adc	r27, r27
    47f6:	2a 95       	dec	r18
    47f8:	d2 f7       	brpl	.-12     	; 0x47ee <loop+0x188c>
    47fa:	9c 01       	movw	r18, r24
    47fc:	ad 01       	movw	r20, r26
    47fe:	80 91 bf 08 	lds	r24, 0x08BF
    4802:	90 91 c0 08 	lds	r25, 0x08C0
    4806:	a0 91 c1 08 	lds	r26, 0x08C1
    480a:	b0 91 c2 08 	lds	r27, 0x08C2
    480e:	82 2b       	or	r24, r18
    4810:	93 2b       	or	r25, r19
    4812:	a4 2b       	or	r26, r20
    4814:	b5 2b       	or	r27, r21
    4816:	80 93 bf 08 	sts	0x08BF, r24
    481a:	90 93 c0 08 	sts	0x08C0, r25
    481e:	a0 93 c1 08 	sts	0x08C1, r26
    4822:	b0 93 c2 08 	sts	0x08C2, r27
            }
            pinMode(p1, INPUT);     // reset to INPUT mode
    4826:	81 2f       	mov	r24, r17
    4828:	60 e0       	ldi	r22, 0x00	; 0
    482a:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <pinMode>
            digitalWrite(p1, HIGH); // enable pullup
    482e:	81 2f       	mov	r24, r17
    4830:	61 e0       	ldi	r22, 0x01	; 1
    4832:	3e d7       	rcall	.+3708   	; 0x56b0 <digitalWrite>
        detect1 = 0;
        detect2 = 0;
        removing = false;
    
        // loop through every possible 1-to-1 sensor combination and record levels
        for (i = 0; i < KG_BASE_COMBINATIONS; i++) {
    4834:	80 91 a8 06 	lds	r24, 0x06A8
    4838:	90 91 a9 06 	lds	r25, 0x06A9
    483c:	a0 91 aa 06 	lds	r26, 0x06AA
    4840:	b0 91 ab 06 	lds	r27, 0x06AB
    4844:	01 96       	adiw	r24, 0x01	; 1
    4846:	a1 1d       	adc	r26, r1
    4848:	b1 1d       	adc	r27, r1
    484a:	80 93 a8 06 	sts	0x06A8, r24
    484e:	90 93 a9 06 	sts	0x06A9, r25
    4852:	a0 93 aa 06 	sts	0x06AA, r26
    4856:	b0 93 ab 06 	sts	0x06AB, r27
    485a:	80 91 a8 06 	lds	r24, 0x06A8
    485e:	90 91 a9 06 	lds	r25, 0x06A9
    4862:	a0 91 aa 06 	lds	r26, 0x06AA
    4866:	b0 91 ab 06 	lds	r27, 0x06AB
    486a:	8c 33       	cpi	r24, 0x3C	; 60
    486c:	91 05       	cpc	r25, r1
    486e:	a1 05       	cpc	r26, r1
    4870:	b1 05       	cpc	r27, r1
    4872:	0c f4       	brge	.+2      	; 0x4876 <loop+0x1914>
    4874:	6b cf       	rjmp	.-298    	; 0x474c <loop+0x17ea>
            pinMode(p1, INPUT);     // reset to INPUT mode
            digitalWrite(p1, HIGH); // enable pullup
        }
        
        // check to see if we need to reset detection threshold
        if (verify1 != detect1 || verify2 != detect2) {
    4876:	e0 90 c3 08 	lds	r14, 0x08C3
    487a:	f0 90 c4 08 	lds	r15, 0x08C4
    487e:	00 91 c5 08 	lds	r16, 0x08C5
    4882:	10 91 c6 08 	lds	r17, 0x08C6
    4886:	80 91 bb 08 	lds	r24, 0x08BB
    488a:	90 91 bc 08 	lds	r25, 0x08BC
    488e:	a0 91 bd 08 	lds	r26, 0x08BD
    4892:	b0 91 be 08 	lds	r27, 0x08BE
    4896:	e8 16       	cp	r14, r24
    4898:	f9 06       	cpc	r15, r25
    489a:	0a 07       	cpc	r16, r26
    489c:	1b 07       	cpc	r17, r27
    489e:	a9 f4       	brne	.+42     	; 0x48ca <loop+0x1968>
    48a0:	20 91 c7 08 	lds	r18, 0x08C7
    48a4:	30 91 c8 08 	lds	r19, 0x08C8
    48a8:	40 91 c9 08 	lds	r20, 0x08C9
    48ac:	50 91 ca 08 	lds	r21, 0x08CA
    48b0:	80 91 bf 08 	lds	r24, 0x08BF
    48b4:	90 91 c0 08 	lds	r25, 0x08C0
    48b8:	a0 91 c1 08 	lds	r26, 0x08C1
    48bc:	b0 91 c2 08 	lds	r27, 0x08C2
    48c0:	28 17       	cp	r18, r24
    48c2:	39 07       	cpc	r19, r25
    48c4:	4a 07       	cpc	r20, r26
    48c6:	5b 07       	cpc	r21, r27
    48c8:	59 f0       	breq	.+22     	; 0x48e0 <loop+0x197e>
            // current sensors different from last detection, so reset threshold
            touchTime = millis();
    48ca:	0e 94 b6 39 	call	0x736c	; 0x736c <millis>
    48ce:	60 93 b5 08 	sts	0x08B5, r22
    48d2:	70 93 b6 08 	sts	0x08B6, r23
    48d6:	80 93 b7 08 	sts	0x08B7, r24
    48da:	90 93 b8 08 	sts	0x08B8, r25
    48de:	1a c1       	rjmp	.+564    	; 0x4b14 <loop+0x1bb2>
        } else if ((verify1 != sensors1 || verify2 != sensors2) && millis() - touchTime >= opt_touch_detect_threshold) {
    48e0:	80 91 cb 08 	lds	r24, 0x08CB
    48e4:	90 91 cc 08 	lds	r25, 0x08CC
    48e8:	a0 91 cd 08 	lds	r26, 0x08CD
    48ec:	b0 91 ce 08 	lds	r27, 0x08CE
    48f0:	e8 16       	cp	r14, r24
    48f2:	f9 06       	cpc	r15, r25
    48f4:	0a 07       	cpc	r16, r26
    48f6:	1b 07       	cpc	r17, r27
    48f8:	71 f4       	brne	.+28     	; 0x4916 <loop+0x19b4>
    48fa:	80 91 cf 08 	lds	r24, 0x08CF
    48fe:	90 91 d0 08 	lds	r25, 0x08D0
    4902:	a0 91 d1 08 	lds	r26, 0x08D1
    4906:	b0 91 d2 08 	lds	r27, 0x08D2
    490a:	28 17       	cp	r18, r24
    490c:	39 07       	cpc	r19, r25
    490e:	4a 07       	cpc	r20, r26
    4910:	5b 07       	cpc	r21, r27
    4912:	09 f4       	brne	.+2      	; 0x4916 <loop+0x19b4>
    4914:	ff c0       	rjmp	.+510    	; 0x4b14 <loop+0x1bb2>
    4916:	0e 94 b6 39 	call	0x736c	; 0x736c <millis>
    491a:	20 91 b5 08 	lds	r18, 0x08B5
    491e:	30 91 b6 08 	lds	r19, 0x08B6
    4922:	40 91 b7 08 	lds	r20, 0x08B7
    4926:	50 91 b8 08 	lds	r21, 0x08B8
    492a:	62 1b       	sub	r22, r18
    492c:	73 0b       	sbc	r23, r19
    492e:	84 0b       	sbc	r24, r20
    4930:	95 0b       	sbc	r25, r21
    4932:	20 91 09 04 	lds	r18, 0x0409
    4936:	30 91 0a 04 	lds	r19, 0x040A
    493a:	40 e0       	ldi	r20, 0x00	; 0
    493c:	50 e0       	ldi	r21, 0x00	; 0
    493e:	62 17       	cp	r22, r18
    4940:	73 07       	cpc	r23, r19
    4942:	84 07       	cpc	r24, r20
    4944:	95 07       	cpc	r25, r21
    4946:	08 f4       	brcc	.+2      	; 0x494a <loop+0x19e8>
    4948:	e5 c0       	rjmp	.+458    	; 0x4b14 <loop+0x1bb2>
            // detection is over threshold and current readings are different from previous readings

            #ifdef SERIAL_DEBUG_TOUCH
                Serial.print("touch ");
    494a:	80 ef       	ldi	r24, 0xF0	; 240
    494c:	98 e0       	ldi	r25, 0x08	; 8
    494e:	60 ea       	ldi	r22, 0xA0	; 160
    4950:	72 e0       	ldi	r23, 0x02	; 2
    4952:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
                for (i = 0; i < KG_BASE_COMBINATIONS; i++) {
    4956:	10 92 a8 06 	sts	0x06A8, r1
    495a:	10 92 a9 06 	sts	0x06A9, r1
    495e:	10 92 aa 06 	sts	0x06AA, r1
    4962:	10 92 ab 06 	sts	0x06AB, r1
    4966:	39 c0       	rjmp	.+114    	; 0x49da <loop+0x1a78>
                    if (i < 32) Serial.print(bitRead(detect1, i));
    4968:	80 32       	cpi	r24, 0x20	; 32
    496a:	91 05       	cpc	r25, r1
    496c:	a1 05       	cpc	r26, r1
    496e:	b1 05       	cpc	r27, r1
    4970:	4c f4       	brge	.+18     	; 0x4984 <loop+0x1a22>
    4972:	40 91 bb 08 	lds	r20, 0x08BB
    4976:	50 91 bc 08 	lds	r21, 0x08BC
    497a:	60 91 bd 08 	lds	r22, 0x08BD
    497e:	70 91 be 08 	lds	r23, 0x08BE
    4982:	09 c0       	rjmp	.+18     	; 0x4996 <loop+0x1a34>
                    else Serial.print(bitRead(detect2, i - 32));
    4984:	80 97       	sbiw	r24, 0x20	; 32
    4986:	40 91 bf 08 	lds	r20, 0x08BF
    498a:	50 91 c0 08 	lds	r21, 0x08C0
    498e:	60 91 c1 08 	lds	r22, 0x08C1
    4992:	70 91 c2 08 	lds	r23, 0x08C2
    4996:	04 c0       	rjmp	.+8      	; 0x49a0 <loop+0x1a3e>
    4998:	76 95       	lsr	r23
    499a:	67 95       	ror	r22
    499c:	57 95       	ror	r21
    499e:	47 95       	ror	r20
    49a0:	8a 95       	dec	r24
    49a2:	d2 f7       	brpl	.-12     	; 0x4998 <loop+0x1a36>
    49a4:	41 70       	andi	r20, 0x01	; 1
    49a6:	50 70       	andi	r21, 0x00	; 0
    49a8:	60 70       	andi	r22, 0x00	; 0
    49aa:	70 70       	andi	r23, 0x00	; 0
    49ac:	80 ef       	ldi	r24, 0xF0	; 240
    49ae:	98 e0       	ldi	r25, 0x08	; 8
    49b0:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <_ZN16USBVirtualSerial5printEm>
        } else if ((verify1 != sensors1 || verify2 != sensors2) && millis() - touchTime >= opt_touch_detect_threshold) {
            // detection is over threshold and current readings are different from previous readings

            #ifdef SERIAL_DEBUG_TOUCH
                Serial.print("touch ");
                for (i = 0; i < KG_BASE_COMBINATIONS; i++) {
    49b4:	80 91 a8 06 	lds	r24, 0x06A8
    49b8:	90 91 a9 06 	lds	r25, 0x06A9
    49bc:	a0 91 aa 06 	lds	r26, 0x06AA
    49c0:	b0 91 ab 06 	lds	r27, 0x06AB
    49c4:	01 96       	adiw	r24, 0x01	; 1
    49c6:	a1 1d       	adc	r26, r1
    49c8:	b1 1d       	adc	r27, r1
    49ca:	80 93 a8 06 	sts	0x06A8, r24
    49ce:	90 93 a9 06 	sts	0x06A9, r25
    49d2:	a0 93 aa 06 	sts	0x06AA, r26
    49d6:	b0 93 ab 06 	sts	0x06AB, r27
    49da:	80 91 a8 06 	lds	r24, 0x06A8
    49de:	90 91 a9 06 	lds	r25, 0x06A9
    49e2:	a0 91 aa 06 	lds	r26, 0x06AA
    49e6:	b0 91 ab 06 	lds	r27, 0x06AB
    49ea:	8c 33       	cpi	r24, 0x3C	; 60
    49ec:	91 05       	cpc	r25, r1
    49ee:	a1 05       	cpc	r26, r1
    49f0:	b1 05       	cpc	r27, r1
    49f2:	0c f4       	brge	.+2      	; 0x49f6 <loop+0x1a94>
    49f4:	b9 cf       	rjmp	.-142    	; 0x4968 <loop+0x1a06>
                    if (i < 32) Serial.print(bitRead(detect1, i));
                    else Serial.print(bitRead(detect2, i - 32));
                }
                Serial.print("\n");
    49f6:	80 ef       	ldi	r24, 0xF0	; 240
    49f8:	98 e0       	ldi	r25, 0x08	; 8
    49fa:	67 ea       	ldi	r22, 0xA7	; 167
    49fc:	72 e0       	ldi	r23, 0x02	; 2
    49fe:	0e 94 47 2e 	call	0x5c8e	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            #endif /* SERIAL_DEBUG_TOUCH */

            // check to see if they've just initiated or removed any touches
            if (verify1 > sensors1 || verify2 > sensors2) {
    4a02:	60 90 c3 08 	lds	r6, 0x08C3
    4a06:	70 90 c4 08 	lds	r7, 0x08C4
    4a0a:	80 90 c5 08 	lds	r8, 0x08C5
    4a0e:	90 90 c6 08 	lds	r9, 0x08C6
    4a12:	a0 90 cb 08 	lds	r10, 0x08CB
    4a16:	b0 90 cc 08 	lds	r11, 0x08CC
    4a1a:	c0 90 cd 08 	lds	r12, 0x08CD
    4a1e:	d0 90 ce 08 	lds	r13, 0x08CE
    4a22:	a6 14       	cp	r10, r6
    4a24:	b7 04       	cpc	r11, r7
    4a26:	c8 04       	cpc	r12, r8
    4a28:	d9 04       	cpc	r13, r9
    4a2a:	a8 f0       	brcs	.+42     	; 0x4a56 <loop+0x1af4>
    4a2c:	e0 90 c7 08 	lds	r14, 0x08C7
    4a30:	f0 90 c8 08 	lds	r15, 0x08C8
    4a34:	00 91 c9 08 	lds	r16, 0x08C9
    4a38:	10 91 ca 08 	lds	r17, 0x08CA
    4a3c:	20 91 cf 08 	lds	r18, 0x08CF
    4a40:	30 91 d0 08 	lds	r19, 0x08D0
    4a44:	40 91 d1 08 	lds	r20, 0x08D1
    4a48:	50 91 d2 08 	lds	r21, 0x08D2
    4a4c:	2e 15       	cp	r18, r14
    4a4e:	3f 05       	cpc	r19, r15
    4a50:	40 07       	cpc	r20, r16
    4a52:	51 07       	cpc	r21, r17
    4a54:	c0 f4       	brcc	.+48     	; 0x4a86 <loop+0x1b24>
                adding = true;
    4a56:	81 e0       	ldi	r24, 0x01	; 1
    4a58:	80 93 b9 08 	sts	0x08B9, r24

                // touch initiation, check for actions
                check_sensors_touch(verify1, verify2, 1);
    4a5c:	60 91 c3 08 	lds	r22, 0x08C3
    4a60:	70 91 c4 08 	lds	r23, 0x08C4
    4a64:	80 91 c5 08 	lds	r24, 0x08C5
    4a68:	90 91 c6 08 	lds	r25, 0x08C6
    4a6c:	20 91 c7 08 	lds	r18, 0x08C7
    4a70:	30 91 c8 08 	lds	r19, 0x08C8
    4a74:	40 91 c9 08 	lds	r20, 0x08C9
    4a78:	50 91 ca 08 	lds	r21, 0x08CA
    4a7c:	01 e0       	ldi	r16, 0x01	; 1
    4a7e:	10 e0       	ldi	r17, 0x00	; 0
    4a80:	0e 94 64 16 	call	0x2cc8	; 0x2cc8 <_Z19check_sensors_touchmmi>
    4a84:	27 c0       	rjmp	.+78     	; 0x4ad4 <loop+0x1b72>
            } else if (adding && (verify1 < sensors1 || verify2 < sensors2)) {
    4a86:	80 91 b9 08 	lds	r24, 0x08B9
    4a8a:	88 23       	and	r24, r24
    4a8c:	19 f1       	breq	.+70     	; 0x4ad4 <loop+0x1b72>
    4a8e:	6a 14       	cp	r6, r10
    4a90:	7b 04       	cpc	r7, r11
    4a92:	8c 04       	cpc	r8, r12
    4a94:	9d 04       	cpc	r9, r13
    4a96:	28 f0       	brcs	.+10     	; 0x4aa2 <loop+0x1b40>
    4a98:	e2 16       	cp	r14, r18
    4a9a:	f3 06       	cpc	r15, r19
    4a9c:	04 07       	cpc	r16, r20
    4a9e:	15 07       	cpc	r17, r21
    4aa0:	c8 f4       	brcc	.+50     	; 0x4ad4 <loop+0x1b72>
                adding = false;
    4aa2:	10 92 b9 08 	sts	0x08B9, r1
                removing = true;
    4aa6:	81 e0       	ldi	r24, 0x01	; 1
    4aa8:	80 93 ba 08 	sts	0x08BA, r24
    
                // touch release, check for actions
                check_sensors_release(sensors1, sensors2, 1);
    4aac:	60 91 cb 08 	lds	r22, 0x08CB
    4ab0:	70 91 cc 08 	lds	r23, 0x08CC
    4ab4:	80 91 cd 08 	lds	r24, 0x08CD
    4ab8:	90 91 ce 08 	lds	r25, 0x08CE
    4abc:	20 91 cf 08 	lds	r18, 0x08CF
    4ac0:	30 91 d0 08 	lds	r19, 0x08D0
    4ac4:	40 91 d1 08 	lds	r20, 0x08D1
    4ac8:	50 91 d2 08 	lds	r21, 0x08D2
    4acc:	01 e0       	ldi	r16, 0x01	; 1
    4ace:	10 e0       	ldi	r17, 0x00	; 0
    4ad0:	0e 94 15 0a 	call	0x142a	; 0x142a <_Z21check_sensors_releasemmi>
            }
            
            // set official sensor readings to current readings 
            sensors1 = verify1;
    4ad4:	80 91 c3 08 	lds	r24, 0x08C3
    4ad8:	90 91 c4 08 	lds	r25, 0x08C4
    4adc:	a0 91 c5 08 	lds	r26, 0x08C5
    4ae0:	b0 91 c6 08 	lds	r27, 0x08C6
    4ae4:	80 93 cb 08 	sts	0x08CB, r24
    4ae8:	90 93 cc 08 	sts	0x08CC, r25
    4aec:	a0 93 cd 08 	sts	0x08CD, r26
    4af0:	b0 93 ce 08 	sts	0x08CE, r27
            sensors2 = verify2;
    4af4:	80 91 c7 08 	lds	r24, 0x08C7
    4af8:	90 91 c8 08 	lds	r25, 0x08C8
    4afc:	a0 91 c9 08 	lds	r26, 0x08C9
    4b00:	b0 91 ca 08 	lds	r27, 0x08CA
    4b04:	80 93 cf 08 	sts	0x08CF, r24
    4b08:	90 93 d0 08 	sts	0x08D0, r25
    4b0c:	a0 93 d1 08 	sts	0x08D1, r26
    4b10:	b0 93 d2 08 	sts	0x08D2, r27
        }
        
        verify1 = detect1;
    4b14:	80 91 bb 08 	lds	r24, 0x08BB
    4b18:	90 91 bc 08 	lds	r25, 0x08BC
    4b1c:	a0 91 bd 08 	lds	r26, 0x08BD
    4b20:	b0 91 be 08 	lds	r27, 0x08BE
    4b24:	80 93 c3 08 	sts	0x08C3, r24
    4b28:	90 93 c4 08 	sts	0x08C4, r25
    4b2c:	a0 93 c5 08 	sts	0x08C5, r26
    4b30:	b0 93 c6 08 	sts	0x08C6, r27
        verify2 = detect2;
    4b34:	80 91 bf 08 	lds	r24, 0x08BF
    4b38:	90 91 c0 08 	lds	r25, 0x08C0
    4b3c:	a0 91 c1 08 	lds	r26, 0x08C1
    4b40:	b0 91 c2 08 	lds	r27, 0x08C2
    4b44:	80 93 c7 08 	sts	0x08C7, r24
    4b48:	90 93 c8 08 	sts	0x08C8, r25
    4b4c:	a0 93 c9 08 	sts	0x08C9, r26
    4b50:	b0 93 ca 08 	sts	0x08CA, r27
    #endif /* ENABLE_TOUCH */

    // increment loop tick counter
    counter++;
    4b54:	20 91 a0 06 	lds	r18, 0x06A0
    4b58:	30 91 a1 06 	lds	r19, 0x06A1
    4b5c:	2f 5f       	subi	r18, 0xFF	; 255
    4b5e:	3f 4f       	sbci	r19, 0xFF	; 255
    4b60:	30 93 a1 06 	sts	0x06A1, r19
    4b64:	20 93 a0 06 	sts	0x06A0, r18

    #ifdef ENABLE_TRICOLOR
        if      (tricolorBlinkRed   == 1 && counter % 500 == 0) tricolor(counter % 1000 >= 500 ? 0 : 1, 255, 255);
    4b68:	e0 91 88 08 	lds	r30, 0x0888
    4b6c:	f0 91 89 08 	lds	r31, 0x0889
    4b70:	e1 30       	cpi	r30, 0x01	; 1
    4b72:	f1 05       	cpc	r31, r1
    4b74:	89 f4       	brne	.+34     	; 0x4b98 <loop+0x1c36>
    4b76:	c9 01       	movw	r24, r18
    4b78:	64 ef       	ldi	r22, 0xF4	; 244
    4b7a:	71 e0       	ldi	r23, 0x01	; 1
    4b7c:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4b80:	89 2b       	or	r24, r25
    4b82:	51 f4       	brne	.+20     	; 0x4b98 <loop+0x1c36>
    4b84:	40 e0       	ldi	r20, 0x00	; 0
    4b86:	c9 01       	movw	r24, r18
    4b88:	68 ee       	ldi	r22, 0xE8	; 232
    4b8a:	73 e0       	ldi	r23, 0x03	; 3
    4b8c:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4b90:	84 5f       	subi	r24, 0xF4	; 244
    4b92:	91 40       	sbci	r25, 0x01	; 1
    4b94:	d4 f5       	brge	.+116    	; 0x4c0a <loop+0x1ca8>
    4b96:	38 c0       	rjmp	.+112    	; 0x4c08 <loop+0x1ca6>
        else if (tricolorBlinkRed   == 2 && counter % 100 == 0) tricolor(counter % 1000 >= 100 ? 0 : 1, 255, 255);
    4b98:	e2 30       	cpi	r30, 0x02	; 2
    4b9a:	f1 05       	cpc	r31, r1
    4b9c:	89 f4       	brne	.+34     	; 0x4bc0 <loop+0x1c5e>
    4b9e:	c9 01       	movw	r24, r18
    4ba0:	64 e6       	ldi	r22, 0x64	; 100
    4ba2:	70 e0       	ldi	r23, 0x00	; 0
    4ba4:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4ba8:	89 2b       	or	r24, r25
    4baa:	51 f4       	brne	.+20     	; 0x4bc0 <loop+0x1c5e>
    4bac:	40 e0       	ldi	r20, 0x00	; 0
    4bae:	c9 01       	movw	r24, r18
    4bb0:	68 ee       	ldi	r22, 0xE8	; 232
    4bb2:	73 e0       	ldi	r23, 0x03	; 3
    4bb4:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4bb8:	84 36       	cpi	r24, 0x64	; 100
    4bba:	91 05       	cpc	r25, r1
    4bbc:	34 f5       	brge	.+76     	; 0x4c0a <loop+0x1ca8>
    4bbe:	24 c0       	rjmp	.+72     	; 0x4c08 <loop+0x1ca6>
        else if (tricolorBlinkRed   == 3 && counter %  50 == 0) tricolor(counter %  100 >=  50 ? 0 : 1, 255, 255);
    4bc0:	e3 30       	cpi	r30, 0x03	; 3
    4bc2:	f1 05       	cpc	r31, r1
    4bc4:	81 f4       	brne	.+32     	; 0x4be6 <loop+0x1c84>
    4bc6:	c9 01       	movw	r24, r18
    4bc8:	62 e3       	ldi	r22, 0x32	; 50
    4bca:	70 e0       	ldi	r23, 0x00	; 0
    4bcc:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4bd0:	89 2b       	or	r24, r25
    4bd2:	49 f4       	brne	.+18     	; 0x4be6 <loop+0x1c84>
    4bd4:	40 e0       	ldi	r20, 0x00	; 0
    4bd6:	c9 01       	movw	r24, r18
    4bd8:	64 e6       	ldi	r22, 0x64	; 100
    4bda:	70 e0       	ldi	r23, 0x00	; 0
    4bdc:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4be0:	c2 97       	sbiw	r24, 0x32	; 50
    4be2:	9c f4       	brge	.+38     	; 0x4c0a <loop+0x1ca8>
    4be4:	11 c0       	rjmp	.+34     	; 0x4c08 <loop+0x1ca6>
        else if (tricolorBlinkRed   == 4 && counter %  10 == 0) tricolor(counter %  100 >=  10 ? 0 : 1, 255, 255);
    4be6:	34 97       	sbiw	r30, 0x04	; 4
    4be8:	a9 f4       	brne	.+42     	; 0x4c14 <loop+0x1cb2>
    4bea:	c9 01       	movw	r24, r18
    4bec:	6a e0       	ldi	r22, 0x0A	; 10
    4bee:	70 e0       	ldi	r23, 0x00	; 0
    4bf0:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4bf4:	89 2b       	or	r24, r25
    4bf6:	71 f4       	brne	.+28     	; 0x4c14 <loop+0x1cb2>
    4bf8:	40 e0       	ldi	r20, 0x00	; 0
    4bfa:	c9 01       	movw	r24, r18
    4bfc:	64 e6       	ldi	r22, 0x64	; 100
    4bfe:	70 e0       	ldi	r23, 0x00	; 0
    4c00:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4c04:	0a 97       	sbiw	r24, 0x0a	; 10
    4c06:	0c f4       	brge	.+2      	; 0x4c0a <loop+0x1ca8>
    4c08:	41 e0       	ldi	r20, 0x01	; 1
    4c0a:	84 2f       	mov	r24, r20
    4c0c:	6f ef       	ldi	r22, 0xFF	; 255
    4c0e:	4f ef       	ldi	r20, 0xFF	; 255
    4c10:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <_Z8tricolorhhh>
        if      (tricolorBlinkGreen == 1 && counter % 500 == 0) tricolor(255, counter % 1000 >= 500 ? 0 : 1, 255);
    4c14:	20 91 8a 08 	lds	r18, 0x088A
    4c18:	30 91 8b 08 	lds	r19, 0x088B
    4c1c:	21 30       	cpi	r18, 0x01	; 1
    4c1e:	31 05       	cpc	r19, r1
    4c20:	a9 f4       	brne	.+42     	; 0x4c4c <loop+0x1cea>
    4c22:	e0 91 a0 06 	lds	r30, 0x06A0
    4c26:	f0 91 a1 06 	lds	r31, 0x06A1
    4c2a:	cf 01       	movw	r24, r30
    4c2c:	64 ef       	ldi	r22, 0xF4	; 244
    4c2e:	71 e0       	ldi	r23, 0x01	; 1
    4c30:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4c34:	89 2b       	or	r24, r25
    4c36:	51 f4       	brne	.+20     	; 0x4c4c <loop+0x1cea>
    4c38:	20 e0       	ldi	r18, 0x00	; 0
    4c3a:	cf 01       	movw	r24, r30
    4c3c:	68 ee       	ldi	r22, 0xE8	; 232
    4c3e:	73 e0       	ldi	r23, 0x03	; 3
    4c40:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4c44:	84 5f       	subi	r24, 0xF4	; 244
    4c46:	91 40       	sbci	r25, 0x01	; 1
    4c48:	84 f5       	brge	.+96     	; 0x4caa <loop+0x1d48>
    4c4a:	2e c0       	rjmp	.+92     	; 0x4ca8 <loop+0x1d46>
        else if (tricolorBlinkGreen == 3 && counter % 100 == 0) tricolor(255, counter % 1000 >= 100 ? 0 : 1, 255);
    4c4c:	23 30       	cpi	r18, 0x03	; 3
    4c4e:	31 05       	cpc	r19, r1
    4c50:	a9 f4       	brne	.+42     	; 0x4c7c <loop+0x1d1a>
    4c52:	e0 91 a0 06 	lds	r30, 0x06A0
    4c56:	f0 91 a1 06 	lds	r31, 0x06A1
    4c5a:	cf 01       	movw	r24, r30
    4c5c:	64 e6       	ldi	r22, 0x64	; 100
    4c5e:	70 e0       	ldi	r23, 0x00	; 0
    4c60:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4c64:	89 2b       	or	r24, r25
    4c66:	51 f4       	brne	.+20     	; 0x4c7c <loop+0x1d1a>
    4c68:	20 e0       	ldi	r18, 0x00	; 0
    4c6a:	cf 01       	movw	r24, r30
    4c6c:	68 ee       	ldi	r22, 0xE8	; 232
    4c6e:	73 e0       	ldi	r23, 0x03	; 3
    4c70:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4c74:	84 36       	cpi	r24, 0x64	; 100
    4c76:	91 05       	cpc	r25, r1
    4c78:	c4 f4       	brge	.+48     	; 0x4caa <loop+0x1d48>
    4c7a:	16 c0       	rjmp	.+44     	; 0x4ca8 <loop+0x1d46>
        else if (tricolorBlinkGreen == 2 && counter %  50 == 0) tricolor(255, counter %  100 >=  50 ? 0 : 1, 255);
    4c7c:	22 30       	cpi	r18, 0x02	; 2
    4c7e:	31 05       	cpc	r19, r1
    4c80:	b9 f4       	brne	.+46     	; 0x4cb0 <loop+0x1d4e>
    4c82:	e0 91 a0 06 	lds	r30, 0x06A0
    4c86:	f0 91 a1 06 	lds	r31, 0x06A1
    4c8a:	cf 01       	movw	r24, r30
    4c8c:	62 e3       	ldi	r22, 0x32	; 50
    4c8e:	70 e0       	ldi	r23, 0x00	; 0
    4c90:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4c94:	89 2b       	or	r24, r25
    4c96:	61 f4       	brne	.+24     	; 0x4cb0 <loop+0x1d4e>
    4c98:	20 e0       	ldi	r18, 0x00	; 0
    4c9a:	cf 01       	movw	r24, r30
    4c9c:	64 e6       	ldi	r22, 0x64	; 100
    4c9e:	70 e0       	ldi	r23, 0x00	; 0
    4ca0:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4ca4:	c2 97       	sbiw	r24, 0x32	; 50
    4ca6:	0c f4       	brge	.+2      	; 0x4caa <loop+0x1d48>
    4ca8:	21 e0       	ldi	r18, 0x01	; 1
    4caa:	8f ef       	ldi	r24, 0xFF	; 255
    4cac:	62 2f       	mov	r22, r18
    4cae:	19 c0       	rjmp	.+50     	; 0x4ce2 <loop+0x1d80>
        else if (tricolorBlinkGreen == 4 && counter %  10 == 0) tricolor(255, counter %  100 >=  10 ? 0 : 1, 255);
    4cb0:	24 30       	cpi	r18, 0x04	; 4
    4cb2:	31 05       	cpc	r19, r1
    4cb4:	c9 f4       	brne	.+50     	; 0x4ce8 <loop+0x1d86>
    4cb6:	20 91 a0 06 	lds	r18, 0x06A0
    4cba:	30 91 a1 06 	lds	r19, 0x06A1
    4cbe:	c9 01       	movw	r24, r18
    4cc0:	6a e0       	ldi	r22, 0x0A	; 10
    4cc2:	70 e0       	ldi	r23, 0x00	; 0
    4cc4:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4cc8:	89 2b       	or	r24, r25
    4cca:	71 f4       	brne	.+28     	; 0x4ce8 <loop+0x1d86>
    4ccc:	40 e0       	ldi	r20, 0x00	; 0
    4cce:	c9 01       	movw	r24, r18
    4cd0:	64 e6       	ldi	r22, 0x64	; 100
    4cd2:	70 e0       	ldi	r23, 0x00	; 0
    4cd4:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4cd8:	0a 97       	sbiw	r24, 0x0a	; 10
    4cda:	0c f4       	brge	.+2      	; 0x4cde <loop+0x1d7c>
    4cdc:	41 e0       	ldi	r20, 0x01	; 1
    4cde:	8f ef       	ldi	r24, 0xFF	; 255
    4ce0:	64 2f       	mov	r22, r20
    4ce2:	4f ef       	ldi	r20, 0xFF	; 255
    4ce4:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <_Z8tricolorhhh>
        if      (tricolorBlinkBlue  == 1 && counter % 500 == 0) tricolor(255, 255, counter % 1000 >= 500 ? 0 : 1);
    4ce8:	20 91 8c 08 	lds	r18, 0x088C
    4cec:	30 91 8d 08 	lds	r19, 0x088D
    4cf0:	21 30       	cpi	r18, 0x01	; 1
    4cf2:	31 05       	cpc	r19, r1
    4cf4:	b1 f4       	brne	.+44     	; 0x4d22 <loop+0x1dc0>
    4cf6:	e0 91 a0 06 	lds	r30, 0x06A0
    4cfa:	f0 91 a1 06 	lds	r31, 0x06A1
    4cfe:	cf 01       	movw	r24, r30
    4d00:	64 ef       	ldi	r22, 0xF4	; 244
    4d02:	71 e0       	ldi	r23, 0x01	; 1
    4d04:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4d08:	89 2b       	or	r24, r25
    4d0a:	59 f4       	brne	.+22     	; 0x4d22 <loop+0x1dc0>
    4d0c:	40 e0       	ldi	r20, 0x00	; 0
    4d0e:	cf 01       	movw	r24, r30
    4d10:	68 ee       	ldi	r22, 0xE8	; 232
    4d12:	73 e0       	ldi	r23, 0x03	; 3
    4d14:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4d18:	84 5f       	subi	r24, 0xF4	; 244
    4d1a:	91 40       	sbci	r25, 0x01	; 1
    4d1c:	0c f0       	brlt	.+2      	; 0x4d20 <loop+0x1dbe>
    4d1e:	47 c0       	rjmp	.+142    	; 0x4dae <loop+0x1e4c>
    4d20:	45 c0       	rjmp	.+138    	; 0x4dac <loop+0x1e4a>
        else if (tricolorBlinkBlue  == 2 && counter % 100 == 0) tricolor(255, 255, counter % 1000 >= 100 ? 0 : 1);
    4d22:	22 30       	cpi	r18, 0x02	; 2
    4d24:	31 05       	cpc	r19, r1
    4d26:	a9 f4       	brne	.+42     	; 0x4d52 <loop+0x1df0>
    4d28:	e0 91 a0 06 	lds	r30, 0x06A0
    4d2c:	f0 91 a1 06 	lds	r31, 0x06A1
    4d30:	cf 01       	movw	r24, r30
    4d32:	64 e6       	ldi	r22, 0x64	; 100
    4d34:	70 e0       	ldi	r23, 0x00	; 0
    4d36:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4d3a:	89 2b       	or	r24, r25
    4d3c:	51 f4       	brne	.+20     	; 0x4d52 <loop+0x1df0>
    4d3e:	40 e0       	ldi	r20, 0x00	; 0
    4d40:	cf 01       	movw	r24, r30
    4d42:	68 ee       	ldi	r22, 0xE8	; 232
    4d44:	73 e0       	ldi	r23, 0x03	; 3
    4d46:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4d4a:	84 36       	cpi	r24, 0x64	; 100
    4d4c:	91 05       	cpc	r25, r1
    4d4e:	7c f5       	brge	.+94     	; 0x4dae <loop+0x1e4c>
    4d50:	2d c0       	rjmp	.+90     	; 0x4dac <loop+0x1e4a>
        else if (tricolorBlinkBlue  == 3 && counter %  50 == 0) tricolor(255, 255, counter %  100 >=  50 ? 0 : 1);
    4d52:	23 30       	cpi	r18, 0x03	; 3
    4d54:	31 05       	cpc	r19, r1
    4d56:	a1 f4       	brne	.+40     	; 0x4d80 <loop+0x1e1e>
    4d58:	e0 91 a0 06 	lds	r30, 0x06A0
    4d5c:	f0 91 a1 06 	lds	r31, 0x06A1
    4d60:	cf 01       	movw	r24, r30
    4d62:	62 e3       	ldi	r22, 0x32	; 50
    4d64:	70 e0       	ldi	r23, 0x00	; 0
    4d66:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4d6a:	89 2b       	or	r24, r25
    4d6c:	49 f4       	brne	.+18     	; 0x4d80 <loop+0x1e1e>
    4d6e:	40 e0       	ldi	r20, 0x00	; 0
    4d70:	cf 01       	movw	r24, r30
    4d72:	64 e6       	ldi	r22, 0x64	; 100
    4d74:	70 e0       	ldi	r23, 0x00	; 0
    4d76:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4d7a:	c2 97       	sbiw	r24, 0x32	; 50
    4d7c:	c4 f4       	brge	.+48     	; 0x4dae <loop+0x1e4c>
    4d7e:	16 c0       	rjmp	.+44     	; 0x4dac <loop+0x1e4a>
        else if (tricolorBlinkBlue  == 4 && counter %  10 == 0) tricolor(255, 255, counter %  100 >=  10 ? 0 : 1);
    4d80:	24 30       	cpi	r18, 0x04	; 4
    4d82:	31 05       	cpc	r19, r1
    4d84:	c1 f4       	brne	.+48     	; 0x4db6 <loop+0x1e54>
    4d86:	20 91 a0 06 	lds	r18, 0x06A0
    4d8a:	30 91 a1 06 	lds	r19, 0x06A1
    4d8e:	c9 01       	movw	r24, r18
    4d90:	6a e0       	ldi	r22, 0x0A	; 10
    4d92:	70 e0       	ldi	r23, 0x00	; 0
    4d94:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4d98:	89 2b       	or	r24, r25
    4d9a:	69 f4       	brne	.+26     	; 0x4db6 <loop+0x1e54>
    4d9c:	40 e0       	ldi	r20, 0x00	; 0
    4d9e:	c9 01       	movw	r24, r18
    4da0:	64 e6       	ldi	r22, 0x64	; 100
    4da2:	70 e0       	ldi	r23, 0x00	; 0
    4da4:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__divmodhi4>
    4da8:	0a 97       	sbiw	r24, 0x0a	; 10
    4daa:	0c f4       	brge	.+2      	; 0x4dae <loop+0x1e4c>
    4dac:	41 e0       	ldi	r20, 0x01	; 1
    4dae:	8f ef       	ldi	r24, 0xFF	; 255
    4db0:	6f ef       	ldi	r22, 0xFF	; 255
    4db2:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <_Z8tricolorhhh>
    #endif /* ENABLE_TRICOLOR */

    // test counter and reset if necessary
    if (counter == 1000) {
    4db6:	80 91 a0 06 	lds	r24, 0x06A0
    4dba:	90 91 a1 06 	lds	r25, 0x06A1
    4dbe:	88 5e       	subi	r24, 0xE8	; 232
    4dc0:	93 40       	sbci	r25, 0x03	; 3
    4dc2:	09 f0       	breq	.+2      	; 0x4dc6 <loop+0x1e64>
    4dc4:	4b c0       	rjmp	.+150    	; 0x4e5c <loop+0x1efa>
        counter = 0;
    4dc6:	10 92 a1 06 	sts	0x06A1, r1
    4dca:	10 92 a0 06 	sts	0x06A0, r1
        ticks++;
    4dce:	80 91 a2 06 	lds	r24, 0x06A2
    4dd2:	90 91 a3 06 	lds	r25, 0x06A3
    4dd6:	01 96       	adiw	r24, 0x01	; 1
    4dd8:	90 93 a3 06 	sts	0x06A3, r25
    4ddc:	80 93 a2 06 	sts	0x06A2, r24
        #ifdef ENABLE_BLINK
            blink_led = !blink_led;
    4de0:	90 e0       	ldi	r25, 0x00	; 0
    4de2:	80 91 8e 08 	lds	r24, 0x088E
    4de6:	88 23       	and	r24, r24
    4de8:	09 f4       	brne	.+2      	; 0x4dec <loop+0x1e8a>
    4dea:	91 e0       	ldi	r25, 0x01	; 1
    4dec:	90 93 8e 08 	sts	0x088E, r25
            if (blink_led) digitalWrite(BLINK_LED_PIN, HIGH);
    4df0:	99 23       	and	r25, r25
    4df2:	19 f0       	breq	.+6      	; 0x4dfa <loop+0x1e98>
    4df4:	86 e0       	ldi	r24, 0x06	; 6
    4df6:	61 e0       	ldi	r22, 0x01	; 1
    4df8:	02 c0       	rjmp	.+4      	; 0x4dfe <loop+0x1e9c>
            else digitalWrite(BLINK_LED_PIN, LOW);
    4dfa:	86 e0       	ldi	r24, 0x06	; 6
    4dfc:	60 e0       	ldi	r22, 0x00	; 0
    4dfe:	58 d4       	rcall	.+2224   	; 0x56b0 <digitalWrite>
        #endif /* ENABLE_BLINK */
        #ifdef SERIAL_DEBUG_BENCHMARK
            Serial.print("benchmark 1000 ");
    4e00:	80 ef       	ldi	r24, 0xF0	; 240
    4e02:	98 e0       	ldi	r25, 0x08	; 8
    4e04:	69 ea       	ldi	r22, 0xA9	; 169
    4e06:	72 e0       	ldi	r23, 0x02	; 2
    4e08:	42 d7       	rcall	.+3716   	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.print(millis() - t);
    4e0a:	0e 94 b6 39 	call	0x736c	; 0x736c <millis>
    4e0e:	ab 01       	movw	r20, r22
    4e10:	bc 01       	movw	r22, r24
    4e12:	80 91 a4 06 	lds	r24, 0x06A4
    4e16:	90 91 a5 06 	lds	r25, 0x06A5
    4e1a:	a0 91 a6 06 	lds	r26, 0x06A6
    4e1e:	b0 91 a7 06 	lds	r27, 0x06A7
    4e22:	48 1b       	sub	r20, r24
    4e24:	59 0b       	sbc	r21, r25
    4e26:	6a 0b       	sbc	r22, r26
    4e28:	7b 0b       	sbc	r23, r27
    4e2a:	80 ef       	ldi	r24, 0xF0	; 240
    4e2c:	98 e0       	ldi	r25, 0x08	; 8
    4e2e:	76 d7       	rcall	.+3820   	; 0x5d1c <_ZN16USBVirtualSerial5printEm>
            Serial.print(" ");
    4e30:	80 ef       	ldi	r24, 0xF0	; 240
    4e32:	98 e0       	ldi	r25, 0x08	; 8
    4e34:	67 e3       	ldi	r22, 0x37	; 55
    4e36:	71 e0       	ldi	r23, 0x01	; 1
    4e38:	2a d7       	rcall	.+3668   	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(ticks);
    4e3a:	60 91 a2 06 	lds	r22, 0x06A2
    4e3e:	70 91 a3 06 	lds	r23, 0x06A3
    4e42:	80 ef       	ldi	r24, 0xF0	; 240
    4e44:	98 e0       	ldi	r25, 0x08	; 8
    4e46:	21 d7       	rcall	.+3650   	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_BENCHMARK */
        t = millis();
    4e48:	0e 94 b6 39 	call	0x736c	; 0x736c <millis>
    4e4c:	60 93 a4 06 	sts	0x06A4, r22
    4e50:	70 93 a5 06 	sts	0x06A5, r23
    4e54:	80 93 a6 06 	sts	0x06A6, r24
    4e58:	90 93 a7 06 	sts	0x06A7, r25
    }
}
    4e5c:	28 96       	adiw	r28, 0x08	; 8
    4e5e:	0f b6       	in	r0, 0x3f	; 63
    4e60:	f8 94       	cli
    4e62:	de bf       	out	0x3e, r29	; 62
    4e64:	0f be       	out	0x3f, r0	; 63
    4e66:	cd bf       	out	0x3d, r28	; 61
    4e68:	cf 91       	pop	r28
    4e6a:	df 91       	pop	r29
    4e6c:	1f 91       	pop	r17
    4e6e:	0f 91       	pop	r16
    4e70:	ff 90       	pop	r15
    4e72:	ef 90       	pop	r14
    4e74:	df 90       	pop	r13
    4e76:	cf 90       	pop	r12
    4e78:	bf 90       	pop	r11
    4e7a:	af 90       	pop	r10
    4e7c:	9f 90       	pop	r9
    4e7e:	8f 90       	pop	r8
    4e80:	7f 90       	pop	r7
    4e82:	6f 90       	pop	r6
    4e84:	5f 90       	pop	r5
    4e86:	4f 90       	pop	r4
    4e88:	3f 90       	pop	r3
    4e8a:	2f 90       	pop	r2
    4e8c:	08 95       	ret

00004e8e <main>:
		 *  \param[out] DataPtr  Pointer to a global array that will hold the data stored into the ring buffer.
		 *  \param[out] Size     Maximum number of bytes that can be stored in the underlying data array.
		 */
		static inline void RingBuffer_InitBuffer(RingBuffer_t* Buffer, uint8_t* const DataPtr, const uint16_t Size)
		{
			GCC_FORCE_POINTER_ACCESS(Buffer);
    4e8e:	e7 e8       	ldi	r30, 0x87	; 135
    4e90:	f4 e0       	ldi	r31, 0x04	; 4
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    4e92:	2f b7       	in	r18, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    4e94:	f8 94       	cli

			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
			GlobalInterruptDisable();
	
			Buffer->In     = DataPtr;
    4e96:	82 e9       	ldi	r24, 0x92	; 146
    4e98:	94 e0       	ldi	r25, 0x04	; 4
    4e9a:	91 83       	std	Z+1, r25	; 0x01
    4e9c:	80 83       	st	Z, r24
			Buffer->Out    = DataPtr;
    4e9e:	93 83       	std	Z+3, r25	; 0x03
    4ea0:	82 83       	std	Z+2, r24	; 0x02
			Buffer->Start  = &DataPtr[0];
    4ea2:	95 83       	std	Z+5, r25	; 0x05
    4ea4:	84 83       	std	Z+4, r24	; 0x04
			Buffer->End    = &DataPtr[Size];
    4ea6:	82 e9       	ldi	r24, 0x92	; 146
    4ea8:	95 e0       	ldi	r25, 0x05	; 5
    4eaa:	97 83       	std	Z+7, r25	; 0x07
    4eac:	86 83       	std	Z+6, r24	; 0x06
			Buffer->Size   = Size;
    4eae:	10 86       	std	Z+8, r1	; 0x08
			Buffer->Count  = 0;
    4eb0:	12 86       	std	Z+10, r1	; 0x0a
    4eb2:	11 86       	std	Z+9, r1	; 0x09
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    4eb4:	2f bf       	out	0x3f, r18	; 63
		 *  \param[out] DataPtr  Pointer to a global array that will hold the data stored into the ring buffer.
		 *  \param[out] Size     Maximum number of bytes that can be stored in the underlying data array.
		 */
		static inline void RingBuffer_InitBuffer(RingBuffer_t* Buffer, uint8_t* const DataPtr, const uint16_t Size)
		{
			GCC_FORCE_POINTER_ACCESS(Buffer);
    4eb6:	e2 e9       	ldi	r30, 0x92	; 146
    4eb8:	f5 e0       	ldi	r31, 0x05	; 5
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    4eba:	2f b7       	in	r18, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    4ebc:	f8 94       	cli

			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
			GlobalInterruptDisable();
	
			Buffer->In     = DataPtr;
    4ebe:	8d e9       	ldi	r24, 0x9D	; 157
    4ec0:	95 e0       	ldi	r25, 0x05	; 5
    4ec2:	91 83       	std	Z+1, r25	; 0x01
    4ec4:	80 83       	st	Z, r24
			Buffer->Out    = DataPtr;
    4ec6:	93 83       	std	Z+3, r25	; 0x03
    4ec8:	82 83       	std	Z+2, r24	; 0x02
			Buffer->Start  = &DataPtr[0];
    4eca:	95 83       	std	Z+5, r25	; 0x05
    4ecc:	84 83       	std	Z+4, r24	; 0x04
			Buffer->End    = &DataPtr[Size];
    4ece:	8d e9       	ldi	r24, 0x9D	; 157
    4ed0:	96 e0       	ldi	r25, 0x06	; 6
    4ed2:	97 83       	std	Z+7, r25	; 0x07
    4ed4:	86 83       	std	Z+6, r24	; 0x06
			Buffer->Size   = Size;
    4ed6:	10 86       	std	Z+8, r1	; 0x08
			Buffer->Count  = 0;
    4ed8:	12 86       	std	Z+10, r1	; 0x0a
    4eda:	11 86       	std	Z+9, r1	; 0x09
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    4edc:	2f bf       	out	0x3f, r18	; 63
int main(void)
{
    RingBuffer_InitBuffer(&HostRXSerial_Buffer, HostRXSerial_Buffer_Data, sizeof(HostRXSerial_Buffer_Data));
    RingBuffer_InitBuffer(&HostTXSerial_Buffer, HostTXSerial_Buffer_Data, sizeof(HostTXSerial_Buffer_Data));

    SetupHardware();
    4ede:	0e 94 b8 03 	call	0x770	; 0x770 <SetupHardware>
    //LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
    //sei(); // called by init()
    init();
    4ee2:	0e 94 0e 3a 	call	0x741c	; 0x741c <init>
    setup();
    4ee6:	0e 94 50 07 	call	0xea0	; 0xea0 <setup>
            HIDReportInData[6] = 0; // right y exis
            HIDReportInData[7] = 0; // ] - unused
            HIDReportInData[8] = 0; // ]
        }*/

        loop();
    4eea:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <loop>
        if (!CDCTaskRun) CDC_Task(); else CDCTaskRun = false;
    4eee:	80 91 9d 06 	lds	r24, 0x069D
    4ef2:	88 23       	and	r24, r24
    4ef4:	19 f4       	brne	.+6      	; 0x4efc <main+0x6e>
    4ef6:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <CDC_Task>
    4efa:	02 c0       	rjmp	.+4      	; 0x4f00 <main+0x72>
    4efc:	10 92 9d 06 	sts	0x069D, r1
        if (!HIDTaskRun) HID_Task(); else HIDTaskRun = false;
    4f00:	80 91 9e 06 	lds	r24, 0x069E
    4f04:	88 23       	and	r24, r24
    4f06:	19 f4       	brne	.+6      	; 0x4f0e <main+0x80>
    4f08:	0e 94 1f 02 	call	0x43e	; 0x43e <HID_Task>
    4f0c:	02 c0       	rjmp	.+4      	; 0x4f12 <main+0x84>
    4f0e:	10 92 9e 06 	sts	0x069E, r1
        USB_USBTask();
    4f12:	0e 94 80 3f 	call	0x7f00	; 0x7f00 <USB_USBTask>
    4f16:	e9 cf       	rjmp	.-46     	; 0x4eea <main+0x5c>

00004f18 <_Z10mouseclicki>:
                RX400.set_buttons((mouseDown & 1) > 0 ? 1 : 0, (mouseDown & 2) > 0 ? 1 : 0, (mouseDown & 4) > 0 ? 1 : 0);
            #endif /* ENABLE_RX400 */
        }
    }
    
    void mouseclick(int button) {
    4f18:	ef 92       	push	r14
    4f1a:	ff 92       	push	r15
    4f1c:	0f 93       	push	r16
    4f1e:	1f 93       	push	r17
    4f20:	7c 01       	movw	r14, r24
        #ifdef SERIAL_DEBUG_TOUCHSET
            Serial.print("touchset mouseclick ");
    4f22:	00 ef       	ldi	r16, 0xF0	; 240
    4f24:	18 e0       	ldi	r17, 0x08	; 8
    4f26:	c8 01       	movw	r24, r16
    4f28:	69 eb       	ldi	r22, 0xB9	; 185
    4f2a:	72 e0       	ldi	r23, 0x02	; 2
    4f2c:	b0 d6       	rcall	.+3424   	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
            Serial.println(button);
    4f2e:	c8 01       	movw	r24, r16
    4f30:	b7 01       	movw	r22, r14
    4f32:	ab d6       	rcall	.+3414   	; 0x5c8a <_ZN16USBVirtualSerial7printlnEi>
        #endif /* SERIAL_DEBUG_TOUCHSET */
        mousedown(button);
    4f34:	c7 01       	movw	r24, r14
    4f36:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <_Z9mousedowni>
        delay(5);
    4f3a:	65 e0       	ldi	r22, 0x05	; 5
    4f3c:	70 e0       	ldi	r23, 0x00	; 0
    4f3e:	80 e0       	ldi	r24, 0x00	; 0
    4f40:	90 e0       	ldi	r25, 0x00	; 0
    4f42:	0e 94 ea 39 	call	0x73d4	; 0x73d4 <delay>
        mouseup(button);
    4f46:	c7 01       	movw	r24, r14
    4f48:	0e 94 e6 09 	call	0x13cc	; 0x13cc <_Z7mouseupi>
    }
    4f4c:	1f 91       	pop	r17
    4f4e:	0f 91       	pop	r16
    4f50:	ff 90       	pop	r15
    4f52:	ef 90       	pop	r14
    4f54:	08 95       	ret

00004f56 <_Z12disableTimerh>:
// XXX: this function only works properly for timer 2 (the only one we use
// currently).  for the others, it should end the tone, but won't restore
// proper PWM functionality for the timer.
void disableTimer(uint8_t _timer)
{
  switch (_timer)
    4f56:	81 30       	cpi	r24, 0x01	; 1
    4f58:	51 f0       	breq	.+20     	; 0x4f6e <_Z12disableTimerh+0x18>
    4f5a:	81 30       	cpi	r24, 0x01	; 1
    4f5c:	28 f0       	brcs	.+10     	; 0x4f68 <_Z12disableTimerh+0x12>
    4f5e:	82 30       	cpi	r24, 0x02	; 2
    4f60:	61 f0       	breq	.+24     	; 0x4f7a <_Z12disableTimerh+0x24>
    4f62:	83 30       	cpi	r24, 0x03	; 3
    4f64:	e9 f4       	brne	.+58     	; 0x4fa0 <_Z12disableTimerh+0x4a>
    4f66:	1a c0       	rjmp	.+52     	; 0x4f9c <_Z12disableTimerh+0x46>
  {
    case 0:
      #if defined(TIMSK0)
        TIMSK0 = 0;
    4f68:	10 92 6e 00 	sts	0x006E, r1
    4f6c:	08 95       	ret
      #endif
      break;

#if defined(TIMSK1) && defined(OCIE1A)
    case 1:
      bitWrite(TIMSK1, OCIE1A, 0);
    4f6e:	80 91 6f 00 	lds	r24, 0x006F
    4f72:	8d 7f       	andi	r24, 0xFD	; 253
    4f74:	80 93 6f 00 	sts	0x006F, r24
    4f78:	08 95       	ret
      break;
#endif

    case 2:
      #if defined(TIMSK2) && defined(OCIE2A)
        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
    4f7a:	80 91 70 00 	lds	r24, 0x0070
    4f7e:	8d 7f       	andi	r24, 0xFD	; 253
    4f80:	80 93 70 00 	sts	0x0070, r24
      #endif
      #if defined(TCCR2A) && defined(WGM20)
        TCCR2A = (1 << WGM20);
    4f84:	81 e0       	ldi	r24, 0x01	; 1
    4f86:	80 93 b0 00 	sts	0x00B0, r24
      #endif
      #if defined(TCCR2B) && defined(CS22)
        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
    4f8a:	80 91 b1 00 	lds	r24, 0x00B1
    4f8e:	88 7f       	andi	r24, 0xF8	; 248
    4f90:	84 60       	ori	r24, 0x04	; 4
    4f92:	80 93 b1 00 	sts	0x00B1, r24
      #endif
      #if defined(OCR2A)
        OCR2A = 0;
    4f96:	10 92 b3 00 	sts	0x00B3, r1
    4f9a:	08 95       	ret
      #endif
      break;

#if defined(TIMSK3)
    case 3:
      TIMSK3 = 0;
    4f9c:	10 92 71 00 	sts	0x0071, r1
    4fa0:	08 95       	ret

00004fa2 <_Z6noToneh>:
#endif
  }
}


void noTone(uint8_t _pin)
    4fa2:	1f 93       	push	r17
    4fa4:	18 2f       	mov	r17, r24
{
  int8_t _timer = -1;
  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == _pin) {
    4fa6:	80 91 5b 04 	lds	r24, 0x045B
    4faa:	81 17       	cp	r24, r17
    4fac:	11 f0       	breq	.+4      	; 0x4fb2 <_Z6noToneh+0x10>
    4fae:	9f ef       	ldi	r25, 0xFF	; 255
    4fb0:	06 c0       	rjmp	.+12     	; 0x4fbe <_Z6noToneh+0x1c>
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
    4fb2:	e2 e7       	ldi	r30, 0x72	; 114
    4fb4:	f3 e0       	ldi	r31, 0x03	; 3
    4fb6:	94 91       	lpm	r25, Z+
      tone_pins[i] = 255;
    4fb8:	8f ef       	ldi	r24, 0xFF	; 255
    4fba:	80 93 5b 04 	sts	0x045B, r24
    }
  }
  
  disableTimer(_timer);
    4fbe:	89 2f       	mov	r24, r25
    4fc0:	ca df       	rcall	.-108    	; 0x4f56 <_Z12disableTimerh>

  digitalWrite(_pin, 0);
    4fc2:	81 2f       	mov	r24, r17
    4fc4:	60 e0       	ldi	r22, 0x00	; 0
    4fc6:	74 d3       	rcall	.+1768   	; 0x56b0 <digitalWrite>
}
    4fc8:	1f 91       	pop	r17
    4fca:	08 95       	ret

00004fcc <__vector_13>:
  }
}
#endif


ISR(TIMER2_COMPA_vect)
    4fcc:	1f 92       	push	r1
    4fce:	0f 92       	push	r0
    4fd0:	0f b6       	in	r0, 0x3f	; 63
    4fd2:	0f 92       	push	r0
    4fd4:	0b b6       	in	r0, 0x3b	; 59
    4fd6:	0f 92       	push	r0
    4fd8:	11 24       	eor	r1, r1
    4fda:	2f 93       	push	r18
    4fdc:	3f 93       	push	r19
    4fde:	4f 93       	push	r20
    4fe0:	5f 93       	push	r21
    4fe2:	6f 93       	push	r22
    4fe4:	7f 93       	push	r23
    4fe6:	8f 93       	push	r24
    4fe8:	9f 93       	push	r25
    4fea:	af 93       	push	r26
    4fec:	bf 93       	push	r27
    4fee:	ef 93       	push	r30
    4ff0:	ff 93       	push	r31
{

  if (timer2_toggle_count != 0)
    4ff2:	80 91 e2 08 	lds	r24, 0x08E2
    4ff6:	90 91 e3 08 	lds	r25, 0x08E3
    4ffa:	a0 91 e4 08 	lds	r26, 0x08E4
    4ffe:	b0 91 e5 08 	lds	r27, 0x08E5
    5002:	00 97       	sbiw	r24, 0x00	; 0
    5004:	a1 05       	cpc	r26, r1
    5006:	b1 05       	cpc	r27, r1
    5008:	51 f1       	breq	.+84     	; 0x505e <__vector_13+0x92>
  {
    // toggle the pin
    *timer2_pin_port ^= timer2_pin_mask;
    500a:	e0 91 e6 08 	lds	r30, 0x08E6
    500e:	f0 91 e7 08 	lds	r31, 0x08E7
    5012:	80 81       	ld	r24, Z
    5014:	90 91 e8 08 	lds	r25, 0x08E8
    5018:	89 27       	eor	r24, r25
    501a:	80 83       	st	Z, r24

    if (timer2_toggle_count > 0)
    501c:	80 91 e2 08 	lds	r24, 0x08E2
    5020:	90 91 e3 08 	lds	r25, 0x08E3
    5024:	a0 91 e4 08 	lds	r26, 0x08E4
    5028:	b0 91 e5 08 	lds	r27, 0x08E5
    502c:	18 16       	cp	r1, r24
    502e:	19 06       	cpc	r1, r25
    5030:	1a 06       	cpc	r1, r26
    5032:	1b 06       	cpc	r1, r27
    5034:	bc f4       	brge	.+46     	; 0x5064 <__vector_13+0x98>
      timer2_toggle_count--;
    5036:	80 91 e2 08 	lds	r24, 0x08E2
    503a:	90 91 e3 08 	lds	r25, 0x08E3
    503e:	a0 91 e4 08 	lds	r26, 0x08E4
    5042:	b0 91 e5 08 	lds	r27, 0x08E5
    5046:	01 97       	sbiw	r24, 0x01	; 1
    5048:	a1 09       	sbc	r26, r1
    504a:	b1 09       	sbc	r27, r1
    504c:	80 93 e2 08 	sts	0x08E2, r24
    5050:	90 93 e3 08 	sts	0x08E3, r25
    5054:	a0 93 e4 08 	sts	0x08E4, r26
    5058:	b0 93 e5 08 	sts	0x08E5, r27
    505c:	03 c0       	rjmp	.+6      	; 0x5064 <__vector_13+0x98>
  else
  {
    // need to call noTone() so that the tone_pins[] entry is reset, so the
    // timer gets initialized next time we call tone().
    // XXX: this assumes timer 2 is always the first one used.
    noTone(tone_pins[0]);
    505e:	80 91 5b 04 	lds	r24, 0x045B
    5062:	9f df       	rcall	.-194    	; 0x4fa2 <_Z6noToneh>
//    disableTimer(2);
//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
  }
}
    5064:	ff 91       	pop	r31
    5066:	ef 91       	pop	r30
    5068:	bf 91       	pop	r27
    506a:	af 91       	pop	r26
    506c:	9f 91       	pop	r25
    506e:	8f 91       	pop	r24
    5070:	7f 91       	pop	r23
    5072:	6f 91       	pop	r22
    5074:	5f 91       	pop	r21
    5076:	4f 91       	pop	r20
    5078:	3f 91       	pop	r19
    507a:	2f 91       	pop	r18
    507c:	0f 90       	pop	r0
    507e:	0b be       	out	0x3b, r0	; 59
    5080:	0f 90       	pop	r0
    5082:	0f be       	out	0x3f, r0	; 63
    5084:	0f 90       	pop	r0
    5086:	1f 90       	pop	r1
    5088:	18 95       	reti

0000508a <_Z4tonehjm>:



// frequency (in hertz) and duration (in milliseconds).

void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
    508a:	2f 92       	push	r2
    508c:	3f 92       	push	r3
    508e:	5f 92       	push	r5
    5090:	6f 92       	push	r6
    5092:	7f 92       	push	r7
    5094:	8f 92       	push	r8
    5096:	9f 92       	push	r9
    5098:	af 92       	push	r10
    509a:	bf 92       	push	r11
    509c:	cf 92       	push	r12
    509e:	df 92       	push	r13
    50a0:	ef 92       	push	r14
    50a2:	ff 92       	push	r15
    50a4:	0f 93       	push	r16
    50a6:	1f 93       	push	r17
    50a8:	df 93       	push	r29
    50aa:	cf 93       	push	r28
    50ac:	00 d0       	rcall	.+0      	; 0x50ae <_Z4tonehjm+0x24>
    50ae:	00 d0       	rcall	.+0      	; 0x50b0 <_Z4tonehjm+0x26>
    50b0:	cd b7       	in	r28, 0x3d	; 61
    50b2:	de b7       	in	r29, 0x3e	; 62
    50b4:	a8 2f       	mov	r26, r24
    50b6:	1b 01       	movw	r2, r22
    50b8:	29 83       	std	Y+1, r18	; 0x01
    50ba:	3a 83       	std	Y+2, r19	; 0x02
    50bc:	4b 83       	std	Y+3, r20	; 0x03
    50be:	5c 83       	std	Y+4, r21	; 0x04
{
  int8_t _timer = -1;

  // if we're already using the pin, the timer should be configured.  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == _pin) {
    50c0:	80 91 5b 04 	lds	r24, 0x045B
    50c4:	8a 17       	cp	r24, r26
    50c6:	21 f4       	brne	.+8      	; 0x50d0 <_Z4tonehjm+0x46>
      return pgm_read_byte(tone_pin_to_timer_PGM + i);
    50c8:	e2 e7       	ldi	r30, 0x72	; 114
    50ca:	f3 e0       	ldi	r31, 0x03	; 3
    50cc:	54 90       	lpm	r5, Z+
    50ce:	af c0       	rjmp	.+350    	; 0x522e <_Z4tonehjm+0x1a4>
    }
  }
  
  // search for an unused timer.
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == 255) {
    50d0:	8f 3f       	cpi	r24, 0xFF	; 255
    50d2:	09 f0       	breq	.+2      	; 0x50d6 <_Z4tonehjm+0x4c>
    50d4:	29 c2       	rjmp	.+1106   	; 0x5528 <_Z4tonehjm+0x49e>
      tone_pins[i] = _pin;
    50d6:	a0 93 5b 04 	sts	0x045B, r26
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
    50da:	e2 e7       	ldi	r30, 0x72	; 114
    50dc:	f3 e0       	ldi	r31, 0x03	; 3
    50de:	54 90       	lpm	r5, Z+
      break;
    }
  }
  
  if (_timer != -1)
    50e0:	2f ef       	ldi	r18, 0xFF	; 255
    50e2:	52 16       	cp	r5, r18
    50e4:	09 f4       	brne	.+2      	; 0x50e8 <_Z4tonehjm+0x5e>
    50e6:	20 c2       	rjmp	.+1088   	; 0x5528 <_Z4tonehjm+0x49e>
  {
    // Set timer specific stuff
    // All timers in CTC mode
    // 8 bit timers will require changing prescalar values,
    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
    switch (_timer)
    50e8:	81 e0       	ldi	r24, 0x01	; 1
    50ea:	58 16       	cp	r5, r24
    50ec:	71 f1       	breq	.+92     	; 0x514a <_Z4tonehjm+0xc0>
    50ee:	85 15       	cp	r24, r5
    50f0:	1c f0       	brlt	.+6      	; 0x50f8 <_Z4tonehjm+0x6e>
    50f2:	55 20       	and	r5, r5
    50f4:	51 f0       	breq	.+20     	; 0x510a <_Z4tonehjm+0x80>
    50f6:	9b c0       	rjmp	.+310    	; 0x522e <_Z4tonehjm+0x1a4>
    50f8:	92 e0       	ldi	r25, 0x02	; 2
    50fa:	59 16       	cp	r5, r25
    50fc:	09 f4       	brne	.+2      	; 0x5100 <_Z4tonehjm+0x76>
    50fe:	4b c0       	rjmp	.+150    	; 0x5196 <_Z4tonehjm+0x10c>
    5100:	b3 e0       	ldi	r27, 0x03	; 3
    5102:	5b 16       	cp	r5, r27
    5104:	09 f0       	breq	.+2      	; 0x5108 <_Z4tonehjm+0x7e>
    5106:	93 c0       	rjmp	.+294    	; 0x522e <_Z4tonehjm+0x1a4>
    5108:	6c c0       	rjmp	.+216    	; 0x51e2 <_Z4tonehjm+0x158>
    {
      #if defined(TCCR0A) && defined(TCCR0B)
      case 0:
        // 8 bit timer
        TCCR0A = 0;
    510a:	14 bc       	out	0x24, r1	; 36
        TCCR0B = 0;
    510c:	15 bc       	out	0x25, r1	; 37
        bitWrite(TCCR0A, WGM01, 1);
    510e:	84 b5       	in	r24, 0x24	; 36
    5110:	82 60       	ori	r24, 0x02	; 2
    5112:	84 bd       	out	0x24, r24	; 36
        bitWrite(TCCR0B, CS00, 1);
    5114:	85 b5       	in	r24, 0x25	; 37
    5116:	81 60       	ori	r24, 0x01	; 1
    5118:	85 bd       	out	0x25, r24	; 37
        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
    511a:	2a 2f       	mov	r18, r26
    511c:	30 e0       	ldi	r19, 0x00	; 0
    511e:	f9 01       	movw	r30, r18
    5120:	eb 59       	subi	r30, 0x9B	; 155
    5122:	fe 4f       	sbci	r31, 0xFE	; 254
    5124:	e4 91       	lpm	r30, Z+
    5126:	f0 e0       	ldi	r31, 0x00	; 0
    5128:	ee 0f       	add	r30, r30
    512a:	ff 1f       	adc	r31, r31
    512c:	ef 5a       	subi	r30, 0xAF	; 175
    512e:	fe 4f       	sbci	r31, 0xFE	; 254
    5130:	85 91       	lpm	r24, Z+
    5132:	94 91       	lpm	r25, Z+
    5134:	90 93 d9 08 	sts	0x08D9, r25
    5138:	80 93 d8 08 	sts	0x08D8, r24
        timer0_pin_mask = digitalPinToBitMask(_pin);
    513c:	27 58       	subi	r18, 0x87	; 135
    513e:	3e 4f       	sbci	r19, 0xFE	; 254
    5140:	f9 01       	movw	r30, r18
    5142:	84 91       	lpm	r24, Z+
    5144:	80 93 da 08 	sts	0x08DA, r24
    5148:	74 c0       	rjmp	.+232    	; 0x5232 <_Z4tonehjm+0x1a8>
      #endif

      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
      case 1:
        // 16 bit timer
        TCCR1A = 0;
    514a:	10 92 80 00 	sts	0x0080, r1
        TCCR1B = 0;
    514e:	10 92 81 00 	sts	0x0081, r1
        bitWrite(TCCR1B, WGM12, 1);
    5152:	80 91 81 00 	lds	r24, 0x0081
    5156:	88 60       	ori	r24, 0x08	; 8
    5158:	80 93 81 00 	sts	0x0081, r24
        bitWrite(TCCR1B, CS10, 1);
    515c:	80 91 81 00 	lds	r24, 0x0081
    5160:	81 60       	ori	r24, 0x01	; 1
    5162:	80 93 81 00 	sts	0x0081, r24
        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
    5166:	2a 2f       	mov	r18, r26
    5168:	30 e0       	ldi	r19, 0x00	; 0
    516a:	f9 01       	movw	r30, r18
    516c:	eb 59       	subi	r30, 0x9B	; 155
    516e:	fe 4f       	sbci	r31, 0xFE	; 254
    5170:	e4 91       	lpm	r30, Z+
    5172:	f0 e0       	ldi	r31, 0x00	; 0
    5174:	ee 0f       	add	r30, r30
    5176:	ff 1f       	adc	r31, r31
    5178:	ef 5a       	subi	r30, 0xAF	; 175
    517a:	fe 4f       	sbci	r31, 0xFE	; 254
    517c:	85 91       	lpm	r24, Z+
    517e:	94 91       	lpm	r25, Z+
    5180:	90 93 e0 08 	sts	0x08E0, r25
    5184:	80 93 df 08 	sts	0x08DF, r24
        timer1_pin_mask = digitalPinToBitMask(_pin);
    5188:	27 58       	subi	r18, 0x87	; 135
    518a:	3e 4f       	sbci	r19, 0xFE	; 254
    518c:	f9 01       	movw	r30, r18
    518e:	84 91       	lpm	r24, Z+
    5190:	80 93 e1 08 	sts	0x08E1, r24
    5194:	4e c0       	rjmp	.+156    	; 0x5232 <_Z4tonehjm+0x1a8>
      #endif

      #if defined(TCCR2A) && defined(TCCR2B)
      case 2:
        // 8 bit timer
        TCCR2A = 0;
    5196:	10 92 b0 00 	sts	0x00B0, r1
        TCCR2B = 0;
    519a:	10 92 b1 00 	sts	0x00B1, r1
        bitWrite(TCCR2A, WGM21, 1);
    519e:	80 91 b0 00 	lds	r24, 0x00B0
    51a2:	82 60       	ori	r24, 0x02	; 2
    51a4:	80 93 b0 00 	sts	0x00B0, r24
        bitWrite(TCCR2B, CS20, 1);
    51a8:	80 91 b1 00 	lds	r24, 0x00B1
    51ac:	81 60       	ori	r24, 0x01	; 1
    51ae:	80 93 b1 00 	sts	0x00B1, r24
        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
    51b2:	2a 2f       	mov	r18, r26
    51b4:	30 e0       	ldi	r19, 0x00	; 0
    51b6:	f9 01       	movw	r30, r18
    51b8:	eb 59       	subi	r30, 0x9B	; 155
    51ba:	fe 4f       	sbci	r31, 0xFE	; 254
    51bc:	e4 91       	lpm	r30, Z+
    51be:	f0 e0       	ldi	r31, 0x00	; 0
    51c0:	ee 0f       	add	r30, r30
    51c2:	ff 1f       	adc	r31, r31
    51c4:	ef 5a       	subi	r30, 0xAF	; 175
    51c6:	fe 4f       	sbci	r31, 0xFE	; 254
    51c8:	85 91       	lpm	r24, Z+
    51ca:	94 91       	lpm	r25, Z+
    51cc:	90 93 e7 08 	sts	0x08E7, r25
    51d0:	80 93 e6 08 	sts	0x08E6, r24
        timer2_pin_mask = digitalPinToBitMask(_pin);
    51d4:	27 58       	subi	r18, 0x87	; 135
    51d6:	3e 4f       	sbci	r19, 0xFE	; 254
    51d8:	f9 01       	movw	r30, r18
    51da:	84 91       	lpm	r24, Z+
    51dc:	80 93 e8 08 	sts	0x08E8, r24
    51e0:	28 c0       	rjmp	.+80     	; 0x5232 <_Z4tonehjm+0x1a8>
      #endif

      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
      case 3:
        // 16 bit timer
        TCCR3A = 0;
    51e2:	10 92 90 00 	sts	0x0090, r1
        TCCR3B = 0;
    51e6:	10 92 91 00 	sts	0x0091, r1
        bitWrite(TCCR3B, WGM32, 1);
    51ea:	80 91 91 00 	lds	r24, 0x0091
    51ee:	88 60       	ori	r24, 0x08	; 8
    51f0:	80 93 91 00 	sts	0x0091, r24
        bitWrite(TCCR3B, CS30, 1);
    51f4:	80 91 91 00 	lds	r24, 0x0091
    51f8:	81 60       	ori	r24, 0x01	; 1
    51fa:	80 93 91 00 	sts	0x0091, r24
        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
    51fe:	2a 2f       	mov	r18, r26
    5200:	30 e0       	ldi	r19, 0x00	; 0
    5202:	f9 01       	movw	r30, r18
    5204:	eb 59       	subi	r30, 0x9B	; 155
    5206:	fe 4f       	sbci	r31, 0xFE	; 254
    5208:	e4 91       	lpm	r30, Z+
    520a:	f0 e0       	ldi	r31, 0x00	; 0
    520c:	ee 0f       	add	r30, r30
    520e:	ff 1f       	adc	r31, r31
    5210:	ef 5a       	subi	r30, 0xAF	; 175
    5212:	fe 4f       	sbci	r31, 0xFE	; 254
    5214:	85 91       	lpm	r24, Z+
    5216:	94 91       	lpm	r25, Z+
    5218:	90 93 ee 08 	sts	0x08EE, r25
    521c:	80 93 ed 08 	sts	0x08ED, r24
        timer3_pin_mask = digitalPinToBitMask(_pin);
    5220:	27 58       	subi	r18, 0x87	; 135
    5222:	3e 4f       	sbci	r19, 0xFE	; 254
    5224:	f9 01       	movw	r30, r18
    5226:	84 91       	lpm	r24, Z+
    5228:	80 93 ef 08 	sts	0x08EF, r24
    522c:	02 c0       	rjmp	.+4      	; 0x5232 <_Z4tonehjm+0x1a8>
  uint32_t ocr = 0;
  int8_t _timer;

  _timer = toneBegin(_pin);

  if (_timer >= 0)
    522e:	57 fc       	sbrc	r5, 7
    5230:	7b c1       	rjmp	.+758    	; 0x5528 <_Z4tonehjm+0x49e>
  {
    // Set the pinMode as OUTPUT
    pinMode(_pin, OUTPUT);
    5232:	8a 2f       	mov	r24, r26
    5234:	61 e0       	ldi	r22, 0x01	; 1
    5236:	45 d3       	rcall	.+1674   	; 0x58c2 <pinMode>

    // if we are using an 8 bit timer, scan through prescalars to find the best fit
    if (_timer == 0 || _timer == 2)
    5238:	55 20       	and	r5, r5
    523a:	21 f0       	breq	.+8      	; 0x5244 <_Z4tonehjm+0x1ba>
    523c:	f2 e0       	ldi	r31, 0x02	; 2
    523e:	5f 16       	cp	r5, r31
    5240:	09 f0       	breq	.+2      	; 0x5244 <_Z4tonehjm+0x1ba>
    5242:	bd c0       	rjmp	.+378    	; 0x53be <_Z4tonehjm+0x334>
    {
      ocr = F_CPU / frequency / 2 - 1;
    5244:	31 01       	movw	r6, r2
    5246:	88 24       	eor	r8, r8
    5248:	99 24       	eor	r9, r9
    524a:	60 e0       	ldi	r22, 0x00	; 0
    524c:	79 e0       	ldi	r23, 0x09	; 9
    524e:	8d e3       	ldi	r24, 0x3D	; 61
    5250:	90 e0       	ldi	r25, 0x00	; 0
    5252:	a4 01       	movw	r20, r8
    5254:	93 01       	movw	r18, r6
    5256:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    525a:	59 01       	movw	r10, r18
    525c:	6a 01       	movw	r12, r20
    525e:	86 01       	movw	r16, r12
    5260:	75 01       	movw	r14, r10
    5262:	08 94       	sec
    5264:	e1 08       	sbc	r14, r1
    5266:	f1 08       	sbc	r15, r1
    5268:	01 09       	sbc	r16, r1
    526a:	11 09       	sbc	r17, r1
      prescalarbits = 0b001;  // ck/1: same for both timers
      if (ocr > 255)
    526c:	2f ef       	ldi	r18, 0xFF	; 255
    526e:	e2 16       	cp	r14, r18
    5270:	f1 04       	cpc	r15, r1
    5272:	01 05       	cpc	r16, r1
    5274:	11 05       	cpc	r17, r1
    5276:	09 f0       	breq	.+2      	; 0x527a <_Z4tonehjm+0x1f0>
    5278:	08 f4       	brcc	.+2      	; 0x527c <_Z4tonehjm+0x1f2>
    527a:	98 c0       	rjmp	.+304    	; 0x53ac <_Z4tonehjm+0x322>
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
    527c:	60 e2       	ldi	r22, 0x20	; 32
    527e:	71 ea       	ldi	r23, 0xA1	; 161
    5280:	87 e0       	ldi	r24, 0x07	; 7
    5282:	90 e0       	ldi	r25, 0x00	; 0
    5284:	a4 01       	movw	r20, r8
    5286:	93 01       	movw	r18, r6
    5288:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    528c:	79 01       	movw	r14, r18
    528e:	8a 01       	movw	r16, r20
    5290:	08 94       	sec
    5292:	e1 08       	sbc	r14, r1
    5294:	f1 08       	sbc	r15, r1
    5296:	01 09       	sbc	r16, r1
    5298:	11 09       	sbc	r17, r1
        prescalarbits = 0b010;  // ck/8: same for both timers

        if (_timer == 2 && ocr > 255)
    529a:	82 e0       	ldi	r24, 0x02	; 2
    529c:	58 16       	cp	r5, r24
    529e:	c1 f4       	brne	.+48     	; 0x52d0 <_Z4tonehjm+0x246>
    52a0:	9f ef       	ldi	r25, 0xFF	; 255
    52a2:	e9 16       	cp	r14, r25
    52a4:	f1 04       	cpc	r15, r1
    52a6:	01 05       	cpc	r16, r1
    52a8:	11 05       	cpc	r17, r1
    52aa:	09 f0       	breq	.+2      	; 0x52ae <_Z4tonehjm+0x224>
    52ac:	08 f4       	brcc	.+2      	; 0x52b0 <_Z4tonehjm+0x226>
    52ae:	83 c0       	rjmp	.+262    	; 0x53b6 <_Z4tonehjm+0x32c>
        {
          ocr = F_CPU / frequency / 2 / 32 - 1;
    52b0:	68 e4       	ldi	r22, 0x48	; 72
    52b2:	78 ee       	ldi	r23, 0xE8	; 232
    52b4:	81 e0       	ldi	r24, 0x01	; 1
    52b6:	90 e0       	ldi	r25, 0x00	; 0
    52b8:	a4 01       	movw	r20, r8
    52ba:	93 01       	movw	r18, r6
    52bc:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    52c0:	79 01       	movw	r14, r18
    52c2:	8a 01       	movw	r16, r20
    52c4:	08 94       	sec
    52c6:	e1 08       	sbc	r14, r1
    52c8:	f1 08       	sbc	r15, r1
    52ca:	01 09       	sbc	r16, r1
    52cc:	11 09       	sbc	r17, r1
    52ce:	83 e0       	ldi	r24, 0x03	; 3
          prescalarbits = 0b011;
        }

        if (ocr > 255)
    52d0:	af ef       	ldi	r26, 0xFF	; 255
    52d2:	ea 16       	cp	r14, r26
    52d4:	f1 04       	cpc	r15, r1
    52d6:	01 05       	cpc	r16, r1
    52d8:	11 05       	cpc	r17, r1
    52da:	09 f0       	breq	.+2      	; 0x52de <_Z4tonehjm+0x254>
    52dc:	08 f4       	brcc	.+2      	; 0x52e0 <_Z4tonehjm+0x256>
    52de:	67 c0       	rjmp	.+206    	; 0x53ae <_Z4tonehjm+0x324>
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
    52e0:	64 e2       	ldi	r22, 0x24	; 36
    52e2:	74 ef       	ldi	r23, 0xF4	; 244
    52e4:	80 e0       	ldi	r24, 0x00	; 0
    52e6:	90 e0       	ldi	r25, 0x00	; 0
    52e8:	a4 01       	movw	r20, r8
    52ea:	93 01       	movw	r18, r6
    52ec:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    52f0:	79 01       	movw	r14, r18
    52f2:	8a 01       	movw	r16, r20
    52f4:	08 94       	sec
    52f6:	e1 08       	sbc	r14, r1
    52f8:	f1 08       	sbc	r15, r1
    52fa:	01 09       	sbc	r16, r1
    52fc:	11 09       	sbc	r17, r1
          prescalarbits = _timer == 0 ? 0b011 : 0b100;
    52fe:	55 20       	and	r5, r5
    5300:	11 f4       	brne	.+4      	; 0x5306 <_Z4tonehjm+0x27c>
    5302:	83 e0       	ldi	r24, 0x03	; 3
    5304:	1d c0       	rjmp	.+58     	; 0x5340 <_Z4tonehjm+0x2b6>

          if (_timer == 2 && ocr > 255)
    5306:	b2 e0       	ldi	r27, 0x02	; 2
    5308:	5b 16       	cp	r5, r27
    530a:	11 f0       	breq	.+4      	; 0x5310 <_Z4tonehjm+0x286>
    530c:	84 e0       	ldi	r24, 0x04	; 4
    530e:	18 c0       	rjmp	.+48     	; 0x5340 <_Z4tonehjm+0x2b6>
    5310:	ef ef       	ldi	r30, 0xFF	; 255
    5312:	ee 16       	cp	r14, r30
    5314:	f1 04       	cpc	r15, r1
    5316:	01 05       	cpc	r16, r1
    5318:	11 05       	cpc	r17, r1
    531a:	09 f0       	breq	.+2      	; 0x531e <_Z4tonehjm+0x294>
    531c:	08 f4       	brcc	.+2      	; 0x5320 <_Z4tonehjm+0x296>
    531e:	02 c1       	rjmp	.+516    	; 0x5524 <_Z4tonehjm+0x49a>
          {
            ocr = F_CPU / frequency / 2 / 128 - 1;
    5320:	62 e1       	ldi	r22, 0x12	; 18
    5322:	7a e7       	ldi	r23, 0x7A	; 122
    5324:	80 e0       	ldi	r24, 0x00	; 0
    5326:	90 e0       	ldi	r25, 0x00	; 0
    5328:	a4 01       	movw	r20, r8
    532a:	93 01       	movw	r18, r6
    532c:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    5330:	79 01       	movw	r14, r18
    5332:	8a 01       	movw	r16, r20
    5334:	08 94       	sec
    5336:	e1 08       	sbc	r14, r1
    5338:	f1 08       	sbc	r15, r1
    533a:	01 09       	sbc	r16, r1
    533c:	11 09       	sbc	r17, r1
    533e:	85 e0       	ldi	r24, 0x05	; 5
            prescalarbits = 0b101;
          }

          if (ocr > 255)
    5340:	ff ef       	ldi	r31, 0xFF	; 255
    5342:	ef 16       	cp	r14, r31
    5344:	f1 04       	cpc	r15, r1
    5346:	01 05       	cpc	r16, r1
    5348:	11 05       	cpc	r17, r1
    534a:	89 f1       	breq	.+98     	; 0x53ae <_Z4tonehjm+0x324>
    534c:	80 f1       	brcs	.+96     	; 0x53ae <_Z4tonehjm+0x324>
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
    534e:	69 e0       	ldi	r22, 0x09	; 9
    5350:	7d e3       	ldi	r23, 0x3D	; 61
    5352:	80 e0       	ldi	r24, 0x00	; 0
    5354:	90 e0       	ldi	r25, 0x00	; 0
    5356:	a4 01       	movw	r20, r8
    5358:	93 01       	movw	r18, r6
    535a:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    535e:	79 01       	movw	r14, r18
    5360:	8a 01       	movw	r16, r20
    5362:	08 94       	sec
    5364:	e1 08       	sbc	r14, r1
    5366:	f1 08       	sbc	r15, r1
    5368:	01 09       	sbc	r16, r1
    536a:	11 09       	sbc	r17, r1
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
    536c:	55 20       	and	r5, r5
    536e:	11 f0       	breq	.+4      	; 0x5374 <_Z4tonehjm+0x2ea>
    5370:	86 e0       	ldi	r24, 0x06	; 6
    5372:	01 c0       	rjmp	.+2      	; 0x5376 <_Z4tonehjm+0x2ec>
    5374:	84 e0       	ldi	r24, 0x04	; 4
            if (ocr > 255)
    5376:	2f ef       	ldi	r18, 0xFF	; 255
    5378:	e2 16       	cp	r14, r18
    537a:	f1 04       	cpc	r15, r1
    537c:	01 05       	cpc	r16, r1
    537e:	11 05       	cpc	r17, r1
    5380:	b1 f0       	breq	.+44     	; 0x53ae <_Z4tonehjm+0x324>
    5382:	a8 f0       	brcs	.+42     	; 0x53ae <_Z4tonehjm+0x324>
            {
              // can't do any better than /1024
              ocr = F_CPU / frequency / 2 / 1024 - 1;
    5384:	86 01       	movw	r16, r12
    5386:	75 01       	movw	r14, r10
    5388:	9a e0       	ldi	r25, 0x0A	; 10
    538a:	16 95       	lsr	r17
    538c:	07 95       	ror	r16
    538e:	f7 94       	ror	r15
    5390:	e7 94       	ror	r14
    5392:	9a 95       	dec	r25
    5394:	d1 f7       	brne	.-12     	; 0x538a <_Z4tonehjm+0x300>
    5396:	08 94       	sec
    5398:	e1 08       	sbc	r14, r1
    539a:	f1 08       	sbc	r15, r1
    539c:	01 09       	sbc	r16, r1
    539e:	11 09       	sbc	r17, r1
              prescalarbits = _timer == 0 ? 0b101 : 0b111;
    53a0:	55 20       	and	r5, r5
    53a2:	11 f0       	breq	.+4      	; 0x53a8 <_Z4tonehjm+0x31e>
    53a4:	87 e0       	ldi	r24, 0x07	; 7
    53a6:	08 c0       	rjmp	.+16     	; 0x53b8 <_Z4tonehjm+0x32e>
    53a8:	85 e0       	ldi	r24, 0x05	; 5
    53aa:	03 c0       	rjmp	.+6      	; 0x53b2 <_Z4tonehjm+0x328>
    53ac:	81 e0       	ldi	r24, 0x01	; 1
          }
        }
      }

#if defined(TCCR0B)
      if (_timer == 0)
    53ae:	55 20       	and	r5, r5
    53b0:	19 f4       	brne	.+6      	; 0x53b8 <_Z4tonehjm+0x32e>
      {
        TCCR0B = prescalarbits;
    53b2:	85 bd       	out	0x25, r24	; 37
    53b4:	44 c0       	rjmp	.+136    	; 0x543e <_Z4tonehjm+0x3b4>
    53b6:	82 e0       	ldi	r24, 0x02	; 2
      }
      else
#endif
#if defined(TCCR2B)
      {
        TCCR2B = prescalarbits;
    53b8:	80 93 b1 00 	sts	0x00B1, r24
    53bc:	40 c0       	rjmp	.+128    	; 0x543e <_Z4tonehjm+0x3b4>
#endif
    }
    else
    {
      // two choices for the 16 bit timers: ck/1 or ck/64
      ocr = F_CPU / frequency / 2 - 1;
    53be:	51 01       	movw	r10, r2
    53c0:	cc 24       	eor	r12, r12
    53c2:	dd 24       	eor	r13, r13
    53c4:	60 e0       	ldi	r22, 0x00	; 0
    53c6:	79 e0       	ldi	r23, 0x09	; 9
    53c8:	8d e3       	ldi	r24, 0x3D	; 61
    53ca:	90 e0       	ldi	r25, 0x00	; 0
    53cc:	a6 01       	movw	r20, r12
    53ce:	95 01       	movw	r18, r10
    53d0:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    53d4:	79 01       	movw	r14, r18
    53d6:	8a 01       	movw	r16, r20
    53d8:	08 94       	sec
    53da:	e1 08       	sbc	r14, r1
    53dc:	f1 08       	sbc	r15, r1
    53de:	01 09       	sbc	r16, r1
    53e0:	11 09       	sbc	r17, r1

      prescalarbits = 0b001;
      if (ocr > 0xffff)
    53e2:	80 e0       	ldi	r24, 0x00	; 0
    53e4:	e8 16       	cp	r14, r24
    53e6:	80 e0       	ldi	r24, 0x00	; 0
    53e8:	f8 06       	cpc	r15, r24
    53ea:	81 e0       	ldi	r24, 0x01	; 1
    53ec:	08 07       	cpc	r16, r24
    53ee:	80 e0       	ldi	r24, 0x00	; 0
    53f0:	18 07       	cpc	r17, r24
    53f2:	10 f4       	brcc	.+4      	; 0x53f8 <_Z4tonehjm+0x36e>
    53f4:	91 e0       	ldi	r25, 0x01	; 1
    53f6:	10 c0       	rjmp	.+32     	; 0x5418 <_Z4tonehjm+0x38e>
      {
        ocr = F_CPU / frequency / 2 / 64 - 1;
    53f8:	64 e2       	ldi	r22, 0x24	; 36
    53fa:	74 ef       	ldi	r23, 0xF4	; 244
    53fc:	80 e0       	ldi	r24, 0x00	; 0
    53fe:	90 e0       	ldi	r25, 0x00	; 0
    5400:	a6 01       	movw	r20, r12
    5402:	95 01       	movw	r18, r10
    5404:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    5408:	79 01       	movw	r14, r18
    540a:	8a 01       	movw	r16, r20
    540c:	08 94       	sec
    540e:	e1 08       	sbc	r14, r1
    5410:	f1 08       	sbc	r15, r1
    5412:	01 09       	sbc	r16, r1
    5414:	11 09       	sbc	r17, r1
    5416:	93 e0       	ldi	r25, 0x03	; 3
        prescalarbits = 0b011;
      }

      if (_timer == 1)
    5418:	a1 e0       	ldi	r26, 0x01	; 1
    541a:	5a 16       	cp	r5, r26
    541c:	39 f4       	brne	.+14     	; 0x542c <_Z4tonehjm+0x3a2>
      {
#if defined(TCCR1B)
        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
    541e:	80 91 81 00 	lds	r24, 0x0081
    5422:	88 7f       	andi	r24, 0xF8	; 248
    5424:	98 2b       	or	r25, r24
    5426:	90 93 81 00 	sts	0x0081, r25
    542a:	09 c0       	rjmp	.+18     	; 0x543e <_Z4tonehjm+0x3b4>
#endif
      }
#if defined(TCCR3B)
      else if (_timer == 3)
    542c:	b3 e0       	ldi	r27, 0x03	; 3
    542e:	5b 16       	cp	r5, r27
    5430:	31 f4       	brne	.+12     	; 0x543e <_Z4tonehjm+0x3b4>
        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
    5432:	80 91 91 00 	lds	r24, 0x0091
    5436:	88 7f       	andi	r24, 0xF8	; 248
    5438:	98 2b       	or	r25, r24
    543a:	90 93 91 00 	sts	0x0091, r25

    }
    

    // Calculate the toggle count
    if (duration > 0)
    543e:	89 81       	ldd	r24, Y+1	; 0x01
    5440:	9a 81       	ldd	r25, Y+2	; 0x02
    5442:	ab 81       	ldd	r26, Y+3	; 0x03
    5444:	bc 81       	ldd	r27, Y+4	; 0x04
    5446:	00 97       	sbiw	r24, 0x00	; 0
    5448:	a1 05       	cpc	r26, r1
    544a:	b1 05       	cpc	r27, r1
    544c:	29 f4       	brne	.+10     	; 0x5458 <_Z4tonehjm+0x3ce>
    544e:	8f ef       	ldi	r24, 0xFF	; 255
    5450:	9f ef       	ldi	r25, 0xFF	; 255
    5452:	af ef       	ldi	r26, 0xFF	; 255
    5454:	bf ef       	ldi	r27, 0xFF	; 255
    5456:	13 c0       	rjmp	.+38     	; 0x547e <_Z4tonehjm+0x3f4>
    {
      toggle_count = 2 * frequency * duration / 1000;
    5458:	22 0c       	add	r2, r2
    545a:	33 1c       	adc	r3, r3
    545c:	b1 01       	movw	r22, r2
    545e:	80 e0       	ldi	r24, 0x00	; 0
    5460:	90 e0       	ldi	r25, 0x00	; 0
    5462:	29 81       	ldd	r18, Y+1	; 0x01
    5464:	3a 81       	ldd	r19, Y+2	; 0x02
    5466:	4b 81       	ldd	r20, Y+3	; 0x03
    5468:	5c 81       	ldd	r21, Y+4	; 0x04
    546a:	0e 94 5b 43 	call	0x86b6	; 0x86b6 <__mulsi3>
    546e:	28 ee       	ldi	r18, 0xE8	; 232
    5470:	33 e0       	ldi	r19, 0x03	; 3
    5472:	40 e0       	ldi	r20, 0x00	; 0
    5474:	50 e0       	ldi	r21, 0x00	; 0
    5476:	0e 94 8d 43 	call	0x871a	; 0x871a <__udivmodsi4>
    547a:	c9 01       	movw	r24, r18
    547c:	da 01       	movw	r26, r20
    }

    // Set the OCR for the given timer,
    // set the toggle count,
    // then turn on the interrupts
    switch (_timer)
    547e:	e1 e0       	ldi	r30, 0x01	; 1
    5480:	5e 16       	cp	r5, r30
    5482:	e1 f0       	breq	.+56     	; 0x54bc <_Z4tonehjm+0x432>
    5484:	e5 15       	cp	r30, r5
    5486:	1c f0       	brlt	.+6      	; 0x548e <_Z4tonehjm+0x404>
    5488:	55 20       	and	r5, r5
    548a:	49 f0       	breq	.+18     	; 0x549e <_Z4tonehjm+0x414>
    548c:	4d c0       	rjmp	.+154    	; 0x5528 <_Z4tonehjm+0x49e>
    548e:	f2 e0       	ldi	r31, 0x02	; 2
    5490:	5f 16       	cp	r5, r31
    5492:	31 f1       	breq	.+76     	; 0x54e0 <_Z4tonehjm+0x456>
    5494:	23 e0       	ldi	r18, 0x03	; 3
    5496:	52 16       	cp	r5, r18
    5498:	09 f0       	breq	.+2      	; 0x549c <_Z4tonehjm+0x412>
    549a:	46 c0       	rjmp	.+140    	; 0x5528 <_Z4tonehjm+0x49e>
    549c:	31 c0       	rjmp	.+98     	; 0x5500 <_Z4tonehjm+0x476>
    {

#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
      case 0:
        OCR0A = ocr;
    549e:	e7 bc       	out	0x27, r14	; 39
        timer0_toggle_count = toggle_count;
    54a0:	80 93 d4 08 	sts	0x08D4, r24
    54a4:	90 93 d5 08 	sts	0x08D5, r25
    54a8:	a0 93 d6 08 	sts	0x08D6, r26
    54ac:	b0 93 d7 08 	sts	0x08D7, r27
        bitWrite(TIMSK0, OCIE0A, 1);
    54b0:	80 91 6e 00 	lds	r24, 0x006E
    54b4:	82 60       	ori	r24, 0x02	; 2
    54b6:	80 93 6e 00 	sts	0x006E, r24
    54ba:	36 c0       	rjmp	.+108    	; 0x5528 <_Z4tonehjm+0x49e>
        break;
#endif

      case 1:
#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
        OCR1A = ocr;
    54bc:	f0 92 89 00 	sts	0x0089, r15
    54c0:	e0 92 88 00 	sts	0x0088, r14
        timer1_toggle_count = toggle_count;
    54c4:	80 93 db 08 	sts	0x08DB, r24
    54c8:	90 93 dc 08 	sts	0x08DC, r25
    54cc:	a0 93 dd 08 	sts	0x08DD, r26
    54d0:	b0 93 de 08 	sts	0x08DE, r27
        bitWrite(TIMSK1, OCIE1A, 1);
    54d4:	80 91 6f 00 	lds	r24, 0x006F
    54d8:	82 60       	ori	r24, 0x02	; 2
    54da:	80 93 6f 00 	sts	0x006F, r24
    54de:	24 c0       	rjmp	.+72     	; 0x5528 <_Z4tonehjm+0x49e>
#endif
        break;

#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
      case 2:
        OCR2A = ocr;
    54e0:	e0 92 b3 00 	sts	0x00B3, r14
        timer2_toggle_count = toggle_count;
    54e4:	80 93 e2 08 	sts	0x08E2, r24
    54e8:	90 93 e3 08 	sts	0x08E3, r25
    54ec:	a0 93 e4 08 	sts	0x08E4, r26
    54f0:	b0 93 e5 08 	sts	0x08E5, r27
        bitWrite(TIMSK2, OCIE2A, 1);
    54f4:	80 91 70 00 	lds	r24, 0x0070
    54f8:	82 60       	ori	r24, 0x02	; 2
    54fa:	80 93 70 00 	sts	0x0070, r24
    54fe:	14 c0       	rjmp	.+40     	; 0x5528 <_Z4tonehjm+0x49e>
        break;
#endif

#if defined(TIMSK3)
      case 3:
        OCR3A = ocr;
    5500:	f0 92 99 00 	sts	0x0099, r15
    5504:	e0 92 98 00 	sts	0x0098, r14
        timer3_toggle_count = toggle_count;
    5508:	80 93 e9 08 	sts	0x08E9, r24
    550c:	90 93 ea 08 	sts	0x08EA, r25
    5510:	a0 93 eb 08 	sts	0x08EB, r26
    5514:	b0 93 ec 08 	sts	0x08EC, r27
        bitWrite(TIMSK3, OCIE3A, 1);
    5518:	80 91 71 00 	lds	r24, 0x0071
    551c:	82 60       	ori	r24, 0x02	; 2
    551e:	80 93 71 00 	sts	0x0071, r24
    5522:	02 c0       	rjmp	.+4      	; 0x5528 <_Z4tonehjm+0x49e>
        break;
#endif

    }
  }
}
    5524:	84 e0       	ldi	r24, 0x04	; 4
    5526:	48 cf       	rjmp	.-368    	; 0x53b8 <_Z4tonehjm+0x32e>
    5528:	0f 90       	pop	r0
    552a:	0f 90       	pop	r0
    552c:	0f 90       	pop	r0
    552e:	0f 90       	pop	r0
    5530:	cf 91       	pop	r28
    5532:	df 91       	pop	r29
    5534:	1f 91       	pop	r17
    5536:	0f 91       	pop	r16
    5538:	ff 90       	pop	r15
    553a:	ef 90       	pop	r14
    553c:	df 90       	pop	r13
    553e:	cf 90       	pop	r12
    5540:	bf 90       	pop	r11
    5542:	af 90       	pop	r10
    5544:	9f 90       	pop	r9
    5546:	8f 90       	pop	r8
    5548:	7f 90       	pop	r7
    554a:	6f 90       	pop	r6
    554c:	5f 90       	pop	r5
    554e:	3f 90       	pop	r3
    5550:	2f 90       	pop	r2
    5552:	08 95       	ret

00005554 <RingBuffer_Insert>:
		 *
		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to insert into.
		 *  \param[in]     Data    Data element to insert into the buffer.
		 */
		static inline void RingBuffer_Insert(RingBuffer_t* Buffer,
		                                     const uint8_t Data)
    5554:	cf 93       	push	r28
    5556:	df 93       	push	r29
		{
			GCC_FORCE_POINTER_ACCESS(Buffer);
    5558:	ec 01       	movw	r28, r24

			*Buffer->In = Data;
    555a:	e8 81       	ld	r30, Y
    555c:	f9 81       	ldd	r31, Y+1	; 0x01
    555e:	60 83       	st	Z, r22

			if (++Buffer->In == Buffer->End)
    5560:	88 81       	ld	r24, Y
    5562:	99 81       	ldd	r25, Y+1	; 0x01
    5564:	01 96       	adiw	r24, 0x01	; 1
    5566:	99 83       	std	Y+1, r25	; 0x01
    5568:	88 83       	st	Y, r24
    556a:	2e 81       	ldd	r18, Y+6	; 0x06
    556c:	3f 81       	ldd	r19, Y+7	; 0x07
    556e:	82 17       	cp	r24, r18
    5570:	93 07       	cpc	r25, r19
    5572:	21 f4       	brne	.+8      	; 0x557c <RingBuffer_Insert+0x28>
			  Buffer->In = Buffer->Start;
    5574:	8c 81       	ldd	r24, Y+4	; 0x04
    5576:	9d 81       	ldd	r25, Y+5	; 0x05
    5578:	99 83       	std	Y+1, r25	; 0x01
    557a:	88 83       	st	Y, r24
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    557c:	2f b7       	in	r18, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    557e:	f8 94       	cli

			uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
			GlobalInterruptDisable();
			
			Buffer->Count++;
    5580:	89 85       	ldd	r24, Y+9	; 0x09
    5582:	9a 85       	ldd	r25, Y+10	; 0x0a
    5584:	01 96       	adiw	r24, 0x01	; 1
    5586:	9a 87       	std	Y+10, r25	; 0x0a
    5588:	89 87       	std	Y+9, r24	; 0x09
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    558a:	2f bf       	out	0x3f, r18	; 63

			SetGlobalInterruptMask(CurrentGlobalInt);
		}
    558c:	df 91       	pop	r29
    558e:	cf 91       	pop	r28
    5590:	08 95       	ret

00005592 <_ZN16USBVirtualSerial5beginEm>:

extern "C" {
    #include "Keyglove.h"
}

void USBVirtualSerial::begin(uint32_t baud) { /* no baud setting for virtual serial */ }
    5592:	08 95       	ret

00005594 <_ZN14HardwareSerial5beginEm>:
void USBVirtualSerial::println(unsigned int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(long int val, byte format) { println(ltoa(val, numStr, DEC)); }
void USBVirtualSerial::println(long unsigned int val, byte format) { println(ultoa(val, numStr, DEC)); }
void USBVirtualSerial::println(double val, byte format) { println(ultoa(val, numStr, DEC)); }

void HardwareSerial::begin(uint32_t baud) { /*Serial_Init(baud, false);*/ }
    5594:	08 95       	ret

00005596 <_ZN14HardwareSerial5printEPKc>:
// bool Serial_IsCharReceived();

void HardwareSerial::print(const char *str) { }
    5596:	08 95       	ret

00005598 <_ZN14HardwareSerial5printEh>:
void HardwareSerial::print(byte val) { }
    5598:	08 95       	ret

0000559a <_ZN14HardwareSerial5printEi>:
void HardwareSerial::print(int val) { }
    559a:	08 95       	ret

0000559c <_ZN14HardwareSerial5printEm>:
void HardwareSerial::print(long unsigned int val) { }
    559c:	08 95       	ret

0000559e <_ZN14HardwareSerial5printEe>:
void HardwareSerial::print(long double val) { }
    559e:	08 95       	ret

000055a0 <_ZN14HardwareSerial5printEPKci>:

void HardwareSerial::print(const char *str, int format) { }
    55a0:	08 95       	ret

000055a2 <_ZN14HardwareSerial5printEhi>:
void HardwareSerial::print(byte val, int format) { }
    55a2:	08 95       	ret

000055a4 <_ZN14HardwareSerial5printEii>:
void HardwareSerial::print(int val, int format) { }
    55a4:	08 95       	ret

000055a6 <_ZN14HardwareSerial5printEmi>:
void HardwareSerial::print(long unsigned int val, int format) { }
    55a6:	08 95       	ret

000055a8 <_ZN14HardwareSerial5printEei>:
void HardwareSerial::print(long double val, int format) { }
    55a8:	08 95       	ret

000055aa <_ZN14HardwareSerial7printlnEPKc>:

void HardwareSerial::println(const char *str) { }
    55aa:	08 95       	ret

000055ac <_ZN14HardwareSerial7printlnEh>:
void HardwareSerial::println(byte val) { }
    55ac:	08 95       	ret

000055ae <_ZN14HardwareSerial7printlnEi>:
void HardwareSerial::println(int val) { }
    55ae:	08 95       	ret

000055b0 <_ZN14HardwareSerial7printlnEm>:
void HardwareSerial::println(long unsigned int val) { }
    55b0:	08 95       	ret

000055b2 <_ZN14HardwareSerial7printlnEe>:
void HardwareSerial::println(long double val) { }
    55b2:	08 95       	ret

000055b4 <_ZN14HardwareSerial7printlnEPKci>:

void HardwareSerial::println(const char *str, int format) { }
    55b4:	08 95       	ret

000055b6 <_ZN14HardwareSerial7printlnEhi>:
void HardwareSerial::println(byte val, int format) { }
    55b6:	08 95       	ret

000055b8 <_ZN14HardwareSerial7printlnEii>:
void HardwareSerial::println(int val, int format) { }
    55b8:	08 95       	ret

000055ba <_ZN14HardwareSerial7printlnEmi>:
void HardwareSerial::println(long unsigned int val, int format) { }
    55ba:	08 95       	ret

000055bc <_ZN14HardwareSerial7printlnEei>:
void HardwareSerial::println(long double val, int format) { }
    55bc:	08 95       	ret

000055be <_ZN11USBKeyboard12set_modifierEh>:
    report[3] = z;
    memcpy(HIDReportInData + 1, report, 8);
    HID_Task();
}

void USBKeyboard::set_modifier(uint8_t modifier) {
    55be:	fc 01       	movw	r30, r24
    report[0] = modifier;
    55c0:	60 83       	st	Z, r22
}
    55c2:	08 95       	ret

000055c4 <_ZN11USBKeyboard8set_key1Eh>:
void USBKeyboard::set_key1(uint8_t code) {
    report[2] = code;
    55c4:	fc 01       	movw	r30, r24
    55c6:	62 83       	std	Z+2, r22	; 0x02
}
    55c8:	08 95       	ret

000055ca <_ZN11USBKeyboard8set_key2Eh>:
void USBKeyboard::set_key2(uint8_t code) {
    report[3] = code;
    55ca:	fc 01       	movw	r30, r24
    55cc:	63 83       	std	Z+3, r22	; 0x03
}
    55ce:	08 95       	ret

000055d0 <_ZN11USBKeyboard8set_key3Eh>:
void USBKeyboard::set_key3(uint8_t code) {
    report[4] = code;
    55d0:	fc 01       	movw	r30, r24
    55d2:	64 83       	std	Z+4, r22	; 0x04
}
    55d4:	08 95       	ret

000055d6 <_ZN11USBKeyboard8set_key4Eh>:
void USBKeyboard::set_key4(uint8_t code) {
    report[5] = code;
    55d6:	fc 01       	movw	r30, r24
    55d8:	65 83       	std	Z+5, r22	; 0x05
}
    55da:	08 95       	ret

000055dc <_ZN11USBKeyboard8set_key5Eh>:
void USBKeyboard::set_key5(uint8_t code) {
    report[6] = code;
    55dc:	fc 01       	movw	r30, r24
    55de:	66 83       	std	Z+6, r22	; 0x06
}
    55e0:	08 95       	ret

000055e2 <_ZN11USBKeyboard8set_key6Eh>:
void USBKeyboard::set_key6(uint8_t code) {
    report[7] = code;
    55e2:	fc 01       	movw	r30, r24
    55e4:	67 83       	std	Z+7, r22	; 0x07
}
    55e6:	08 95       	ret

000055e8 <_ZN7WireI2C5beginEv>:
    HIDReportInData[0] = HID_REPORTID_KeyboardReport;
    memcpy(HIDReportInData + 1, report, 8);
    HID_Task();
}

void WireI2C::begin() { }
    55e8:	08 95       	ret

000055ea <_ZN7WireI2C17beginTransmissionEi>:
void WireI2C::beginTransmission(int) { }
    55ea:	08 95       	ret

000055ec <_ZN7WireI2C15endTransmissionEv>:
void WireI2C::endTransmission() { }
    55ec:	08 95       	ret

000055ee <_ZN7WireI2C4sendEh>:
void WireI2C::send(byte) { }
    55ee:	08 95       	ret

000055f0 <_ZN7WireI2C7receiveEv>:
byte WireI2C::receive() { return 0; }
    55f0:	80 e0       	ldi	r24, 0x00	; 0
    55f2:	08 95       	ret

000055f4 <_ZN7WireI2C11requestFromEii>:
void WireI2C::requestFrom(int, int) { }
    55f4:	08 95       	ret

000055f6 <_ZN7WireI2C9availableEv>:
bool WireI2C::available() { return false; }
    55f6:	80 e0       	ldi	r24, 0x00	; 0
    55f8:	08 95       	ret

000055fa <digitalRead>:

int digitalRead(uint8_t pin) {
    55fa:	98 2f       	mov	r25, r24
    if (pin >= 0 && pin < 8) {
    55fc:	88 30       	cpi	r24, 0x08	; 8
    55fe:	60 f4       	brcc	.+24     	; 0x5618 <digitalRead+0x1e>
        return PIND & (1 << pin);
    5600:	89 b1       	in	r24, 0x09	; 9
    5602:	41 e0       	ldi	r20, 0x01	; 1
    5604:	50 e0       	ldi	r21, 0x00	; 0
    5606:	02 c0       	rjmp	.+4      	; 0x560c <digitalRead+0x12>
    5608:	44 0f       	add	r20, r20
    560a:	55 1f       	adc	r21, r21
    560c:	9a 95       	dec	r25
    560e:	e2 f7       	brpl	.-8      	; 0x5608 <digitalRead+0xe>
    5610:	90 e0       	ldi	r25, 0x00	; 0
    5612:	48 23       	and	r20, r24
    5614:	59 23       	and	r21, r25
    5616:	4a c0       	rjmp	.+148    	; 0x56ac <digitalRead+0xb2>
    } else if (pin >= 8 && pin < 10) {
    5618:	88 50       	subi	r24, 0x08	; 8
    561a:	82 30       	cpi	r24, 0x02	; 2
    561c:	28 f4       	brcc	.+10     	; 0x5628 <digitalRead+0x2e>
        return PINE & (1 << (pin - 8));
    561e:	2c b1       	in	r18, 0x0c	; 12
    5620:	89 2f       	mov	r24, r25
    5622:	90 e0       	ldi	r25, 0x00	; 0
    5624:	08 97       	sbiw	r24, 0x08	; 8
    5626:	38 c0       	rjmp	.+112    	; 0x5698 <digitalRead+0x9e>
    } else if (pin >= 10 && pin < 18) {
    5628:	89 2f       	mov	r24, r25
    562a:	8a 50       	subi	r24, 0x0A	; 10
    562c:	88 30       	cpi	r24, 0x08	; 8
    562e:	28 f4       	brcc	.+10     	; 0x563a <digitalRead+0x40>
        return PINC & (1 << (pin - 10));
    5630:	26 b1       	in	r18, 0x06	; 6
    5632:	89 2f       	mov	r24, r25
    5634:	90 e0       	ldi	r25, 0x00	; 0
    5636:	0a 97       	sbiw	r24, 0x0a	; 10
    5638:	2f c0       	rjmp	.+94     	; 0x5698 <digitalRead+0x9e>
    } else if (pin >= 18 && pin < 20) {
    563a:	89 2f       	mov	r24, r25
    563c:	82 51       	subi	r24, 0x12	; 18
    563e:	82 30       	cpi	r24, 0x02	; 2
    5640:	28 f4       	brcc	.+10     	; 0x564c <digitalRead+0x52>
        return PINE & (1 << (pin - 18 + 6));
    5642:	2c b1       	in	r18, 0x0c	; 12
    5644:	89 2f       	mov	r24, r25
    5646:	90 e0       	ldi	r25, 0x00	; 0
    5648:	0c 97       	sbiw	r24, 0x0c	; 12
    564a:	26 c0       	rjmp	.+76     	; 0x5698 <digitalRead+0x9e>
    } else if (pin >= 20 && pin < 28) {
    564c:	89 2f       	mov	r24, r25
    564e:	84 51       	subi	r24, 0x14	; 20
    5650:	88 30       	cpi	r24, 0x08	; 8
    5652:	28 f4       	brcc	.+10     	; 0x565e <digitalRead+0x64>
        return PINB & (1 << (pin - 20));
    5654:	23 b1       	in	r18, 0x03	; 3
    5656:	89 2f       	mov	r24, r25
    5658:	90 e0       	ldi	r25, 0x00	; 0
    565a:	44 97       	sbiw	r24, 0x14	; 20
    565c:	1d c0       	rjmp	.+58     	; 0x5698 <digitalRead+0x9e>
    } else if (pin >= 28 && pin < 36) {
    565e:	89 2f       	mov	r24, r25
    5660:	8c 51       	subi	r24, 0x1C	; 28
    5662:	88 30       	cpi	r24, 0x08	; 8
    5664:	28 f4       	brcc	.+10     	; 0x5670 <digitalRead+0x76>
        return PINA & (1 << (pin - 28));
    5666:	20 b1       	in	r18, 0x00	; 0
    5668:	89 2f       	mov	r24, r25
    566a:	90 e0       	ldi	r25, 0x00	; 0
    566c:	4c 97       	sbiw	r24, 0x1c	; 28
    566e:	14 c0       	rjmp	.+40     	; 0x5698 <digitalRead+0x9e>
    } else if (pin >= 36 && pin < 38) {
    5670:	89 2f       	mov	r24, r25
    5672:	84 52       	subi	r24, 0x24	; 36
    5674:	82 30       	cpi	r24, 0x02	; 2
    5676:	28 f4       	brcc	.+10     	; 0x5682 <digitalRead+0x88>
        return PINE & (1 << (pin - 36 + 4));
    5678:	2c b1       	in	r18, 0x0c	; 12
    567a:	89 2f       	mov	r24, r25
    567c:	90 e0       	ldi	r25, 0x00	; 0
    567e:	80 97       	sbiw	r24, 0x20	; 32
    5680:	0b c0       	rjmp	.+22     	; 0x5698 <digitalRead+0x9e>
    } else if (pin >= 38 && pin < 46) {
    5682:	89 2f       	mov	r24, r25
    5684:	86 52       	subi	r24, 0x26	; 38
    5686:	88 30       	cpi	r24, 0x08	; 8
    5688:	18 f0       	brcs	.+6      	; 0x5690 <digitalRead+0x96>
    568a:	40 e0       	ldi	r20, 0x00	; 0
    568c:	50 e0       	ldi	r21, 0x00	; 0
    568e:	0e c0       	rjmp	.+28     	; 0x56ac <digitalRead+0xb2>
        return PINF & (1 << (pin - 38));
    5690:	2f b1       	in	r18, 0x0f	; 15
    5692:	89 2f       	mov	r24, r25
    5694:	90 e0       	ldi	r25, 0x00	; 0
    5696:	86 97       	sbiw	r24, 0x26	; 38
    5698:	41 e0       	ldi	r20, 0x01	; 1
    569a:	50 e0       	ldi	r21, 0x00	; 0
    569c:	02 c0       	rjmp	.+4      	; 0x56a2 <digitalRead+0xa8>
    569e:	44 0f       	add	r20, r20
    56a0:	55 1f       	adc	r21, r21
    56a2:	8a 95       	dec	r24
    56a4:	e2 f7       	brpl	.-8      	; 0x569e <digitalRead+0xa4>
    56a6:	30 e0       	ldi	r19, 0x00	; 0
    56a8:	42 23       	and	r20, r18
    56aa:	53 23       	and	r21, r19
    }
    return 0;
}
    56ac:	ca 01       	movw	r24, r20
    56ae:	08 95       	ret

000056b0 <digitalWrite>:

void digitalWrite(uint8_t pin, uint8_t level) {
    56b0:	38 2f       	mov	r19, r24
    if (level == LOW) {
    56b2:	66 23       	and	r22, r22
    56b4:	09 f0       	breq	.+2      	; 0x56b8 <digitalWrite+0x8>
    56b6:	86 c0       	rjmp	.+268    	; 0x57c4 <digitalWrite+0x114>
        if (pin >= 0 && pin < 8) {
    56b8:	88 30       	cpi	r24, 0x08	; 8
    56ba:	60 f4       	brcc	.+24     	; 0x56d4 <digitalWrite+0x24>
            PORTD &= ~(1 << pin);
    56bc:	2b b1       	in	r18, 0x0b	; 11
    56be:	81 e0       	ldi	r24, 0x01	; 1
    56c0:	90 e0       	ldi	r25, 0x00	; 0
    56c2:	02 c0       	rjmp	.+4      	; 0x56c8 <digitalWrite+0x18>
    56c4:	88 0f       	add	r24, r24
    56c6:	99 1f       	adc	r25, r25
    56c8:	3a 95       	dec	r19
    56ca:	e2 f7       	brpl	.-8      	; 0x56c4 <digitalWrite+0x14>
    56cc:	80 95       	com	r24
    56ce:	82 23       	and	r24, r18
    56d0:	8b b9       	out	0x0b, r24	; 11
    56d2:	08 95       	ret
        } else if (pin >= 8 && pin < 10) {
    56d4:	88 50       	subi	r24, 0x08	; 8
    56d6:	82 30       	cpi	r24, 0x02	; 2
    56d8:	30 f4       	brcc	.+12     	; 0x56e6 <digitalWrite+0x36>
            PORTE &= ~(1 << (pin - 8));
    56da:	4e b1       	in	r20, 0x0e	; 14
    56dc:	23 2f       	mov	r18, r19
    56de:	30 e0       	ldi	r19, 0x00	; 0
    56e0:	28 50       	subi	r18, 0x08	; 8
    56e2:	30 40       	sbci	r19, 0x00	; 0
    56e4:	4f c0       	rjmp	.+158    	; 0x5784 <digitalWrite+0xd4>
        } else if (pin >= 10 && pin < 18) {
    56e6:	83 2f       	mov	r24, r19
    56e8:	8a 50       	subi	r24, 0x0A	; 10
    56ea:	88 30       	cpi	r24, 0x08	; 8
    56ec:	80 f4       	brcc	.+32     	; 0x570e <digitalWrite+0x5e>
            PORTC &= ~(1 << (pin - 10));
    56ee:	48 b1       	in	r20, 0x08	; 8
    56f0:	23 2f       	mov	r18, r19
    56f2:	30 e0       	ldi	r19, 0x00	; 0
    56f4:	2a 50       	subi	r18, 0x0A	; 10
    56f6:	30 40       	sbci	r19, 0x00	; 0
    56f8:	81 e0       	ldi	r24, 0x01	; 1
    56fa:	90 e0       	ldi	r25, 0x00	; 0
    56fc:	02 c0       	rjmp	.+4      	; 0x5702 <digitalWrite+0x52>
    56fe:	88 0f       	add	r24, r24
    5700:	99 1f       	adc	r25, r25
    5702:	2a 95       	dec	r18
    5704:	e2 f7       	brpl	.-8      	; 0x56fe <digitalWrite+0x4e>
    5706:	80 95       	com	r24
    5708:	84 23       	and	r24, r20
    570a:	88 b9       	out	0x08, r24	; 8
    570c:	08 95       	ret
        } else if (pin >= 18 && pin < 20) {
    570e:	83 2f       	mov	r24, r19
    5710:	82 51       	subi	r24, 0x12	; 18
    5712:	82 30       	cpi	r24, 0x02	; 2
    5714:	30 f4       	brcc	.+12     	; 0x5722 <digitalWrite+0x72>
            PORTE &= ~(1 << (pin - 18 + 6));
    5716:	4e b1       	in	r20, 0x0e	; 14
    5718:	23 2f       	mov	r18, r19
    571a:	30 e0       	ldi	r19, 0x00	; 0
    571c:	2c 50       	subi	r18, 0x0C	; 12
    571e:	30 40       	sbci	r19, 0x00	; 0
    5720:	31 c0       	rjmp	.+98     	; 0x5784 <digitalWrite+0xd4>
        } else if (pin >= 20 && pin < 28) {
    5722:	83 2f       	mov	r24, r19
    5724:	84 51       	subi	r24, 0x14	; 20
    5726:	88 30       	cpi	r24, 0x08	; 8
    5728:	80 f4       	brcc	.+32     	; 0x574a <digitalWrite+0x9a>
            PORTB &= ~(1 << (pin - 20));
    572a:	45 b1       	in	r20, 0x05	; 5
    572c:	23 2f       	mov	r18, r19
    572e:	30 e0       	ldi	r19, 0x00	; 0
    5730:	24 51       	subi	r18, 0x14	; 20
    5732:	30 40       	sbci	r19, 0x00	; 0
    5734:	81 e0       	ldi	r24, 0x01	; 1
    5736:	90 e0       	ldi	r25, 0x00	; 0
    5738:	02 c0       	rjmp	.+4      	; 0x573e <digitalWrite+0x8e>
    573a:	88 0f       	add	r24, r24
    573c:	99 1f       	adc	r25, r25
    573e:	2a 95       	dec	r18
    5740:	e2 f7       	brpl	.-8      	; 0x573a <digitalWrite+0x8a>
    5742:	80 95       	com	r24
    5744:	84 23       	and	r24, r20
    5746:	85 b9       	out	0x05, r24	; 5
    5748:	08 95       	ret
        } else if (pin >= 28 && pin < 36) {
    574a:	83 2f       	mov	r24, r19
    574c:	8c 51       	subi	r24, 0x1C	; 28
    574e:	88 30       	cpi	r24, 0x08	; 8
    5750:	80 f4       	brcc	.+32     	; 0x5772 <digitalWrite+0xc2>
            PORTA &= ~(1 << (pin - 28));
    5752:	42 b1       	in	r20, 0x02	; 2
    5754:	23 2f       	mov	r18, r19
    5756:	30 e0       	ldi	r19, 0x00	; 0
    5758:	2c 51       	subi	r18, 0x1C	; 28
    575a:	30 40       	sbci	r19, 0x00	; 0
    575c:	81 e0       	ldi	r24, 0x01	; 1
    575e:	90 e0       	ldi	r25, 0x00	; 0
    5760:	02 c0       	rjmp	.+4      	; 0x5766 <digitalWrite+0xb6>
    5762:	88 0f       	add	r24, r24
    5764:	99 1f       	adc	r25, r25
    5766:	2a 95       	dec	r18
    5768:	e2 f7       	brpl	.-8      	; 0x5762 <digitalWrite+0xb2>
    576a:	80 95       	com	r24
    576c:	84 23       	and	r24, r20
    576e:	82 b9       	out	0x02, r24	; 2
    5770:	08 95       	ret
        } else if (pin >= 36 && pin < 38) {
    5772:	83 2f       	mov	r24, r19
    5774:	84 52       	subi	r24, 0x24	; 36
    5776:	82 30       	cpi	r24, 0x02	; 2
    5778:	80 f4       	brcc	.+32     	; 0x579a <digitalWrite+0xea>
            PORTE &= ~(1 << (pin - 36 + 4));
    577a:	4e b1       	in	r20, 0x0e	; 14
    577c:	23 2f       	mov	r18, r19
    577e:	30 e0       	ldi	r19, 0x00	; 0
    5780:	20 52       	subi	r18, 0x20	; 32
    5782:	30 40       	sbci	r19, 0x00	; 0
    5784:	81 e0       	ldi	r24, 0x01	; 1
    5786:	90 e0       	ldi	r25, 0x00	; 0
    5788:	02 c0       	rjmp	.+4      	; 0x578e <digitalWrite+0xde>
    578a:	88 0f       	add	r24, r24
    578c:	99 1f       	adc	r25, r25
    578e:	2a 95       	dec	r18
    5790:	e2 f7       	brpl	.-8      	; 0x578a <digitalWrite+0xda>
    5792:	80 95       	com	r24
    5794:	84 23       	and	r24, r20
    5796:	8e b9       	out	0x0e, r24	; 14
    5798:	08 95       	ret
        } else if (pin >= 38 && pin < 46) {
    579a:	83 2f       	mov	r24, r19
    579c:	86 52       	subi	r24, 0x26	; 38
    579e:	88 30       	cpi	r24, 0x08	; 8
    57a0:	08 f0       	brcs	.+2      	; 0x57a4 <digitalWrite+0xf4>
    57a2:	8e c0       	rjmp	.+284    	; 0x58c0 <digitalWrite+0x210>
            PORTF &= ~(1 << (pin - 38));
    57a4:	41 b3       	in	r20, 0x11	; 17
    57a6:	23 2f       	mov	r18, r19
    57a8:	30 e0       	ldi	r19, 0x00	; 0
    57aa:	26 52       	subi	r18, 0x26	; 38
    57ac:	30 40       	sbci	r19, 0x00	; 0
    57ae:	81 e0       	ldi	r24, 0x01	; 1
    57b0:	90 e0       	ldi	r25, 0x00	; 0
    57b2:	02 c0       	rjmp	.+4      	; 0x57b8 <digitalWrite+0x108>
    57b4:	88 0f       	add	r24, r24
    57b6:	99 1f       	adc	r25, r25
    57b8:	2a 95       	dec	r18
    57ba:	e2 f7       	brpl	.-8      	; 0x57b4 <digitalWrite+0x104>
    57bc:	80 95       	com	r24
    57be:	84 23       	and	r24, r20
    57c0:	81 bb       	out	0x11, r24	; 17
    57c2:	08 95       	ret
        }
    } else {
        if (pin >= 0 && pin < 8) {
    57c4:	88 30       	cpi	r24, 0x08	; 8
    57c6:	58 f4       	brcc	.+22     	; 0x57de <digitalWrite+0x12e>
            PORTD |= (1 << pin);
    57c8:	2b b1       	in	r18, 0x0b	; 11
    57ca:	81 e0       	ldi	r24, 0x01	; 1
    57cc:	90 e0       	ldi	r25, 0x00	; 0
    57ce:	02 c0       	rjmp	.+4      	; 0x57d4 <digitalWrite+0x124>
    57d0:	88 0f       	add	r24, r24
    57d2:	99 1f       	adc	r25, r25
    57d4:	3a 95       	dec	r19
    57d6:	e2 f7       	brpl	.-8      	; 0x57d0 <digitalWrite+0x120>
    57d8:	28 2b       	or	r18, r24
    57da:	2b b9       	out	0x0b, r18	; 11
    57dc:	08 95       	ret
        } else if (pin >= 8 && pin < 10) {
    57de:	88 50       	subi	r24, 0x08	; 8
    57e0:	82 30       	cpi	r24, 0x02	; 2
    57e2:	30 f4       	brcc	.+12     	; 0x57f0 <digitalWrite+0x140>
            PORTE |= (1 << (pin - 8));
    57e4:	4e b1       	in	r20, 0x0e	; 14
    57e6:	23 2f       	mov	r18, r19
    57e8:	30 e0       	ldi	r19, 0x00	; 0
    57ea:	28 50       	subi	r18, 0x08	; 8
    57ec:	30 40       	sbci	r19, 0x00	; 0
    57ee:	4c c0       	rjmp	.+152    	; 0x5888 <digitalWrite+0x1d8>
        } else if (pin >= 10 && pin < 18) {
    57f0:	83 2f       	mov	r24, r19
    57f2:	8a 50       	subi	r24, 0x0A	; 10
    57f4:	88 30       	cpi	r24, 0x08	; 8
    57f6:	78 f4       	brcc	.+30     	; 0x5816 <digitalWrite+0x166>
            PORTC |= (1 << (pin - 10));
    57f8:	48 b1       	in	r20, 0x08	; 8
    57fa:	23 2f       	mov	r18, r19
    57fc:	30 e0       	ldi	r19, 0x00	; 0
    57fe:	2a 50       	subi	r18, 0x0A	; 10
    5800:	30 40       	sbci	r19, 0x00	; 0
    5802:	81 e0       	ldi	r24, 0x01	; 1
    5804:	90 e0       	ldi	r25, 0x00	; 0
    5806:	02 c0       	rjmp	.+4      	; 0x580c <digitalWrite+0x15c>
    5808:	88 0f       	add	r24, r24
    580a:	99 1f       	adc	r25, r25
    580c:	2a 95       	dec	r18
    580e:	e2 f7       	brpl	.-8      	; 0x5808 <digitalWrite+0x158>
    5810:	48 2b       	or	r20, r24
    5812:	48 b9       	out	0x08, r20	; 8
    5814:	08 95       	ret
        } else if (pin >= 18 && pin < 20) {
    5816:	83 2f       	mov	r24, r19
    5818:	82 51       	subi	r24, 0x12	; 18
    581a:	82 30       	cpi	r24, 0x02	; 2
    581c:	30 f4       	brcc	.+12     	; 0x582a <digitalWrite+0x17a>
            PORTE |= (1 << (pin - 18 + 6));
    581e:	4e b1       	in	r20, 0x0e	; 14
    5820:	23 2f       	mov	r18, r19
    5822:	30 e0       	ldi	r19, 0x00	; 0
    5824:	2c 50       	subi	r18, 0x0C	; 12
    5826:	30 40       	sbci	r19, 0x00	; 0
    5828:	2f c0       	rjmp	.+94     	; 0x5888 <digitalWrite+0x1d8>
        } else if (pin >= 20 && pin < 28) {
    582a:	83 2f       	mov	r24, r19
    582c:	84 51       	subi	r24, 0x14	; 20
    582e:	88 30       	cpi	r24, 0x08	; 8
    5830:	78 f4       	brcc	.+30     	; 0x5850 <digitalWrite+0x1a0>
            PORTB |= (1 << (pin - 20));
    5832:	45 b1       	in	r20, 0x05	; 5
    5834:	23 2f       	mov	r18, r19
    5836:	30 e0       	ldi	r19, 0x00	; 0
    5838:	24 51       	subi	r18, 0x14	; 20
    583a:	30 40       	sbci	r19, 0x00	; 0
    583c:	81 e0       	ldi	r24, 0x01	; 1
    583e:	90 e0       	ldi	r25, 0x00	; 0
    5840:	02 c0       	rjmp	.+4      	; 0x5846 <digitalWrite+0x196>
    5842:	88 0f       	add	r24, r24
    5844:	99 1f       	adc	r25, r25
    5846:	2a 95       	dec	r18
    5848:	e2 f7       	brpl	.-8      	; 0x5842 <digitalWrite+0x192>
    584a:	48 2b       	or	r20, r24
    584c:	45 b9       	out	0x05, r20	; 5
    584e:	08 95       	ret
        } else if (pin >= 28 && pin < 36) {
    5850:	83 2f       	mov	r24, r19
    5852:	8c 51       	subi	r24, 0x1C	; 28
    5854:	88 30       	cpi	r24, 0x08	; 8
    5856:	78 f4       	brcc	.+30     	; 0x5876 <digitalWrite+0x1c6>
            PORTA |= (1 << (pin - 28));
    5858:	42 b1       	in	r20, 0x02	; 2
    585a:	23 2f       	mov	r18, r19
    585c:	30 e0       	ldi	r19, 0x00	; 0
    585e:	2c 51       	subi	r18, 0x1C	; 28
    5860:	30 40       	sbci	r19, 0x00	; 0
    5862:	81 e0       	ldi	r24, 0x01	; 1
    5864:	90 e0       	ldi	r25, 0x00	; 0
    5866:	02 c0       	rjmp	.+4      	; 0x586c <digitalWrite+0x1bc>
    5868:	88 0f       	add	r24, r24
    586a:	99 1f       	adc	r25, r25
    586c:	2a 95       	dec	r18
    586e:	e2 f7       	brpl	.-8      	; 0x5868 <digitalWrite+0x1b8>
    5870:	48 2b       	or	r20, r24
    5872:	42 b9       	out	0x02, r20	; 2
    5874:	08 95       	ret
        } else if (pin >= 36 && pin < 38) {
    5876:	83 2f       	mov	r24, r19
    5878:	84 52       	subi	r24, 0x24	; 36
    587a:	82 30       	cpi	r24, 0x02	; 2
    587c:	78 f4       	brcc	.+30     	; 0x589c <digitalWrite+0x1ec>
            PORTE |= (1 << (pin - 36 + 4));
    587e:	4e b1       	in	r20, 0x0e	; 14
    5880:	23 2f       	mov	r18, r19
    5882:	30 e0       	ldi	r19, 0x00	; 0
    5884:	20 52       	subi	r18, 0x20	; 32
    5886:	30 40       	sbci	r19, 0x00	; 0
    5888:	81 e0       	ldi	r24, 0x01	; 1
    588a:	90 e0       	ldi	r25, 0x00	; 0
    588c:	02 c0       	rjmp	.+4      	; 0x5892 <digitalWrite+0x1e2>
    588e:	88 0f       	add	r24, r24
    5890:	99 1f       	adc	r25, r25
    5892:	2a 95       	dec	r18
    5894:	e2 f7       	brpl	.-8      	; 0x588e <digitalWrite+0x1de>
    5896:	48 2b       	or	r20, r24
    5898:	4e b9       	out	0x0e, r20	; 14
    589a:	08 95       	ret
        } else if (pin >= 38 && pin < 46) {
    589c:	83 2f       	mov	r24, r19
    589e:	86 52       	subi	r24, 0x26	; 38
    58a0:	88 30       	cpi	r24, 0x08	; 8
    58a2:	70 f4       	brcc	.+28     	; 0x58c0 <digitalWrite+0x210>
            PORTF |= (1 << (pin - 38));
    58a4:	41 b3       	in	r20, 0x11	; 17
    58a6:	23 2f       	mov	r18, r19
    58a8:	30 e0       	ldi	r19, 0x00	; 0
    58aa:	26 52       	subi	r18, 0x26	; 38
    58ac:	30 40       	sbci	r19, 0x00	; 0
    58ae:	81 e0       	ldi	r24, 0x01	; 1
    58b0:	90 e0       	ldi	r25, 0x00	; 0
    58b2:	02 c0       	rjmp	.+4      	; 0x58b8 <digitalWrite+0x208>
    58b4:	88 0f       	add	r24, r24
    58b6:	99 1f       	adc	r25, r25
    58b8:	2a 95       	dec	r18
    58ba:	e2 f7       	brpl	.-8      	; 0x58b4 <digitalWrite+0x204>
    58bc:	48 2b       	or	r20, r24
    58be:	41 bb       	out	0x11, r20	; 17
    58c0:	08 95       	ret

000058c2 <pinMode>:
        }
    }
}

void pinMode(byte pin, byte mode) {
    58c2:	38 2f       	mov	r19, r24
    if (mode == INPUT) {
    58c4:	66 23       	and	r22, r22
    58c6:	09 f0       	breq	.+2      	; 0x58ca <pinMode+0x8>
    58c8:	86 c0       	rjmp	.+268    	; 0x59d6 <pinMode+0x114>
        if (pin >= 0 && pin < 8) {
    58ca:	88 30       	cpi	r24, 0x08	; 8
    58cc:	60 f4       	brcc	.+24     	; 0x58e6 <pinMode+0x24>
            DDRD &= ~(1 << pin);
    58ce:	2a b1       	in	r18, 0x0a	; 10
    58d0:	81 e0       	ldi	r24, 0x01	; 1
    58d2:	90 e0       	ldi	r25, 0x00	; 0
    58d4:	02 c0       	rjmp	.+4      	; 0x58da <pinMode+0x18>
    58d6:	88 0f       	add	r24, r24
    58d8:	99 1f       	adc	r25, r25
    58da:	3a 95       	dec	r19
    58dc:	e2 f7       	brpl	.-8      	; 0x58d6 <pinMode+0x14>
    58de:	80 95       	com	r24
    58e0:	82 23       	and	r24, r18
    58e2:	8a b9       	out	0x0a, r24	; 10
    58e4:	08 95       	ret
        } else if (pin >= 8 && pin < 10) {
    58e6:	88 50       	subi	r24, 0x08	; 8
    58e8:	82 30       	cpi	r24, 0x02	; 2
    58ea:	30 f4       	brcc	.+12     	; 0x58f8 <pinMode+0x36>
            DDRE &= ~(1 << (pin - 8));
    58ec:	4d b1       	in	r20, 0x0d	; 13
    58ee:	23 2f       	mov	r18, r19
    58f0:	30 e0       	ldi	r19, 0x00	; 0
    58f2:	28 50       	subi	r18, 0x08	; 8
    58f4:	30 40       	sbci	r19, 0x00	; 0
    58f6:	4f c0       	rjmp	.+158    	; 0x5996 <pinMode+0xd4>
        } else if (pin >= 10 && pin < 18) {
    58f8:	83 2f       	mov	r24, r19
    58fa:	8a 50       	subi	r24, 0x0A	; 10
    58fc:	88 30       	cpi	r24, 0x08	; 8
    58fe:	80 f4       	brcc	.+32     	; 0x5920 <pinMode+0x5e>
            DDRC &= ~(1 << (pin - 10));
    5900:	47 b1       	in	r20, 0x07	; 7
    5902:	23 2f       	mov	r18, r19
    5904:	30 e0       	ldi	r19, 0x00	; 0
    5906:	2a 50       	subi	r18, 0x0A	; 10
    5908:	30 40       	sbci	r19, 0x00	; 0
    590a:	81 e0       	ldi	r24, 0x01	; 1
    590c:	90 e0       	ldi	r25, 0x00	; 0
    590e:	02 c0       	rjmp	.+4      	; 0x5914 <pinMode+0x52>
    5910:	88 0f       	add	r24, r24
    5912:	99 1f       	adc	r25, r25
    5914:	2a 95       	dec	r18
    5916:	e2 f7       	brpl	.-8      	; 0x5910 <pinMode+0x4e>
    5918:	80 95       	com	r24
    591a:	84 23       	and	r24, r20
    591c:	87 b9       	out	0x07, r24	; 7
    591e:	08 95       	ret
        } else if (pin >= 18 && pin < 20) {
    5920:	83 2f       	mov	r24, r19
    5922:	82 51       	subi	r24, 0x12	; 18
    5924:	82 30       	cpi	r24, 0x02	; 2
    5926:	30 f4       	brcc	.+12     	; 0x5934 <pinMode+0x72>
            DDRE &= ~(1 << (pin - 18 + 6));
    5928:	4d b1       	in	r20, 0x0d	; 13
    592a:	23 2f       	mov	r18, r19
    592c:	30 e0       	ldi	r19, 0x00	; 0
    592e:	2c 50       	subi	r18, 0x0C	; 12
    5930:	30 40       	sbci	r19, 0x00	; 0
    5932:	31 c0       	rjmp	.+98     	; 0x5996 <pinMode+0xd4>
        } else if (pin >= 20 && pin < 28) {
    5934:	83 2f       	mov	r24, r19
    5936:	84 51       	subi	r24, 0x14	; 20
    5938:	88 30       	cpi	r24, 0x08	; 8
    593a:	80 f4       	brcc	.+32     	; 0x595c <pinMode+0x9a>
            DDRB &= ~(1 << (pin - 20));
    593c:	44 b1       	in	r20, 0x04	; 4
    593e:	23 2f       	mov	r18, r19
    5940:	30 e0       	ldi	r19, 0x00	; 0
    5942:	24 51       	subi	r18, 0x14	; 20
    5944:	30 40       	sbci	r19, 0x00	; 0
    5946:	81 e0       	ldi	r24, 0x01	; 1
    5948:	90 e0       	ldi	r25, 0x00	; 0
    594a:	02 c0       	rjmp	.+4      	; 0x5950 <pinMode+0x8e>
    594c:	88 0f       	add	r24, r24
    594e:	99 1f       	adc	r25, r25
    5950:	2a 95       	dec	r18
    5952:	e2 f7       	brpl	.-8      	; 0x594c <pinMode+0x8a>
    5954:	80 95       	com	r24
    5956:	84 23       	and	r24, r20
    5958:	84 b9       	out	0x04, r24	; 4
    595a:	08 95       	ret
        } else if (pin >= 28 && pin < 36) {
    595c:	83 2f       	mov	r24, r19
    595e:	8c 51       	subi	r24, 0x1C	; 28
    5960:	88 30       	cpi	r24, 0x08	; 8
    5962:	80 f4       	brcc	.+32     	; 0x5984 <pinMode+0xc2>
            DDRA &= ~(1 << (pin - 28));
    5964:	41 b1       	in	r20, 0x01	; 1
    5966:	23 2f       	mov	r18, r19
    5968:	30 e0       	ldi	r19, 0x00	; 0
    596a:	2c 51       	subi	r18, 0x1C	; 28
    596c:	30 40       	sbci	r19, 0x00	; 0
    596e:	81 e0       	ldi	r24, 0x01	; 1
    5970:	90 e0       	ldi	r25, 0x00	; 0
    5972:	02 c0       	rjmp	.+4      	; 0x5978 <pinMode+0xb6>
    5974:	88 0f       	add	r24, r24
    5976:	99 1f       	adc	r25, r25
    5978:	2a 95       	dec	r18
    597a:	e2 f7       	brpl	.-8      	; 0x5974 <pinMode+0xb2>
    597c:	80 95       	com	r24
    597e:	84 23       	and	r24, r20
    5980:	81 b9       	out	0x01, r24	; 1
    5982:	08 95       	ret
        } else if (pin >= 36 && pin < 38) {
    5984:	83 2f       	mov	r24, r19
    5986:	84 52       	subi	r24, 0x24	; 36
    5988:	82 30       	cpi	r24, 0x02	; 2
    598a:	80 f4       	brcc	.+32     	; 0x59ac <pinMode+0xea>
            DDRE &= ~(1 << (pin - 36 + 4));
    598c:	4d b1       	in	r20, 0x0d	; 13
    598e:	23 2f       	mov	r18, r19
    5990:	30 e0       	ldi	r19, 0x00	; 0
    5992:	20 52       	subi	r18, 0x20	; 32
    5994:	30 40       	sbci	r19, 0x00	; 0
    5996:	81 e0       	ldi	r24, 0x01	; 1
    5998:	90 e0       	ldi	r25, 0x00	; 0
    599a:	02 c0       	rjmp	.+4      	; 0x59a0 <pinMode+0xde>
    599c:	88 0f       	add	r24, r24
    599e:	99 1f       	adc	r25, r25
    59a0:	2a 95       	dec	r18
    59a2:	e2 f7       	brpl	.-8      	; 0x599c <pinMode+0xda>
    59a4:	80 95       	com	r24
    59a6:	84 23       	and	r24, r20
    59a8:	8d b9       	out	0x0d, r24	; 13
    59aa:	08 95       	ret
        } else if (pin >= 38 && pin < 46) {
    59ac:	83 2f       	mov	r24, r19
    59ae:	86 52       	subi	r24, 0x26	; 38
    59b0:	88 30       	cpi	r24, 0x08	; 8
    59b2:	08 f0       	brcs	.+2      	; 0x59b6 <pinMode+0xf4>
    59b4:	8e c0       	rjmp	.+284    	; 0x5ad2 <pinMode+0x210>
            DDRF &= ~(1 << (pin - 38));
    59b6:	40 b3       	in	r20, 0x10	; 16
    59b8:	23 2f       	mov	r18, r19
    59ba:	30 e0       	ldi	r19, 0x00	; 0
    59bc:	26 52       	subi	r18, 0x26	; 38
    59be:	30 40       	sbci	r19, 0x00	; 0
    59c0:	81 e0       	ldi	r24, 0x01	; 1
    59c2:	90 e0       	ldi	r25, 0x00	; 0
    59c4:	02 c0       	rjmp	.+4      	; 0x59ca <pinMode+0x108>
    59c6:	88 0f       	add	r24, r24
    59c8:	99 1f       	adc	r25, r25
    59ca:	2a 95       	dec	r18
    59cc:	e2 f7       	brpl	.-8      	; 0x59c6 <pinMode+0x104>
    59ce:	80 95       	com	r24
    59d0:	84 23       	and	r24, r20
    59d2:	80 bb       	out	0x10, r24	; 16
    59d4:	08 95       	ret
        }
    } else {
        if (pin >= 0 && pin < 8) {
    59d6:	88 30       	cpi	r24, 0x08	; 8
    59d8:	58 f4       	brcc	.+22     	; 0x59f0 <pinMode+0x12e>
            DDRD |= (1 << pin);
    59da:	2a b1       	in	r18, 0x0a	; 10
    59dc:	81 e0       	ldi	r24, 0x01	; 1
    59de:	90 e0       	ldi	r25, 0x00	; 0
    59e0:	02 c0       	rjmp	.+4      	; 0x59e6 <pinMode+0x124>
    59e2:	88 0f       	add	r24, r24
    59e4:	99 1f       	adc	r25, r25
    59e6:	3a 95       	dec	r19
    59e8:	e2 f7       	brpl	.-8      	; 0x59e2 <pinMode+0x120>
    59ea:	28 2b       	or	r18, r24
    59ec:	2a b9       	out	0x0a, r18	; 10
    59ee:	08 95       	ret
        } else if (pin >= 8 && pin < 10) {
    59f0:	88 50       	subi	r24, 0x08	; 8
    59f2:	82 30       	cpi	r24, 0x02	; 2
    59f4:	30 f4       	brcc	.+12     	; 0x5a02 <pinMode+0x140>
            DDRE |= (1 << (pin - 8));
    59f6:	4d b1       	in	r20, 0x0d	; 13
    59f8:	23 2f       	mov	r18, r19
    59fa:	30 e0       	ldi	r19, 0x00	; 0
    59fc:	28 50       	subi	r18, 0x08	; 8
    59fe:	30 40       	sbci	r19, 0x00	; 0
    5a00:	4c c0       	rjmp	.+152    	; 0x5a9a <pinMode+0x1d8>
        } else if (pin >= 10 && pin < 18) {
    5a02:	83 2f       	mov	r24, r19
    5a04:	8a 50       	subi	r24, 0x0A	; 10
    5a06:	88 30       	cpi	r24, 0x08	; 8
    5a08:	78 f4       	brcc	.+30     	; 0x5a28 <pinMode+0x166>
            DDRC |= (1 << (pin - 10));
    5a0a:	47 b1       	in	r20, 0x07	; 7
    5a0c:	23 2f       	mov	r18, r19
    5a0e:	30 e0       	ldi	r19, 0x00	; 0
    5a10:	2a 50       	subi	r18, 0x0A	; 10
    5a12:	30 40       	sbci	r19, 0x00	; 0
    5a14:	81 e0       	ldi	r24, 0x01	; 1
    5a16:	90 e0       	ldi	r25, 0x00	; 0
    5a18:	02 c0       	rjmp	.+4      	; 0x5a1e <pinMode+0x15c>
    5a1a:	88 0f       	add	r24, r24
    5a1c:	99 1f       	adc	r25, r25
    5a1e:	2a 95       	dec	r18
    5a20:	e2 f7       	brpl	.-8      	; 0x5a1a <pinMode+0x158>
    5a22:	48 2b       	or	r20, r24
    5a24:	47 b9       	out	0x07, r20	; 7
    5a26:	08 95       	ret
        } else if (pin >= 18 && pin < 20) {
    5a28:	83 2f       	mov	r24, r19
    5a2a:	82 51       	subi	r24, 0x12	; 18
    5a2c:	82 30       	cpi	r24, 0x02	; 2
    5a2e:	30 f4       	brcc	.+12     	; 0x5a3c <pinMode+0x17a>
            DDRE |= (1 << (pin - 18 + 6));
    5a30:	4d b1       	in	r20, 0x0d	; 13
    5a32:	23 2f       	mov	r18, r19
    5a34:	30 e0       	ldi	r19, 0x00	; 0
    5a36:	2c 50       	subi	r18, 0x0C	; 12
    5a38:	30 40       	sbci	r19, 0x00	; 0
    5a3a:	2f c0       	rjmp	.+94     	; 0x5a9a <pinMode+0x1d8>
        } else if (pin >= 20 && pin < 28) {
    5a3c:	83 2f       	mov	r24, r19
    5a3e:	84 51       	subi	r24, 0x14	; 20
    5a40:	88 30       	cpi	r24, 0x08	; 8
    5a42:	78 f4       	brcc	.+30     	; 0x5a62 <pinMode+0x1a0>
            DDRB |= (1 << (pin - 20));
    5a44:	44 b1       	in	r20, 0x04	; 4
    5a46:	23 2f       	mov	r18, r19
    5a48:	30 e0       	ldi	r19, 0x00	; 0
    5a4a:	24 51       	subi	r18, 0x14	; 20
    5a4c:	30 40       	sbci	r19, 0x00	; 0
    5a4e:	81 e0       	ldi	r24, 0x01	; 1
    5a50:	90 e0       	ldi	r25, 0x00	; 0
    5a52:	02 c0       	rjmp	.+4      	; 0x5a58 <pinMode+0x196>
    5a54:	88 0f       	add	r24, r24
    5a56:	99 1f       	adc	r25, r25
    5a58:	2a 95       	dec	r18
    5a5a:	e2 f7       	brpl	.-8      	; 0x5a54 <pinMode+0x192>
    5a5c:	48 2b       	or	r20, r24
    5a5e:	44 b9       	out	0x04, r20	; 4
    5a60:	08 95       	ret
        } else if (pin >= 28 && pin < 36) {
    5a62:	83 2f       	mov	r24, r19
    5a64:	8c 51       	subi	r24, 0x1C	; 28
    5a66:	88 30       	cpi	r24, 0x08	; 8
    5a68:	78 f4       	brcc	.+30     	; 0x5a88 <pinMode+0x1c6>
            DDRA |= (1 << (pin - 28));
    5a6a:	41 b1       	in	r20, 0x01	; 1
    5a6c:	23 2f       	mov	r18, r19
    5a6e:	30 e0       	ldi	r19, 0x00	; 0
    5a70:	2c 51       	subi	r18, 0x1C	; 28
    5a72:	30 40       	sbci	r19, 0x00	; 0
    5a74:	81 e0       	ldi	r24, 0x01	; 1
    5a76:	90 e0       	ldi	r25, 0x00	; 0
    5a78:	02 c0       	rjmp	.+4      	; 0x5a7e <pinMode+0x1bc>
    5a7a:	88 0f       	add	r24, r24
    5a7c:	99 1f       	adc	r25, r25
    5a7e:	2a 95       	dec	r18
    5a80:	e2 f7       	brpl	.-8      	; 0x5a7a <pinMode+0x1b8>
    5a82:	48 2b       	or	r20, r24
    5a84:	41 b9       	out	0x01, r20	; 1
    5a86:	08 95       	ret
        } else if (pin >= 36 && pin < 38) {
    5a88:	83 2f       	mov	r24, r19
    5a8a:	84 52       	subi	r24, 0x24	; 36
    5a8c:	82 30       	cpi	r24, 0x02	; 2
    5a8e:	78 f4       	brcc	.+30     	; 0x5aae <pinMode+0x1ec>
            DDRE |= (1 << (pin - 36 + 4));
    5a90:	4d b1       	in	r20, 0x0d	; 13
    5a92:	23 2f       	mov	r18, r19
    5a94:	30 e0       	ldi	r19, 0x00	; 0
    5a96:	20 52       	subi	r18, 0x20	; 32
    5a98:	30 40       	sbci	r19, 0x00	; 0
    5a9a:	81 e0       	ldi	r24, 0x01	; 1
    5a9c:	90 e0       	ldi	r25, 0x00	; 0
    5a9e:	02 c0       	rjmp	.+4      	; 0x5aa4 <pinMode+0x1e2>
    5aa0:	88 0f       	add	r24, r24
    5aa2:	99 1f       	adc	r25, r25
    5aa4:	2a 95       	dec	r18
    5aa6:	e2 f7       	brpl	.-8      	; 0x5aa0 <pinMode+0x1de>
    5aa8:	48 2b       	or	r20, r24
    5aaa:	4d b9       	out	0x0d, r20	; 13
    5aac:	08 95       	ret
        } else if (pin >= 38 && pin < 46) {
    5aae:	83 2f       	mov	r24, r19
    5ab0:	86 52       	subi	r24, 0x26	; 38
    5ab2:	88 30       	cpi	r24, 0x08	; 8
    5ab4:	70 f4       	brcc	.+28     	; 0x5ad2 <pinMode+0x210>
            DDRF |= (1 << (pin - 38));
    5ab6:	40 b3       	in	r20, 0x10	; 16
    5ab8:	23 2f       	mov	r18, r19
    5aba:	30 e0       	ldi	r19, 0x00	; 0
    5abc:	26 52       	subi	r18, 0x26	; 38
    5abe:	30 40       	sbci	r19, 0x00	; 0
    5ac0:	81 e0       	ldi	r24, 0x01	; 1
    5ac2:	90 e0       	ldi	r25, 0x00	; 0
    5ac4:	02 c0       	rjmp	.+4      	; 0x5aca <pinMode+0x208>
    5ac6:	88 0f       	add	r24, r24
    5ac8:	99 1f       	adc	r25, r25
    5aca:	2a 95       	dec	r18
    5acc:	e2 f7       	brpl	.-8      	; 0x5ac6 <pinMode+0x204>
    5ace:	48 2b       	or	r20, r24
    5ad0:	40 bb       	out	0x10, r20	; 16
    5ad2:	08 95       	ret

00005ad4 <_ZN11USBKeyboard8send_nowEv>:
}
void USBKeyboard::set_key6(uint8_t code) {
    report[7] = code;
}
void USBKeyboard::send_now() {
    HIDReportInData[0] = HID_REPORTID_KeyboardReport;
    5ad4:	22 e0       	ldi	r18, 0x02	; 2
    5ad6:	20 93 75 04 	sts	0x0475, r18
    memcpy(HIDReportInData + 1, report, 8);
    5ada:	a6 e7       	ldi	r26, 0x76	; 118
    5adc:	b4 e0       	ldi	r27, 0x04	; 4
    5ade:	fc 01       	movw	r30, r24
    5ae0:	88 e0       	ldi	r24, 0x08	; 8
    5ae2:	01 90       	ld	r0, Z+
    5ae4:	0d 92       	st	X+, r0
    5ae6:	81 50       	subi	r24, 0x01	; 1
    5ae8:	e1 f7       	brne	.-8      	; 0x5ae2 <_ZN11USBKeyboard8send_nowEv+0xe>
    HID_Task();
    5aea:	0c 94 1f 02 	jmp	0x43e	; 0x43e <HID_Task>

00005aee <_ZN8USBMouse6scrollEh>:
    HIDReportInData[0] = HID_REPORTID_MouseReport;
    report[0] = (b1 << 2) + (b2 << 1) + b3;
    memcpy(HIDReportInData + 1, report, 8);
    HID_Task();
}
void USBMouse::scroll(uint8_t z) {
    5aee:	fc 01       	movw	r30, r24
    HIDReportInData[0] = HID_REPORTID_MouseReport;
    5af0:	81 e0       	ldi	r24, 0x01	; 1
    5af2:	80 93 75 04 	sts	0x0475, r24
    report[1] = 0;
    5af6:	11 82       	std	Z+1, r1	; 0x01
    report[2] = 0;
    5af8:	12 82       	std	Z+2, r1	; 0x02
    report[3] = z;
    5afa:	63 83       	std	Z+3, r22	; 0x03
    memcpy(HIDReportInData + 1, report, 8);
    5afc:	a6 e7       	ldi	r26, 0x76	; 118
    5afe:	b4 e0       	ldi	r27, 0x04	; 4
    5b00:	88 e0       	ldi	r24, 0x08	; 8
    5b02:	01 90       	ld	r0, Z+
    5b04:	0d 92       	st	X+, r0
    5b06:	81 50       	subi	r24, 0x01	; 1
    5b08:	e1 f7       	brne	.-8      	; 0x5b02 <_ZN8USBMouse6scrollEh+0x14>
    HID_Task();
    5b0a:	0c 94 1f 02 	jmp	0x43e	; 0x43e <HID_Task>

00005b0e <_ZN8USBMouse11set_buttonsEhhh>:
    report[2] = y;
    report[3] = z;
    memcpy(HIDReportInData + 1, report, 8);
    HID_Task();
}
void USBMouse::set_buttons(uint8_t b1, uint8_t b2, uint8_t b3) {
    5b0e:	fc 01       	movw	r30, r24
    HIDReportInData[0] = HID_REPORTID_MouseReport;
    5b10:	81 e0       	ldi	r24, 0x01	; 1
    5b12:	80 93 75 04 	sts	0x0475, r24
    report[0] = (b1 << 2) + (b2 << 1) + b3;
    5b16:	44 0f       	add	r20, r20
    5b18:	42 0f       	add	r20, r18
    5b1a:	66 0f       	add	r22, r22
    5b1c:	66 0f       	add	r22, r22
    5b1e:	46 0f       	add	r20, r22
    5b20:	40 83       	st	Z, r20
    memcpy(HIDReportInData + 1, report, 8);
    5b22:	a6 e7       	ldi	r26, 0x76	; 118
    5b24:	b4 e0       	ldi	r27, 0x04	; 4
    5b26:	88 e0       	ldi	r24, 0x08	; 8
    5b28:	01 90       	ld	r0, Z+
    5b2a:	0d 92       	st	X+, r0
    5b2c:	81 50       	subi	r24, 0x01	; 1
    5b2e:	e1 f7       	brne	.-8      	; 0x5b28 <_ZN8USBMouse11set_buttonsEhhh+0x1a>
    HID_Task();
    5b30:	0c 94 1f 02 	jmp	0x43e	; 0x43e <HID_Task>

00005b34 <_ZN8USBMouse4moveEhhh>:
void HardwareSerial::println(long double val, int format) { }

void USBMouse::move(uint8_t x, uint8_t y) {
    move(x, y, 0);
}
void USBMouse::move(uint8_t x, uint8_t y, uint8_t z) {
    5b34:	fc 01       	movw	r30, r24
    HIDReportInData[0] = HID_REPORTID_MouseReport;
    5b36:	81 e0       	ldi	r24, 0x01	; 1
    5b38:	80 93 75 04 	sts	0x0475, r24
    report[1] = x;
    5b3c:	61 83       	std	Z+1, r22	; 0x01
    report[2] = y;
    5b3e:	42 83       	std	Z+2, r20	; 0x02
    report[3] = z;
    5b40:	23 83       	std	Z+3, r18	; 0x03
    memcpy(HIDReportInData + 1, report, 8);
    5b42:	a6 e7       	ldi	r26, 0x76	; 118
    5b44:	b4 e0       	ldi	r27, 0x04	; 4
    5b46:	88 e0       	ldi	r24, 0x08	; 8
    5b48:	01 90       	ld	r0, Z+
    5b4a:	0d 92       	st	X+, r0
    5b4c:	81 50       	subi	r24, 0x01	; 1
    5b4e:	e1 f7       	brne	.-8      	; 0x5b48 <_ZN8USBMouse4moveEhhh+0x14>
    HID_Task();
    5b50:	0c 94 1f 02 	jmp	0x43e	; 0x43e <HID_Task>

00005b54 <_ZN8USBMouse4moveEhh>:
void HardwareSerial::println(int val, int format) { }
void HardwareSerial::println(long unsigned int val, int format) { }
void HardwareSerial::println(long double val, int format) { }

void USBMouse::move(uint8_t x, uint8_t y) {
    move(x, y, 0);
    5b54:	20 e0       	ldi	r18, 0x00	; 0
}
    5b56:	ee cf       	rjmp	.-36     	; 0x5b34 <_ZN8USBMouse4moveEhhh>

00005b58 <_ZN16USBVirtualSerial7printlnEhh>:
void USBVirtualSerial::println(unsigned int val) { println(val, BYTE); }
void USBVirtualSerial::println(long int val) { println(val, BYTE); }
void USBVirtualSerial::println(long unsigned int val) { println(val, BYTE); }
void USBVirtualSerial::println(double val) { print(val, BYTE); }

void USBVirtualSerial::println(byte val, byte format) {
    5b58:	0f 93       	push	r16
    5b5a:	1f 93       	push	r17
    RingBuffer_Insert(&HostTXSerial_Buffer, val);
    5b5c:	02 e9       	ldi	r16, 0x92	; 146
    5b5e:	15 e0       	ldi	r17, 0x05	; 5
    5b60:	c8 01       	movw	r24, r16
    5b62:	f8 dc       	rcall	.-1552   	; 0x5554 <RingBuffer_Insert>
    RingBuffer_Insert(&HostTXSerial_Buffer, '\r');
    5b64:	c8 01       	movw	r24, r16
    5b66:	6d e0       	ldi	r22, 0x0D	; 13
    5b68:	f5 dc       	rcall	.-1558   	; 0x5554 <RingBuffer_Insert>
    RingBuffer_Insert(&HostTXSerial_Buffer, '\n');
    5b6a:	c8 01       	movw	r24, r16
    5b6c:	6a e0       	ldi	r22, 0x0A	; 10
    5b6e:	f2 dc       	rcall	.-1564   	; 0x5554 <RingBuffer_Insert>
    CDC_Task();
    5b70:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <CDC_Task>
}
    5b74:	1f 91       	pop	r17
    5b76:	0f 91       	pop	r16
    5b78:	08 95       	ret

00005b7a <_ZN16USBVirtualSerial7printlnEh>:
void USBVirtualSerial::print(unsigned int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long int val, byte format) { print(ltoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long unsigned int val, byte format) { print(ultoa(val, numStr, DEC)); }
void USBVirtualSerial::print(double val, byte format) { print(ultoa(val, numStr, DEC)); }

void USBVirtualSerial::println(byte val) { println(val, BYTE); }
    5b7a:	40 e0       	ldi	r20, 0x00	; 0
    5b7c:	ed cf       	rjmp	.-38     	; 0x5b58 <_ZN16USBVirtualSerial7printlnEhh>

00005b7e <_ZN16USBVirtualSerial5printEhh>:
void USBVirtualSerial::print(long int val) { print(val, BYTE); }
void USBVirtualSerial::print(long unsigned int val) { print(val, BYTE); }
void USBVirtualSerial::print(double val) { print(val, BYTE); }

void USBVirtualSerial::print(byte val, byte format) {
    RingBuffer_Insert(&HostTXSerial_Buffer, val);
    5b7e:	82 e9       	ldi	r24, 0x92	; 146
    5b80:	95 e0       	ldi	r25, 0x05	; 5
    5b82:	e8 dc       	rcall	.-1584   	; 0x5554 <RingBuffer_Insert>
    CDC_Task();
    5b84:	0c 94 5a 02 	jmp	0x4b4	; 0x4b4 <CDC_Task>

00005b88 <_ZN16USBVirtualSerial5printEh>:
    RingBuffer_Insert(&HostTXSerial_Buffer, '\r');
    RingBuffer_Insert(&HostTXSerial_Buffer, '\n');
    CDC_Task();
}

void USBVirtualSerial::print(byte val) { print(val, BYTE); }
    5b88:	40 e0       	ldi	r20, 0x00	; 0
    5b8a:	f9 cf       	rjmp	.-14     	; 0x5b7e <_ZN16USBVirtualSerial5printEhh>

00005b8c <_ZN16USBVirtualSerial7printlnEPKc>:

void USBVirtualSerial::print(const char *str) {
    for (unsigned int i = 0; i < strlen(str); i++) RingBuffer_Insert(&HostTXSerial_Buffer, str[i]);
    CDC_Task();
}
void USBVirtualSerial::println(const char *str) {
    5b8c:	0f 93       	push	r16
    5b8e:	1f 93       	push	r17
    5b90:	cf 93       	push	r28
    5b92:	df 93       	push	r29
    5b94:	8b 01       	movw	r16, r22
    5b96:	c0 e0       	ldi	r28, 0x00	; 0
    5b98:	d0 e0       	ldi	r29, 0x00	; 0
    5b9a:	08 c0       	rjmp	.+16     	; 0x5bac <_ZN16USBVirtualSerial7printlnEPKc+0x20>
    for (unsigned int i = 0; i < strlen(str); i++) RingBuffer_Insert(&HostTXSerial_Buffer, str[i]);
    5b9c:	f8 01       	movw	r30, r16
    5b9e:	ec 0f       	add	r30, r28
    5ba0:	fd 1f       	adc	r31, r29
    5ba2:	82 e9       	ldi	r24, 0x92	; 146
    5ba4:	95 e0       	ldi	r25, 0x05	; 5
    5ba6:	60 81       	ld	r22, Z
    5ba8:	d5 dc       	rcall	.-1622   	; 0x5554 <RingBuffer_Insert>
    5baa:	21 96       	adiw	r28, 0x01	; 1
    5bac:	f8 01       	movw	r30, r16
    5bae:	01 90       	ld	r0, Z+
    5bb0:	00 20       	and	r0, r0
    5bb2:	e9 f7       	brne	.-6      	; 0x5bae <_ZN16USBVirtualSerial7printlnEPKc+0x22>
    5bb4:	31 97       	sbiw	r30, 0x01	; 1
    5bb6:	e0 1b       	sub	r30, r16
    5bb8:	f1 0b       	sbc	r31, r17
    5bba:	ce 17       	cp	r28, r30
    5bbc:	df 07       	cpc	r29, r31
    5bbe:	70 f3       	brcs	.-36     	; 0x5b9c <_ZN16USBVirtualSerial7printlnEPKc+0x10>
    RingBuffer_Insert(&HostTXSerial_Buffer, '\r');
    5bc0:	82 e9       	ldi	r24, 0x92	; 146
    5bc2:	95 e0       	ldi	r25, 0x05	; 5
    5bc4:	6d e0       	ldi	r22, 0x0D	; 13
    5bc6:	c6 dc       	rcall	.-1652   	; 0x5554 <RingBuffer_Insert>
    RingBuffer_Insert(&HostTXSerial_Buffer, '\n');
    5bc8:	82 e9       	ldi	r24, 0x92	; 146
    5bca:	95 e0       	ldi	r25, 0x05	; 5
    5bcc:	6a e0       	ldi	r22, 0x0A	; 10
    5bce:	c2 dc       	rcall	.-1660   	; 0x5554 <RingBuffer_Insert>
    CDC_Task();
    5bd0:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <CDC_Task>
}
    5bd4:	df 91       	pop	r29
    5bd6:	cf 91       	pop	r28
    5bd8:	1f 91       	pop	r17
    5bda:	0f 91       	pop	r16
    5bdc:	08 95       	ret

00005bde <_ZN16USBVirtualSerial7printlnEdh>:
}
void USBVirtualSerial::println(int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(unsigned int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(long int val, byte format) { println(ltoa(val, numStr, DEC)); }
void USBVirtualSerial::println(long unsigned int val, byte format) { println(ultoa(val, numStr, DEC)); }
void USBVirtualSerial::println(double val, byte format) { println(ultoa(val, numStr, DEC)); }
    5bde:	0f 93       	push	r16
    5be0:	1f 93       	push	r17
    5be2:	8c 01       	movw	r16, r24
    5be4:	cb 01       	movw	r24, r22
    5be6:	ba 01       	movw	r22, r20
    5be8:	0e 94 8d 40 	call	0x811a	; 0x811a <__fixunssfsi>
    5bec:	a8 01       	movw	r20, r16
    5bee:	2a e0       	ldi	r18, 0x0A	; 10
    5bf0:	30 e0       	ldi	r19, 0x00	; 0
    5bf2:	0e 94 35 44 	call	0x886a	; 0x886a <ultoa>
    5bf6:	bc 01       	movw	r22, r24
    5bf8:	c8 01       	movw	r24, r16
    5bfa:	c8 df       	rcall	.-112    	; 0x5b8c <_ZN16USBVirtualSerial7printlnEPKc>
    5bfc:	1f 91       	pop	r17
    5bfe:	0f 91       	pop	r16
    5c00:	08 95       	ret

00005c02 <_ZN16USBVirtualSerial7printlnEmh>:
    CDC_Task();
}
void USBVirtualSerial::println(int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(unsigned int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(long int val, byte format) { println(ltoa(val, numStr, DEC)); }
void USBVirtualSerial::println(long unsigned int val, byte format) { println(ultoa(val, numStr, DEC)); }
    5c02:	0f 93       	push	r16
    5c04:	1f 93       	push	r17
    5c06:	8c 01       	movw	r16, r24
    5c08:	cb 01       	movw	r24, r22
    5c0a:	ba 01       	movw	r22, r20
    5c0c:	a8 01       	movw	r20, r16
    5c0e:	2a e0       	ldi	r18, 0x0A	; 10
    5c10:	30 e0       	ldi	r19, 0x00	; 0
    5c12:	0e 94 35 44 	call	0x886a	; 0x886a <ultoa>
    5c16:	bc 01       	movw	r22, r24
    5c18:	c8 01       	movw	r24, r16
    5c1a:	b8 df       	rcall	.-144    	; 0x5b8c <_ZN16USBVirtualSerial7printlnEPKc>
    5c1c:	1f 91       	pop	r17
    5c1e:	0f 91       	pop	r16
    5c20:	08 95       	ret

00005c22 <_ZN16USBVirtualSerial7printlnEm>:

void USBVirtualSerial::println(byte val) { println(val, BYTE); }
void USBVirtualSerial::println(int val) { println(val, BYTE); }
void USBVirtualSerial::println(unsigned int val) { println(val, BYTE); }
void USBVirtualSerial::println(long int val) { println(val, BYTE); }
void USBVirtualSerial::println(long unsigned int val) { println(val, BYTE); }
    5c22:	20 e0       	ldi	r18, 0x00	; 0
    5c24:	ee cf       	rjmp	.-36     	; 0x5c02 <_ZN16USBVirtualSerial7printlnEmh>

00005c26 <_ZN16USBVirtualSerial7printlnElh>:
    RingBuffer_Insert(&HostTXSerial_Buffer, '\n');
    CDC_Task();
}
void USBVirtualSerial::println(int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(unsigned int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(long int val, byte format) { println(ltoa(val, numStr, DEC)); }
    5c26:	0f 93       	push	r16
    5c28:	1f 93       	push	r17
    5c2a:	8c 01       	movw	r16, r24
    5c2c:	cb 01       	movw	r24, r22
    5c2e:	ba 01       	movw	r22, r20
    5c30:	a8 01       	movw	r20, r16
    5c32:	2a e0       	ldi	r18, 0x0A	; 10
    5c34:	30 e0       	ldi	r19, 0x00	; 0
    5c36:	0e 94 03 44 	call	0x8806	; 0x8806 <ltoa>
    5c3a:	bc 01       	movw	r22, r24
    5c3c:	c8 01       	movw	r24, r16
    5c3e:	a6 df       	rcall	.-180    	; 0x5b8c <_ZN16USBVirtualSerial7printlnEPKc>
    5c40:	1f 91       	pop	r17
    5c42:	0f 91       	pop	r16
    5c44:	08 95       	ret

00005c46 <_ZN16USBVirtualSerial7printlnEl>:
void USBVirtualSerial::print(double val, byte format) { print(ultoa(val, numStr, DEC)); }

void USBVirtualSerial::println(byte val) { println(val, BYTE); }
void USBVirtualSerial::println(int val) { println(val, BYTE); }
void USBVirtualSerial::println(unsigned int val) { println(val, BYTE); }
void USBVirtualSerial::println(long int val) { println(val, BYTE); }
    5c46:	20 e0       	ldi	r18, 0x00	; 0
    5c48:	ee cf       	rjmp	.-36     	; 0x5c26 <_ZN16USBVirtualSerial7printlnElh>

00005c4a <_ZN16USBVirtualSerial7printlnEjh>:
    RingBuffer_Insert(&HostTXSerial_Buffer, '\r');
    RingBuffer_Insert(&HostTXSerial_Buffer, '\n');
    CDC_Task();
}
void USBVirtualSerial::println(int val, byte format) { println(itoa(val, numStr, DEC)); }
void USBVirtualSerial::println(unsigned int val, byte format) { println(itoa(val, numStr, DEC)); }
    5c4a:	0f 93       	push	r16
    5c4c:	1f 93       	push	r17
    5c4e:	8c 01       	movw	r16, r24
    5c50:	cb 01       	movw	r24, r22
    5c52:	b8 01       	movw	r22, r16
    5c54:	4a e0       	ldi	r20, 0x0A	; 10
    5c56:	50 e0       	ldi	r21, 0x00	; 0
    5c58:	0e 94 e4 43 	call	0x87c8	; 0x87c8 <itoa>
    5c5c:	bc 01       	movw	r22, r24
    5c5e:	c8 01       	movw	r24, r16
    5c60:	95 df       	rcall	.-214    	; 0x5b8c <_ZN16USBVirtualSerial7printlnEPKc>
    5c62:	1f 91       	pop	r17
    5c64:	0f 91       	pop	r16
    5c66:	08 95       	ret

00005c68 <_ZN16USBVirtualSerial7printlnEj>:
void USBVirtualSerial::print(long unsigned int val, byte format) { print(ultoa(val, numStr, DEC)); }
void USBVirtualSerial::print(double val, byte format) { print(ultoa(val, numStr, DEC)); }

void USBVirtualSerial::println(byte val) { println(val, BYTE); }
void USBVirtualSerial::println(int val) { println(val, BYTE); }
void USBVirtualSerial::println(unsigned int val) { println(val, BYTE); }
    5c68:	40 e0       	ldi	r20, 0x00	; 0
    5c6a:	ef cf       	rjmp	.-34     	; 0x5c4a <_ZN16USBVirtualSerial7printlnEjh>

00005c6c <_ZN16USBVirtualSerial7printlnEih>:
    RingBuffer_Insert(&HostTXSerial_Buffer, val);
    RingBuffer_Insert(&HostTXSerial_Buffer, '\r');
    RingBuffer_Insert(&HostTXSerial_Buffer, '\n');
    CDC_Task();
}
void USBVirtualSerial::println(int val, byte format) { println(itoa(val, numStr, DEC)); }
    5c6c:	0f 93       	push	r16
    5c6e:	1f 93       	push	r17
    5c70:	8c 01       	movw	r16, r24
    5c72:	cb 01       	movw	r24, r22
    5c74:	b8 01       	movw	r22, r16
    5c76:	4a e0       	ldi	r20, 0x0A	; 10
    5c78:	50 e0       	ldi	r21, 0x00	; 0
    5c7a:	0e 94 e4 43 	call	0x87c8	; 0x87c8 <itoa>
    5c7e:	bc 01       	movw	r22, r24
    5c80:	c8 01       	movw	r24, r16
    5c82:	84 df       	rcall	.-248    	; 0x5b8c <_ZN16USBVirtualSerial7printlnEPKc>
    5c84:	1f 91       	pop	r17
    5c86:	0f 91       	pop	r16
    5c88:	08 95       	ret

00005c8a <_ZN16USBVirtualSerial7printlnEi>:
void USBVirtualSerial::print(long int val, byte format) { print(ltoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long unsigned int val, byte format) { print(ultoa(val, numStr, DEC)); }
void USBVirtualSerial::print(double val, byte format) { print(ultoa(val, numStr, DEC)); }

void USBVirtualSerial::println(byte val) { println(val, BYTE); }
void USBVirtualSerial::println(int val) { println(val, BYTE); }
    5c8a:	40 e0       	ldi	r20, 0x00	; 0
    5c8c:	ef cf       	rjmp	.-34     	; 0x5c6c <_ZN16USBVirtualSerial7printlnEih>

00005c8e <_ZN16USBVirtualSerial5printEPKc>:
    #include "Keyglove.h"
}

void USBVirtualSerial::begin(uint32_t baud) { /* no baud setting for virtual serial */ }

void USBVirtualSerial::print(const char *str) {
    5c8e:	0f 93       	push	r16
    5c90:	1f 93       	push	r17
    5c92:	cf 93       	push	r28
    5c94:	df 93       	push	r29
    5c96:	8b 01       	movw	r16, r22
    5c98:	c0 e0       	ldi	r28, 0x00	; 0
    5c9a:	d0 e0       	ldi	r29, 0x00	; 0
    5c9c:	08 c0       	rjmp	.+16     	; 0x5cae <_ZN16USBVirtualSerial5printEPKc+0x20>
    for (unsigned int i = 0; i < strlen(str); i++) RingBuffer_Insert(&HostTXSerial_Buffer, str[i]);
    5c9e:	f8 01       	movw	r30, r16
    5ca0:	ec 0f       	add	r30, r28
    5ca2:	fd 1f       	adc	r31, r29
    5ca4:	82 e9       	ldi	r24, 0x92	; 146
    5ca6:	95 e0       	ldi	r25, 0x05	; 5
    5ca8:	60 81       	ld	r22, Z
    5caa:	54 dc       	rcall	.-1880   	; 0x5554 <RingBuffer_Insert>
    5cac:	21 96       	adiw	r28, 0x01	; 1
    5cae:	f8 01       	movw	r30, r16
    5cb0:	01 90       	ld	r0, Z+
    5cb2:	00 20       	and	r0, r0
    5cb4:	e9 f7       	brne	.-6      	; 0x5cb0 <_ZN16USBVirtualSerial5printEPKc+0x22>
    5cb6:	31 97       	sbiw	r30, 0x01	; 1
    5cb8:	e0 1b       	sub	r30, r16
    5cba:	f1 0b       	sbc	r31, r17
    5cbc:	ce 17       	cp	r28, r30
    5cbe:	df 07       	cpc	r29, r31
    5cc0:	70 f3       	brcs	.-36     	; 0x5c9e <_ZN16USBVirtualSerial5printEPKc+0x10>
    CDC_Task();
    5cc2:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <CDC_Task>
}
    5cc6:	df 91       	pop	r29
    5cc8:	cf 91       	pop	r28
    5cca:	1f 91       	pop	r17
    5ccc:	0f 91       	pop	r16
    5cce:	08 95       	ret

00005cd0 <_ZN16USBVirtualSerial5printEdh>:
}
void USBVirtualSerial::print(int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(unsigned int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long int val, byte format) { print(ltoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long unsigned int val, byte format) { print(ultoa(val, numStr, DEC)); }
void USBVirtualSerial::print(double val, byte format) { print(ultoa(val, numStr, DEC)); }
    5cd0:	0f 93       	push	r16
    5cd2:	1f 93       	push	r17
    5cd4:	8c 01       	movw	r16, r24
    5cd6:	cb 01       	movw	r24, r22
    5cd8:	ba 01       	movw	r22, r20
    5cda:	0e 94 8d 40 	call	0x811a	; 0x811a <__fixunssfsi>
    5cde:	a8 01       	movw	r20, r16
    5ce0:	2a e0       	ldi	r18, 0x0A	; 10
    5ce2:	30 e0       	ldi	r19, 0x00	; 0
    5ce4:	0e 94 35 44 	call	0x886a	; 0x886a <ultoa>
    5ce8:	bc 01       	movw	r22, r24
    5cea:	c8 01       	movw	r24, r16
    5cec:	d0 df       	rcall	.-96     	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    5cee:	1f 91       	pop	r17
    5cf0:	0f 91       	pop	r16
    5cf2:	08 95       	ret

00005cf4 <_ZN16USBVirtualSerial7printlnEd>:
void USBVirtualSerial::println(byte val) { println(val, BYTE); }
void USBVirtualSerial::println(int val) { println(val, BYTE); }
void USBVirtualSerial::println(unsigned int val) { println(val, BYTE); }
void USBVirtualSerial::println(long int val) { println(val, BYTE); }
void USBVirtualSerial::println(long unsigned int val) { println(val, BYTE); }
void USBVirtualSerial::println(double val) { print(val, BYTE); }
    5cf4:	20 e0       	ldi	r18, 0x00	; 0
    5cf6:	ec cf       	rjmp	.-40     	; 0x5cd0 <_ZN16USBVirtualSerial5printEdh>

00005cf8 <_ZN16USBVirtualSerial5printEd>:
void USBVirtualSerial::print(byte val) { print(val, BYTE); }
void USBVirtualSerial::print(int val) { print(val, BYTE); }
void USBVirtualSerial::print(unsigned int val) { print(val, BYTE); }
void USBVirtualSerial::print(long int val) { print(val, BYTE); }
void USBVirtualSerial::print(long unsigned int val) { print(val, BYTE); }
void USBVirtualSerial::print(double val) { print(val, BYTE); }
    5cf8:	20 e0       	ldi	r18, 0x00	; 0
    5cfa:	ea cf       	rjmp	.-44     	; 0x5cd0 <_ZN16USBVirtualSerial5printEdh>

00005cfc <_ZN16USBVirtualSerial5printEmh>:
    CDC_Task();
}
void USBVirtualSerial::print(int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(unsigned int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long int val, byte format) { print(ltoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long unsigned int val, byte format) { print(ultoa(val, numStr, DEC)); }
    5cfc:	0f 93       	push	r16
    5cfe:	1f 93       	push	r17
    5d00:	8c 01       	movw	r16, r24
    5d02:	cb 01       	movw	r24, r22
    5d04:	ba 01       	movw	r22, r20
    5d06:	a8 01       	movw	r20, r16
    5d08:	2a e0       	ldi	r18, 0x0A	; 10
    5d0a:	30 e0       	ldi	r19, 0x00	; 0
    5d0c:	0e 94 35 44 	call	0x886a	; 0x886a <ultoa>
    5d10:	bc 01       	movw	r22, r24
    5d12:	c8 01       	movw	r24, r16
    5d14:	bc df       	rcall	.-136    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    5d16:	1f 91       	pop	r17
    5d18:	0f 91       	pop	r16
    5d1a:	08 95       	ret

00005d1c <_ZN16USBVirtualSerial5printEm>:

void USBVirtualSerial::print(byte val) { print(val, BYTE); }
void USBVirtualSerial::print(int val) { print(val, BYTE); }
void USBVirtualSerial::print(unsigned int val) { print(val, BYTE); }
void USBVirtualSerial::print(long int val) { print(val, BYTE); }
void USBVirtualSerial::print(long unsigned int val) { print(val, BYTE); }
    5d1c:	20 e0       	ldi	r18, 0x00	; 0
    5d1e:	ee cf       	rjmp	.-36     	; 0x5cfc <_ZN16USBVirtualSerial5printEmh>

00005d20 <_ZN16USBVirtualSerial5printElh>:
    RingBuffer_Insert(&HostTXSerial_Buffer, val);
    CDC_Task();
}
void USBVirtualSerial::print(int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(unsigned int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(long int val, byte format) { print(ltoa(val, numStr, DEC)); }
    5d20:	0f 93       	push	r16
    5d22:	1f 93       	push	r17
    5d24:	8c 01       	movw	r16, r24
    5d26:	cb 01       	movw	r24, r22
    5d28:	ba 01       	movw	r22, r20
    5d2a:	a8 01       	movw	r20, r16
    5d2c:	2a e0       	ldi	r18, 0x0A	; 10
    5d2e:	30 e0       	ldi	r19, 0x00	; 0
    5d30:	0e 94 03 44 	call	0x8806	; 0x8806 <ltoa>
    5d34:	bc 01       	movw	r22, r24
    5d36:	c8 01       	movw	r24, r16
    5d38:	aa df       	rcall	.-172    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    5d3a:	1f 91       	pop	r17
    5d3c:	0f 91       	pop	r16
    5d3e:	08 95       	ret

00005d40 <_ZN16USBVirtualSerial5printEl>:
}

void USBVirtualSerial::print(byte val) { print(val, BYTE); }
void USBVirtualSerial::print(int val) { print(val, BYTE); }
void USBVirtualSerial::print(unsigned int val) { print(val, BYTE); }
void USBVirtualSerial::print(long int val) { print(val, BYTE); }
    5d40:	20 e0       	ldi	r18, 0x00	; 0
    5d42:	ee cf       	rjmp	.-36     	; 0x5d20 <_ZN16USBVirtualSerial5printElh>

00005d44 <_ZN16USBVirtualSerial5printEjh>:
void USBVirtualSerial::print(byte val, byte format) {
    RingBuffer_Insert(&HostTXSerial_Buffer, val);
    CDC_Task();
}
void USBVirtualSerial::print(int val, byte format) { print(itoa(val, numStr, DEC)); }
void USBVirtualSerial::print(unsigned int val, byte format) { print(itoa(val, numStr, DEC)); }
    5d44:	0f 93       	push	r16
    5d46:	1f 93       	push	r17
    5d48:	8c 01       	movw	r16, r24
    5d4a:	cb 01       	movw	r24, r22
    5d4c:	b8 01       	movw	r22, r16
    5d4e:	4a e0       	ldi	r20, 0x0A	; 10
    5d50:	50 e0       	ldi	r21, 0x00	; 0
    5d52:	0e 94 e4 43 	call	0x87c8	; 0x87c8 <itoa>
    5d56:	bc 01       	movw	r22, r24
    5d58:	c8 01       	movw	r24, r16
    5d5a:	99 df       	rcall	.-206    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    5d5c:	1f 91       	pop	r17
    5d5e:	0f 91       	pop	r16
    5d60:	08 95       	ret

00005d62 <_ZN16USBVirtualSerial5printEj>:
    CDC_Task();
}

void USBVirtualSerial::print(byte val) { print(val, BYTE); }
void USBVirtualSerial::print(int val) { print(val, BYTE); }
void USBVirtualSerial::print(unsigned int val) { print(val, BYTE); }
    5d62:	40 e0       	ldi	r20, 0x00	; 0
    5d64:	ef cf       	rjmp	.-34     	; 0x5d44 <_ZN16USBVirtualSerial5printEjh>

00005d66 <_ZN16USBVirtualSerial5printEih>:

void USBVirtualSerial::print(byte val, byte format) {
    RingBuffer_Insert(&HostTXSerial_Buffer, val);
    CDC_Task();
}
void USBVirtualSerial::print(int val, byte format) { print(itoa(val, numStr, DEC)); }
    5d66:	0f 93       	push	r16
    5d68:	1f 93       	push	r17
    5d6a:	8c 01       	movw	r16, r24
    5d6c:	cb 01       	movw	r24, r22
    5d6e:	b8 01       	movw	r22, r16
    5d70:	4a e0       	ldi	r20, 0x0A	; 10
    5d72:	50 e0       	ldi	r21, 0x00	; 0
    5d74:	0e 94 e4 43 	call	0x87c8	; 0x87c8 <itoa>
    5d78:	bc 01       	movw	r22, r24
    5d7a:	c8 01       	movw	r24, r16
    5d7c:	88 df       	rcall	.-240    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    5d7e:	1f 91       	pop	r17
    5d80:	0f 91       	pop	r16
    5d82:	08 95       	ret

00005d84 <_ZN16USBVirtualSerial5printEi>:
    RingBuffer_Insert(&HostTXSerial_Buffer, '\n');
    CDC_Task();
}

void USBVirtualSerial::print(byte val) { print(val, BYTE); }
void USBVirtualSerial::print(int val) { print(val, BYTE); }
    5d84:	40 e0       	ldi	r20, 0x00	; 0
    5d86:	ef cf       	rjmp	.-34     	; 0x5d66 <_ZN16USBVirtualSerial5printEih>

00005d88 <_ZN13AccelerometerC2Ev>:
#define DEVICE (0x53)    // ADXL345 device address
#define TO_READ (6)      // num of bytes we are going to read each time (two bytes for each axis)

Accelerometer::Accelerometer() {

}
    5d88:	08 95       	ret

00005d8a <_ZN13AccelerometerC1Ev>:
    5d8a:	08 95       	ret

00005d8c <_ZN13Accelerometer7writeToEihh>:
  *y = (((int)_buff[3]) << 8) | _buff[2];
  *z = (((int)_buff[5]) << 8) | _buff[4];
}

// Writes val to address register on device
void Accelerometer::writeTo(int device, byte address, byte val) {
    5d8c:	ef 92       	push	r14
    5d8e:	ff 92       	push	r15
    5d90:	0f 93       	push	r16
    5d92:	1f 93       	push	r17
    5d94:	f4 2e       	mov	r15, r20
    5d96:	e2 2e       	mov	r14, r18
  Wire.beginTransmission(device); // start transmission to device 
    5d98:	00 e2       	ldi	r16, 0x20	; 32
    5d9a:	19 e0       	ldi	r17, 0x09	; 9
    5d9c:	c8 01       	movw	r24, r16
    5d9e:	25 dc       	rcall	.-1974   	; 0x55ea <_ZN7WireI2C17beginTransmissionEi>
  Wire.send(address);             // send register address
    5da0:	c8 01       	movw	r24, r16
    5da2:	6f 2d       	mov	r22, r15
    5da4:	24 dc       	rcall	.-1976   	; 0x55ee <_ZN7WireI2C4sendEh>
  Wire.send(val);                 // send value to write
    5da6:	c8 01       	movw	r24, r16
    5da8:	6e 2d       	mov	r22, r14
    5daa:	21 dc       	rcall	.-1982   	; 0x55ee <_ZN7WireI2C4sendEh>
  Wire.endTransmission();         // end transmission
    5dac:	c8 01       	movw	r24, r16
    5dae:	1e dc       	rcall	.-1988   	; 0x55ec <_ZN7WireI2C15endTransmissionEv>
}
    5db0:	1f 91       	pop	r17
    5db2:	0f 91       	pop	r16
    5db4:	ff 90       	pop	r15
    5db6:	ef 90       	pop	r14
    5db8:	08 95       	ret

00005dba <_ZN13Accelerometer19setFreeFallDurationEi>:
// Sets the TIME_FF register, which holds an unsigned time value representing the minimum
// time that the RSS value of all axes must be less than THRESH_FF to generate a free-fall 
// interrupt. The scale factor is 5ms/LSB. A value of 0 may result in undesirable behavior if
// the free-fall interrupt is enabled. The maximum value is 255.
void Accelerometer::setFreeFallDuration(int freeFallDuration) {
  freeFallDuration = min(max(freeFallDuration,0),255);  
    5dba:	6f 3f       	cpi	r22, 0xFF	; 255
    5dbc:	71 05       	cpc	r23, r1
    5dbe:	1c f0       	brlt	.+6      	; 0x5dc6 <_ZN13Accelerometer19setFreeFallDurationEi+0xc>
    5dc0:	2f ef       	ldi	r18, 0xFF	; 255
    5dc2:	30 e0       	ldi	r19, 0x00	; 0
    5dc4:	05 c0       	rjmp	.+10     	; 0x5dd0 <_ZN13Accelerometer19setFreeFallDurationEi+0x16>
    5dc6:	9b 01       	movw	r18, r22
    5dc8:	77 ff       	sbrs	r23, 7
    5dca:	02 c0       	rjmp	.+4      	; 0x5dd0 <_ZN13Accelerometer19setFreeFallDurationEi+0x16>
    5dcc:	20 e0       	ldi	r18, 0x00	; 0
    5dce:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (freeFallDuration);
  writeTo(DEVICE, ADXL345_TIME_FF, _b);  
    5dd0:	63 e5       	ldi	r22, 0x53	; 83
    5dd2:	70 e0       	ldi	r23, 0x00	; 0
    5dd4:	49 e2       	ldi	r20, 0x29	; 41
}
    5dd6:	da cf       	rjmp	.-76     	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005dd8 <_ZN13Accelerometer20setFreeFallThresholdEi>:
// free-fall detection. The root-sum-square (RSS) value of all axes is calculated and
// compared whith the value in THRESH_FF to determine if a free-fall event occured. The 
// scale factor is 62.5mg/LSB. A value of 0 may result in undesirable behavior if the free-fall
// interrupt is enabled. The maximum value is 255.
void Accelerometer::setFreeFallThreshold(int freeFallThreshold) {
  freeFallThreshold = min(max(freeFallThreshold,0),255);
    5dd8:	6f 3f       	cpi	r22, 0xFF	; 255
    5dda:	71 05       	cpc	r23, r1
    5ddc:	1c f0       	brlt	.+6      	; 0x5de4 <_ZN13Accelerometer20setFreeFallThresholdEi+0xc>
    5dde:	2f ef       	ldi	r18, 0xFF	; 255
    5de0:	30 e0       	ldi	r19, 0x00	; 0
    5de2:	05 c0       	rjmp	.+10     	; 0x5dee <_ZN13Accelerometer20setFreeFallThresholdEi+0x16>
    5de4:	9b 01       	movw	r18, r22
    5de6:	77 ff       	sbrs	r23, 7
    5de8:	02 c0       	rjmp	.+4      	; 0x5dee <_ZN13Accelerometer20setFreeFallThresholdEi+0x16>
    5dea:	20 e0       	ldi	r18, 0x00	; 0
    5dec:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (freeFallThreshold);
  writeTo(DEVICE, ADXL345_THRESH_FF, _b);  
    5dee:	63 e5       	ldi	r22, 0x53	; 83
    5df0:	70 e0       	ldi	r23, 0x00	; 0
    5df2:	48 e2       	ldi	r20, 0x28	; 40
}
    5df4:	cb cf       	rjmp	.-106    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005df6 <_ZN13Accelerometer17setTimeInactivityEi>:
// Sets the TIME_INACT register, which contains an unsigned time value representing the
// amount of time that acceleration must be less thant the value in the THRESH_INACT
// register for inactivity to be declared. The scale factor is 1sec/LSB. The value must
// be between 0 and 255.
void Accelerometer::setTimeInactivity(int timeInactivity) {
  timeInactivity = min(max(timeInactivity,0),255);
    5df6:	6f 3f       	cpi	r22, 0xFF	; 255
    5df8:	71 05       	cpc	r23, r1
    5dfa:	1c f0       	brlt	.+6      	; 0x5e02 <_ZN13Accelerometer17setTimeInactivityEi+0xc>
    5dfc:	2f ef       	ldi	r18, 0xFF	; 255
    5dfe:	30 e0       	ldi	r19, 0x00	; 0
    5e00:	05 c0       	rjmp	.+10     	; 0x5e0c <_ZN13Accelerometer17setTimeInactivityEi+0x16>
    5e02:	9b 01       	movw	r18, r22
    5e04:	77 ff       	sbrs	r23, 7
    5e06:	02 c0       	rjmp	.+4      	; 0x5e0c <_ZN13Accelerometer17setTimeInactivityEi+0x16>
    5e08:	20 e0       	ldi	r18, 0x00	; 0
    5e0a:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (timeInactivity);
  writeTo(DEVICE, ADXL345_TIME_INACT, _b);  
    5e0c:	63 e5       	ldi	r22, 0x53	; 83
    5e0e:	70 e0       	ldi	r23, 0x00	; 0
    5e10:	46 e2       	ldi	r20, 0x26	; 38
}
    5e12:	bc cf       	rjmp	.-136    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005e14 <_ZN13Accelerometer22setInactivityThresholdEi>:
// The data format is unsigned, so the magnitude of the inactivity event is compared 
// with the value is compared with the value in the THRESH_INACT register. The scale
// factor is 62.5mg/LSB. A value of 0 may result in undesirable behavior if the 
// inactivity interrupt is enabled. The maximum value is 255.
void Accelerometer::setInactivityThreshold(int inactivityThreshold) {
  inactivityThreshold = min(max(inactivityThreshold,0),255);
    5e14:	6f 3f       	cpi	r22, 0xFF	; 255
    5e16:	71 05       	cpc	r23, r1
    5e18:	1c f0       	brlt	.+6      	; 0x5e20 <_ZN13Accelerometer22setInactivityThresholdEi+0xc>
    5e1a:	2f ef       	ldi	r18, 0xFF	; 255
    5e1c:	30 e0       	ldi	r19, 0x00	; 0
    5e1e:	05 c0       	rjmp	.+10     	; 0x5e2a <_ZN13Accelerometer22setInactivityThresholdEi+0x16>
    5e20:	9b 01       	movw	r18, r22
    5e22:	77 ff       	sbrs	r23, 7
    5e24:	02 c0       	rjmp	.+4      	; 0x5e2a <_ZN13Accelerometer22setInactivityThresholdEi+0x16>
    5e26:	20 e0       	ldi	r18, 0x00	; 0
    5e28:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (inactivityThreshold);
  writeTo(DEVICE, ADXL345_THRESH_INACT, _b);  
    5e2a:	63 e5       	ldi	r22, 0x53	; 83
    5e2c:	70 e0       	ldi	r23, 0x00	; 0
    5e2e:	45 e2       	ldi	r20, 0x25	; 37
}
    5e30:	ad cf       	rjmp	.-166    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005e32 <_ZN13Accelerometer20setActivityThresholdEi>:
// The data format is unsigned, so the magnitude of the activity event is compared 
// with the value is compared with the value in the THRESH_ACT register. The scale
// factor is 62.5mg/LSB. A value of 0 may result in undesirable behavior if the 
// activity interrupt is enabled. The maximum value is 255.
void Accelerometer::setActivityThreshold(int activityThreshold) {
  activityThreshold = min(max(activityThreshold,0),255);
    5e32:	6f 3f       	cpi	r22, 0xFF	; 255
    5e34:	71 05       	cpc	r23, r1
    5e36:	1c f0       	brlt	.+6      	; 0x5e3e <_ZN13Accelerometer20setActivityThresholdEi+0xc>
    5e38:	2f ef       	ldi	r18, 0xFF	; 255
    5e3a:	30 e0       	ldi	r19, 0x00	; 0
    5e3c:	05 c0       	rjmp	.+10     	; 0x5e48 <_ZN13Accelerometer20setActivityThresholdEi+0x16>
    5e3e:	9b 01       	movw	r18, r22
    5e40:	77 ff       	sbrs	r23, 7
    5e42:	02 c0       	rjmp	.+4      	; 0x5e48 <_ZN13Accelerometer20setActivityThresholdEi+0x16>
    5e44:	20 e0       	ldi	r18, 0x00	; 0
    5e46:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (activityThreshold);
  writeTo(DEVICE, ADXL345_THRESH_ACT, _b);  
    5e48:	63 e5       	ldi	r22, 0x53	; 83
    5e4a:	70 e0       	ldi	r23, 0x00	; 0
    5e4c:	44 e2       	ldi	r20, 0x24	; 36
}
    5e4e:	9e cf       	rjmp	.-196    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005e50 <_ZN13Accelerometer18setDoubleTapWindowEi>:
// Sets the Window register, which contains an unsigned time value representing
// the amount of time after the expiration of the latency time (Latent register)
// during which a second valud tap can begin. The scale factor is 1.25ms/LSB. A
// value of 0 disables the double tap function. The maximum value is 255.
void Accelerometer::setDoubleTapWindow(int doubleTapWindow) {
  doubleTapWindow = min(max(doubleTapWindow,0),255);
    5e50:	6f 3f       	cpi	r22, 0xFF	; 255
    5e52:	71 05       	cpc	r23, r1
    5e54:	1c f0       	brlt	.+6      	; 0x5e5c <_ZN13Accelerometer18setDoubleTapWindowEi+0xc>
    5e56:	2f ef       	ldi	r18, 0xFF	; 255
    5e58:	30 e0       	ldi	r19, 0x00	; 0
    5e5a:	05 c0       	rjmp	.+10     	; 0x5e66 <_ZN13Accelerometer18setDoubleTapWindowEi+0x16>
    5e5c:	9b 01       	movw	r18, r22
    5e5e:	77 ff       	sbrs	r23, 7
    5e60:	02 c0       	rjmp	.+4      	; 0x5e66 <_ZN13Accelerometer18setDoubleTapWindowEi+0x16>
    5e62:	20 e0       	ldi	r18, 0x00	; 0
    5e64:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (doubleTapWindow);
  writeTo(DEVICE, ADXL345_WINDOW, _b);  
    5e66:	63 e5       	ldi	r22, 0x53	; 83
    5e68:	70 e0       	ldi	r23, 0x00	; 0
    5e6a:	43 e2       	ldi	r20, 0x23	; 35
}
    5e6c:	8f cf       	rjmp	.-226    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005e6e <_ZN13Accelerometer19setDoubleTapLatencyEi>:
// Sets the latency (latent register) which contains an unsigned time value
// representing the wait time from the detection of a tap event to the start
// of the time window, during which a possible second tap can be detected.
// The scale factor is 1.25ms/LSB. A value of 0 disables the double tap function.
// It accepts a maximum value of 255.
void Accelerometer::setDoubleTapLatency(int doubleTapLatency) {
    5e6e:	26 2f       	mov	r18, r22
  byte _b = byte (doubleTapLatency);
  writeTo(DEVICE, ADXL345_LATENT, _b);  
    5e70:	63 e5       	ldi	r22, 0x53	; 83
    5e72:	70 e0       	ldi	r23, 0x00	; 0
    5e74:	42 e2       	ldi	r20, 0x22	; 34
}
    5e76:	8a cf       	rjmp	.-236    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005e78 <_ZN13Accelerometer14setTapDurationEi>:
// The DUR byte contains an unsigned time value representing the maximum time
// that an event must be above THRESH_TAP threshold to qualify as a tap event
// The scale factor is 625µs/LSB
// A value of 0 disables the tap/double tap funcitons. Max value is 255.
void Accelerometer::setTapDuration(int tapDuration) {
  tapDuration = min(max(tapDuration,0),255);
    5e78:	6f 3f       	cpi	r22, 0xFF	; 255
    5e7a:	71 05       	cpc	r23, r1
    5e7c:	1c f0       	brlt	.+6      	; 0x5e84 <_ZN13Accelerometer14setTapDurationEi+0xc>
    5e7e:	2f ef       	ldi	r18, 0xFF	; 255
    5e80:	30 e0       	ldi	r19, 0x00	; 0
    5e82:	05 c0       	rjmp	.+10     	; 0x5e8e <_ZN13Accelerometer14setTapDurationEi+0x16>
    5e84:	9b 01       	movw	r18, r22
    5e86:	77 ff       	sbrs	r23, 7
    5e88:	02 c0       	rjmp	.+4      	; 0x5e8e <_ZN13Accelerometer14setTapDurationEi+0x16>
    5e8a:	20 e0       	ldi	r18, 0x00	; 0
    5e8c:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (tapDuration);
  writeTo(DEVICE, ADXL345_DUR, _b);  
    5e8e:	63 e5       	ldi	r22, 0x53	; 83
    5e90:	70 e0       	ldi	r23, 0x00	; 0
    5e92:	41 e2       	ldi	r20, 0x21	; 33
}
    5e94:	7b cf       	rjmp	.-266    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005e96 <_ZN13Accelerometer13setAxisOffsetEiii>:

// Sets the OFSX, OFSY and OFSZ bytes
// OFSX, OFSY and OFSZ are user offset adjustments in twos complement format with
// a scale factor of 15,6mg/LSB
// OFSX, OFSY and OFSZ should be comprised between 
void Accelerometer::setAxisOffset(int x, int y, int z) {
    5e96:	ef 92       	push	r14
    5e98:	ff 92       	push	r15
    5e9a:	0f 93       	push	r16
    5e9c:	1f 93       	push	r17
    5e9e:	8c 01       	movw	r16, r24
    5ea0:	36 2f       	mov	r19, r22
    5ea2:	f4 2e       	mov	r15, r20
    5ea4:	e2 2e       	mov	r14, r18
  writeTo(DEVICE, ADXL345_OFSX, byte (x));  
    5ea6:	63 e5       	ldi	r22, 0x53	; 83
    5ea8:	70 e0       	ldi	r23, 0x00	; 0
    5eaa:	4e e1       	ldi	r20, 0x1E	; 30
    5eac:	23 2f       	mov	r18, r19
    5eae:	6e df       	rcall	.-292    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
  writeTo(DEVICE, ADXL345_OFSY, byte (y));  
    5eb0:	c8 01       	movw	r24, r16
    5eb2:	63 e5       	ldi	r22, 0x53	; 83
    5eb4:	70 e0       	ldi	r23, 0x00	; 0
    5eb6:	4f e1       	ldi	r20, 0x1F	; 31
    5eb8:	2f 2d       	mov	r18, r15
    5eba:	68 df       	rcall	.-304    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
  writeTo(DEVICE, ADXL345_OFSZ, byte (z));  
    5ebc:	c8 01       	movw	r24, r16
    5ebe:	63 e5       	ldi	r22, 0x53	; 83
    5ec0:	70 e0       	ldi	r23, 0x00	; 0
    5ec2:	40 e2       	ldi	r20, 0x20	; 32
    5ec4:	2e 2d       	mov	r18, r14
    5ec6:	62 df       	rcall	.-316    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
}
    5ec8:	1f 91       	pop	r17
    5eca:	0f 91       	pop	r16
    5ecc:	ff 90       	pop	r15
    5ece:	ef 90       	pop	r14
    5ed0:	08 95       	ret

00005ed2 <_ZN13Accelerometer15setTapThresholdEi>:
// Sets the THRESH_TAP byte value
// it should be between 0 and 255
// the scale factor is 62.5 mg/LSB
// A value of 0 may result in undesirable behavior
void Accelerometer::setTapThreshold(int tapThreshold) {
  tapThreshold = min(max(tapThreshold,0),255);
    5ed2:	6f 3f       	cpi	r22, 0xFF	; 255
    5ed4:	71 05       	cpc	r23, r1
    5ed6:	1c f0       	brlt	.+6      	; 0x5ede <_ZN13Accelerometer15setTapThresholdEi+0xc>
    5ed8:	2f ef       	ldi	r18, 0xFF	; 255
    5eda:	30 e0       	ldi	r19, 0x00	; 0
    5edc:	05 c0       	rjmp	.+10     	; 0x5ee8 <_ZN13Accelerometer15setTapThresholdEi+0x16>
    5ede:	9b 01       	movw	r18, r22
    5ee0:	77 ff       	sbrs	r23, 7
    5ee2:	02 c0       	rjmp	.+4      	; 0x5ee8 <_ZN13Accelerometer15setTapThresholdEi+0x16>
    5ee4:	20 e0       	ldi	r18, 0x00	; 0
    5ee6:	30 e0       	ldi	r19, 0x00	; 0
  byte _b = byte (tapThreshold);
  writeTo(DEVICE, ADXL345_THRESH_TAP, _b);  
    5ee8:	63 e5       	ldi	r22, 0x53	; 83
    5eea:	70 e0       	ldi	r23, 0x00	; 0
    5eec:	4d e1       	ldi	r20, 0x1D	; 29
}
    5eee:	4e cf       	rjmp	.-356    	; 0x5d8c <_ZN13Accelerometer7writeToEihh>

00005ef0 <_ZN13Accelerometer8readFromEihiPh>:
  Wire.send(val);                 // send value to write
  Wire.endTransmission();         // end transmission
}

// Reads num bytes starting from address register on device in to _buff array
void Accelerometer::readFrom(int device, byte address, int num, byte _buff[]) {
    5ef0:	af 92       	push	r10
    5ef2:	bf 92       	push	r11
    5ef4:	df 92       	push	r13
    5ef6:	ef 92       	push	r14
    5ef8:	ff 92       	push	r15
    5efa:	0f 93       	push	r16
    5efc:	1f 93       	push	r17
    5efe:	cf 93       	push	r28
    5f00:	df 93       	push	r29
    5f02:	7b 01       	movw	r14, r22
    5f04:	d4 2e       	mov	r13, r20
    5f06:	59 01       	movw	r10, r18
  Wire.beginTransmission(device); // start transmission to device 
    5f08:	80 e2       	ldi	r24, 0x20	; 32
    5f0a:	99 e0       	ldi	r25, 0x09	; 9
    5f0c:	6e db       	rcall	.-2340   	; 0x55ea <_ZN7WireI2C17beginTransmissionEi>
  Wire.send(address);             // sends address to read from
    5f0e:	80 e2       	ldi	r24, 0x20	; 32
    5f10:	99 e0       	ldi	r25, 0x09	; 9
    5f12:	6d 2d       	mov	r22, r13
    5f14:	6c db       	rcall	.-2344   	; 0x55ee <_ZN7WireI2C4sendEh>
  Wire.endTransmission();         // end transmission
    5f16:	80 e2       	ldi	r24, 0x20	; 32
    5f18:	99 e0       	ldi	r25, 0x09	; 9
    5f1a:	68 db       	rcall	.-2352   	; 0x55ec <_ZN7WireI2C15endTransmissionEv>

    Wire.beginTransmission(device); // start transmission to device
    5f1c:	80 e2       	ldi	r24, 0x20	; 32
    5f1e:	99 e0       	ldi	r25, 0x09	; 9
    5f20:	b7 01       	movw	r22, r14
    5f22:	63 db       	rcall	.-2362   	; 0x55ea <_ZN7WireI2C17beginTransmissionEi>
  Wire.requestFrom(device, num);    // request 6 bytes from device
    5f24:	80 e2       	ldi	r24, 0x20	; 32
    5f26:	99 e0       	ldi	r25, 0x09	; 9
    5f28:	b7 01       	movw	r22, r14
    5f2a:	a5 01       	movw	r20, r10
    5f2c:	63 db       	rcall	.-2362   	; 0x55f4 <_ZN7WireI2C11requestFromEii>
    5f2e:	e8 01       	movw	r28, r16
    5f30:	04 c0       	rjmp	.+8      	; 0x5f3a <_ZN13Accelerometer8readFromEihiPh+0x4a>

  int i = 0;
  while(Wire.available())         // device may send less than requested (abnormal)
  { 
    _buff[i] = Wire.receive();    // receive a byte
    5f32:	80 e2       	ldi	r24, 0x20	; 32
    5f34:	99 e0       	ldi	r25, 0x09	; 9
    5f36:	5c db       	rcall	.-2376   	; 0x55f0 <_ZN7WireI2C7receiveEv>
    5f38:	89 93       	st	Y+, r24

    Wire.beginTransmission(device); // start transmission to device
  Wire.requestFrom(device, num);    // request 6 bytes from device

  int i = 0;
  while(Wire.available())         // device may send less than requested (abnormal)
    5f3a:	80 e2       	ldi	r24, 0x20	; 32
    5f3c:	99 e0       	ldi	r25, 0x09	; 9
    5f3e:	5b db       	rcall	.-2378   	; 0x55f6 <_ZN7WireI2C9availableEv>
    5f40:	88 23       	and	r24, r24
    5f42:	b9 f7       	brne	.-18     	; 0x5f32 <_ZN13Accelerometer8readFromEihiPh+0x42>
  { 
    _buff[i] = Wire.receive();    // receive a byte
    i++;
  }
  Wire.endTransmission();         // end transmission
    5f44:	80 e2       	ldi	r24, 0x20	; 32
    5f46:	99 e0       	ldi	r25, 0x09	; 9
    5f48:	51 db       	rcall	.-2398   	; 0x55ec <_ZN7WireI2C15endTransmissionEv>
}
    5f4a:	df 91       	pop	r29
    5f4c:	cf 91       	pop	r28
    5f4e:	1f 91       	pop	r17
    5f50:	0f 91       	pop	r16
    5f52:	ff 90       	pop	r15
    5f54:	ef 90       	pop	r14
    5f56:	df 90       	pop	r13
    5f58:	bf 90       	pop	r11
    5f5a:	af 90       	pop	r10
    5f5c:	08 95       	ret

00005f5e <_ZN13Accelerometer16printAllRegisterEv>:
  return ((_b >> bitPos) & 1);
}

// print all register value to the serial ouptut, which requires it to be setup
// this can be used to manually to check the current configuration of the device
void Accelerometer::printAllRegister() {
    5f5e:	9f 92       	push	r9
    5f60:	af 92       	push	r10
    5f62:	bf 92       	push	r11
    5f64:	cf 92       	push	r12
    5f66:	df 92       	push	r13
    5f68:	ef 92       	push	r14
    5f6a:	ff 92       	push	r15
    5f6c:	0f 93       	push	r16
    5f6e:	1f 93       	push	r17
    5f70:	df 93       	push	r29
    5f72:	cf 93       	push	r28
    5f74:	0f 92       	push	r0
    5f76:	cd b7       	in	r28, 0x3d	; 61
    5f78:	de b7       	in	r29, 0x3e	; 62
    5f7a:	5c 01       	movw	r10, r24
  byte _b;
  Serial.print("0x00:\t");
    5f7c:	80 ef       	ldi	r24, 0xF0	; 240
    5f7e:	98 e0       	ldi	r25, 0x08	; 8
    5f80:	6c e5       	ldi	r22, 0x5C	; 92
    5f82:	74 e0       	ldi	r23, 0x04	; 4
    5f84:	84 de       	rcall	.-760    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
  readFrom(DEVICE, 0x00, 1, &_b);
    5f86:	c5 01       	movw	r24, r10
    5f88:	63 e5       	ldi	r22, 0x53	; 83
    5f8a:	70 e0       	ldi	r23, 0x00	; 0
    5f8c:	40 e0       	ldi	r20, 0x00	; 0
    5f8e:	21 e0       	ldi	r18, 0x01	; 1
    5f90:	30 e0       	ldi	r19, 0x00	; 0
    5f92:	7e 01       	movw	r14, r28
    5f94:	08 94       	sec
    5f96:	e1 1c       	adc	r14, r1
    5f98:	f1 1c       	adc	r15, r1
    5f9a:	87 01       	movw	r16, r14
    5f9c:	a9 df       	rcall	.-174    	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  Serial.print(_b, BIN);
    5f9e:	80 ef       	ldi	r24, 0xF0	; 240
    5fa0:	98 e0       	ldi	r25, 0x08	; 8
    5fa2:	69 81       	ldd	r22, Y+1	; 0x01
    5fa4:	42 e0       	ldi	r20, 0x02	; 2
    5fa6:	eb dd       	rcall	.-1066   	; 0x5b7e <_ZN16USBVirtualSerial5printEhh>
  Serial.print("\r\n");
    5fa8:	80 ef       	ldi	r24, 0xF0	; 240
    5faa:	98 e0       	ldi	r25, 0x08	; 8
    5fac:	63 e6       	ldi	r22, 0x63	; 99
    5fae:	74 e0       	ldi	r23, 0x04	; 4
    5fb0:	6e de       	rcall	.-804    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    5fb2:	8d e1       	ldi	r24, 0x1D	; 29
    5fb4:	c8 2e       	mov	r12, r24
    5fb6:	d1 2c       	mov	r13, r1
  int i;
  for (i=29;i<=57;i++){
    Serial.print("0x");
    Serial.print(i, HEX);
    Serial.print(":\t");
    readFrom(DEVICE, i, 1, &_b);
    5fb8:	9e 2c       	mov	r9, r14
    5fba:	ef 2c       	mov	r14, r15
  readFrom(DEVICE, 0x00, 1, &_b);
  Serial.print(_b, BIN);
  Serial.print("\r\n");
  int i;
  for (i=29;i<=57;i++){
    Serial.print("0x");
    5fbc:	80 ef       	ldi	r24, 0xF0	; 240
    5fbe:	98 e0       	ldi	r25, 0x08	; 8
    5fc0:	66 e6       	ldi	r22, 0x66	; 102
    5fc2:	74 e0       	ldi	r23, 0x04	; 4
    5fc4:	64 de       	rcall	.-824    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    Serial.print(i, HEX);
    5fc6:	80 ef       	ldi	r24, 0xF0	; 240
    5fc8:	98 e0       	ldi	r25, 0x08	; 8
    5fca:	b6 01       	movw	r22, r12
    5fcc:	40 e1       	ldi	r20, 0x10	; 16
    5fce:	cb de       	rcall	.-618    	; 0x5d66 <_ZN16USBVirtualSerial5printEih>
    Serial.print(":\t");
    5fd0:	80 ef       	ldi	r24, 0xF0	; 240
    5fd2:	98 e0       	ldi	r25, 0x08	; 8
    5fd4:	69 e6       	ldi	r22, 0x69	; 105
    5fd6:	74 e0       	ldi	r23, 0x04	; 4
    5fd8:	5a de       	rcall	.-844    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
    readFrom(DEVICE, i, 1, &_b);
    5fda:	c5 01       	movw	r24, r10
    5fdc:	63 e5       	ldi	r22, 0x53	; 83
    5fde:	70 e0       	ldi	r23, 0x00	; 0
    5fe0:	4c 2d       	mov	r20, r12
    5fe2:	21 e0       	ldi	r18, 0x01	; 1
    5fe4:	30 e0       	ldi	r19, 0x00	; 0
    5fe6:	09 2d       	mov	r16, r9
    5fe8:	1e 2d       	mov	r17, r14
    5fea:	82 df       	rcall	.-252    	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
    Serial.print(_b, BIN);
    5fec:	80 ef       	ldi	r24, 0xF0	; 240
    5fee:	98 e0       	ldi	r25, 0x08	; 8
    5ff0:	69 81       	ldd	r22, Y+1	; 0x01
    5ff2:	42 e0       	ldi	r20, 0x02	; 2
    5ff4:	c4 dd       	rcall	.-1144   	; 0x5b7e <_ZN16USBVirtualSerial5printEhh>
    Serial.print("\r\n");    
    5ff6:	80 ef       	ldi	r24, 0xF0	; 240
    5ff8:	98 e0       	ldi	r25, 0x08	; 8
    5ffa:	63 e6       	ldi	r22, 0x63	; 99
    5ffc:	74 e0       	ldi	r23, 0x04	; 4
    5ffe:	47 de       	rcall	.-882    	; 0x5c8e <_ZN16USBVirtualSerial5printEPKc>
  Serial.print("0x00:\t");
  readFrom(DEVICE, 0x00, 1, &_b);
  Serial.print(_b, BIN);
  Serial.print("\r\n");
  int i;
  for (i=29;i<=57;i++){
    6000:	08 94       	sec
    6002:	c1 1c       	adc	r12, r1
    6004:	d1 1c       	adc	r13, r1
    6006:	8a e3       	ldi	r24, 0x3A	; 58
    6008:	c8 16       	cp	r12, r24
    600a:	d1 04       	cpc	r13, r1
    600c:	b9 f6       	brne	.-82     	; 0x5fbc <_ZN13Accelerometer16printAllRegisterEv+0x5e>
    Serial.print(":\t");
    readFrom(DEVICE, i, 1, &_b);
    Serial.print(_b, BIN);
    Serial.print("\r\n");    
  }
}
    600e:	0f 90       	pop	r0
    6010:	cf 91       	pop	r28
    6012:	df 91       	pop	r29
    6014:	1f 91       	pop	r17
    6016:	0f 91       	pop	r16
    6018:	ff 90       	pop	r15
    601a:	ef 90       	pop	r14
    601c:	df 90       	pop	r13
    601e:	cf 90       	pop	r12
    6020:	bf 90       	pop	r11
    6022:	af 90       	pop	r10
    6024:	9f 90       	pop	r9
    6026:	08 95       	ret

00006028 <_ZN13Accelerometer14getRegisterBitEhi>:
    _b &= ~(1 << bitPos); // forces nth bit of _b to be 0.  all other bits left alone.
  }
  writeTo(DEVICE, regAdress, _b);  
}

bool Accelerometer::getRegisterBit(byte regAdress, int bitPos) {
    6028:	ff 92       	push	r15
    602a:	0f 93       	push	r16
    602c:	1f 93       	push	r17
    602e:	df 93       	push	r29
    6030:	cf 93       	push	r28
    6032:	0f 92       	push	r0
    6034:	cd b7       	in	r28, 0x3d	; 61
    6036:	de b7       	in	r29, 0x3e	; 62
    6038:	26 2f       	mov	r18, r22
    603a:	f4 2e       	mov	r15, r20
  byte _b;
  readFrom(DEVICE, regAdress, 1, &_b);
    603c:	63 e5       	ldi	r22, 0x53	; 83
    603e:	70 e0       	ldi	r23, 0x00	; 0
    6040:	42 2f       	mov	r20, r18
    6042:	21 e0       	ldi	r18, 0x01	; 1
    6044:	30 e0       	ldi	r19, 0x00	; 0
    6046:	8e 01       	movw	r16, r28
    6048:	0f 5f       	subi	r16, 0xFF	; 255
    604a:	1f 4f       	sbci	r17, 0xFF	; 255
    604c:	51 df       	rcall	.-350    	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
    604e:	89 81       	ldd	r24, Y+1	; 0x01
    6050:	90 e0       	ldi	r25, 0x00	; 0
    6052:	02 c0       	rjmp	.+4      	; 0x6058 <_ZN13Accelerometer14getRegisterBitEhi+0x30>
    6054:	95 95       	asr	r25
    6056:	87 95       	ror	r24
    6058:	fa 94       	dec	r15
    605a:	e2 f7       	brpl	.-8      	; 0x6054 <_ZN13Accelerometer14getRegisterBitEhi+0x2c>
  return ((_b >> bitPos) & 1);
}
    605c:	81 70       	andi	r24, 0x01	; 1
    605e:	0f 90       	pop	r0
    6060:	cf 91       	pop	r28
    6062:	df 91       	pop	r29
    6064:	1f 91       	pop	r17
    6066:	0f 91       	pop	r16
    6068:	ff 90       	pop	r15
    606a:	08 95       	ret

0000606c <_ZN13Accelerometer18isInterruptEnabledEh>:
// eg: setInterruptMapping(ADXL345_INT_DOUBLE_TAP_BIT,ADXL345_INT2_PIN);
void Accelerometer::setInterruptMapping(byte interruptBit, bool interruptPin) {
  setRegisterBit(ADXL345_INT_MAP, interruptBit, interruptPin);
}

bool Accelerometer::isInterruptEnabled(byte interruptBit) {
    606c:	46 2f       	mov	r20, r22
  return getRegisterBit(ADXL345_INT_ENABLE,interruptBit);
    606e:	6e e2       	ldi	r22, 0x2E	; 46
    6070:	50 e0       	ldi	r21, 0x00	; 0
}
    6072:	da cf       	rjmp	.-76     	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006074 <_ZN13Accelerometer19getInterruptMappingEh>:

bool Accelerometer::getInterruptSource(byte interruptBit) {
  return getRegisterBit(ADXL345_INT_SOURCE,interruptBit);
}

bool Accelerometer::getInterruptMapping(byte interruptBit) {
    6074:	46 2f       	mov	r20, r22
  return getRegisterBit(ADXL345_INT_MAP,interruptBit);
    6076:	6f e2       	ldi	r22, 0x2F	; 47
    6078:	50 e0       	ldi	r21, 0x00	; 0
}
    607a:	d6 cf       	rjmp	.-84     	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000607c <_ZN13Accelerometer18getInterruptSourceEh>:
  byte _b;
  readFrom(DEVICE, ADXL345_INT_SOURCE, 1, &_b);
  return _b;
}

bool Accelerometer::getInterruptSource(byte interruptBit) {
    607c:	46 2f       	mov	r20, r22
  return getRegisterBit(ADXL345_INT_SOURCE,interruptBit);
    607e:	60 e3       	ldi	r22, 0x30	; 48
    6080:	50 e0       	ldi	r21, 0x00	; 0
}
    6082:	d2 cf       	rjmp	.-92     	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006084 <_ZN13Accelerometer10isLowPowerEv>:
bool Accelerometer::isAsleep(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 3); 
}

bool Accelerometer::isLowPower(){ 
  return getRegisterBit(ADXL345_BW_RATE, 4); 
    6084:	6c e2       	ldi	r22, 0x2C	; 44
    6086:	44 e0       	ldi	r20, 0x04	; 4
    6088:	50 e0       	ldi	r21, 0x00	; 0
}
    608a:	ce cf       	rjmp	.-100    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000608c <_ZN13Accelerometer8isAsleepEv>:
bool Accelerometer::isTapSourceOnZ(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 0); 
}

bool Accelerometer::isAsleep(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 3); 
    608c:	6b e2       	ldi	r22, 0x2B	; 43
    608e:	43 e0       	ldi	r20, 0x03	; 3
    6090:	50 e0       	ldi	r21, 0x00	; 0
}
    6092:	ca cf       	rjmp	.-108    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006094 <_ZN13Accelerometer14isTapSourceOnZEv>:
}
bool Accelerometer::isTapSourceOnY(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 1); 
}
bool Accelerometer::isTapSourceOnZ(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 0); 
    6094:	6b e2       	ldi	r22, 0x2B	; 43
    6096:	40 e0       	ldi	r20, 0x00	; 0
    6098:	50 e0       	ldi	r21, 0x00	; 0
}
    609a:	c6 cf       	rjmp	.-116    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000609c <_ZN13Accelerometer14isTapSourceOnYEv>:

bool Accelerometer::isTapSourceOnX(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 2); 
}
bool Accelerometer::isTapSourceOnY(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 1); 
    609c:	6b e2       	ldi	r22, 0x2B	; 43
    609e:	41 e0       	ldi	r20, 0x01	; 1
    60a0:	50 e0       	ldi	r21, 0x00	; 0
}
    60a2:	c2 cf       	rjmp	.-124    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060a4 <_ZN13Accelerometer14isTapSourceOnXEv>:
bool Accelerometer::isActivitySourceOnZ(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 4); 
}

bool Accelerometer::isTapSourceOnX(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 2); 
    60a4:	6b e2       	ldi	r22, 0x2B	; 43
    60a6:	42 e0       	ldi	r20, 0x02	; 2
    60a8:	50 e0       	ldi	r21, 0x00	; 0
}
    60aa:	be cf       	rjmp	.-132    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060ac <_ZN13Accelerometer19isActivitySourceOnZEv>:
}
bool Accelerometer::isActivitySourceOnY(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 5); 
}
bool Accelerometer::isActivitySourceOnZ(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 4); 
    60ac:	6b e2       	ldi	r22, 0x2B	; 43
    60ae:	44 e0       	ldi	r20, 0x04	; 4
    60b0:	50 e0       	ldi	r21, 0x00	; 0
}
    60b2:	ba cf       	rjmp	.-140    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060b4 <_ZN13Accelerometer19isActivitySourceOnYEv>:

bool Accelerometer::isActivitySourceOnX(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 6); 
}
bool Accelerometer::isActivitySourceOnY(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 5); 
    60b4:	6b e2       	ldi	r22, 0x2B	; 43
    60b6:	45 e0       	ldi	r20, 0x05	; 5
    60b8:	50 e0       	ldi	r21, 0x00	; 0
}
    60ba:	b6 cf       	rjmp	.-148    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060bc <_ZN13Accelerometer19isActivitySourceOnXEv>:
void Accelerometer::setTapDetectionOnZ(bool state) {  
  setRegisterBit(ADXL345_TAP_AXES, 0, state); 
}

bool Accelerometer::isActivitySourceOnX(){ 
  return getRegisterBit(ADXL345_ACT_TAP_STATUS, 6); 
    60bc:	6b e2       	ldi	r22, 0x2B	; 43
    60be:	46 e0       	ldi	r20, 0x06	; 6
    60c0:	50 e0       	ldi	r21, 0x00	; 0
}
    60c2:	b2 cf       	rjmp	.-156    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060c4 <_ZN13Accelerometer17isTapDetectionOnZEv>:
}
void Accelerometer::setTapDetectionOnY(bool state) {  
  setRegisterBit(ADXL345_TAP_AXES, 1, state); 
}
bool Accelerometer::isTapDetectionOnZ(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 0); 
    60c4:	6a e2       	ldi	r22, 0x2A	; 42
    60c6:	40 e0       	ldi	r20, 0x00	; 0
    60c8:	50 e0       	ldi	r21, 0x00	; 0
}
    60ca:	ae cf       	rjmp	.-164    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060cc <_ZN13Accelerometer17isTapDetectionOnYEv>:
}
void Accelerometer::setTapDetectionOnX(bool state) {  
  setRegisterBit(ADXL345_TAP_AXES, 2, state); 
}
bool Accelerometer::isTapDetectionOnY(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 1); 
    60cc:	6a e2       	ldi	r22, 0x2A	; 42
    60ce:	41 e0       	ldi	r20, 0x01	; 1
    60d0:	50 e0       	ldi	r21, 0x00	; 0
}
    60d2:	aa cf       	rjmp	.-172    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060d4 <_ZN13Accelerometer17isTapDetectionOnXEv>:
void Accelerometer::setSuppressBit(bool state) {  
  setRegisterBit(ADXL345_TAP_AXES, 3, state); 
}

bool Accelerometer::isTapDetectionOnX(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 2); 
    60d4:	6a e2       	ldi	r22, 0x2A	; 42
    60d6:	42 e0       	ldi	r20, 0x02	; 2
    60d8:	50 e0       	ldi	r21, 0x00	; 0
}
    60da:	a6 cf       	rjmp	.-180    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060dc <_ZN13Accelerometer14getSuppressBitEv>:
void Accelerometer::setInactivityAc(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 3, state); 
}

bool Accelerometer::getSuppressBit(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 3); 
    60dc:	6a e2       	ldi	r22, 0x2A	; 42
    60de:	43 e0       	ldi	r20, 0x03	; 3
    60e0:	50 e0       	ldi	r21, 0x00	; 0
}
    60e2:	a2 cf       	rjmp	.-188    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060e4 <_ZN13Accelerometer14isInactivityAcEv>:

bool Accelerometer::isActivityAc() { 
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 7); 
}
bool Accelerometer::isInactivityAc(){ 
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 3); 
    60e4:	67 e2       	ldi	r22, 0x27	; 39
    60e6:	43 e0       	ldi	r20, 0x03	; 3
    60e8:	50 e0       	ldi	r21, 0x00	; 0
}
    60ea:	9e cf       	rjmp	.-196    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060ec <_ZN13Accelerometer12isActivityAcEv>:
void Accelerometer::setInactivityZ(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 0, state); 
}

bool Accelerometer::isActivityAc() { 
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 7); 
    60ec:	67 e2       	ldi	r22, 0x27	; 39
    60ee:	47 e0       	ldi	r20, 0x07	; 7
    60f0:	50 e0       	ldi	r21, 0x00	; 0
}
    60f2:	9a cf       	rjmp	.-204    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060f4 <_ZN13Accelerometer20isInactivityZEnabledEv>:
}
bool Accelerometer::isInactivityYEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 1); 
}
bool Accelerometer::isInactivityZEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 0); 
    60f4:	67 e2       	ldi	r22, 0x27	; 39
    60f6:	40 e0       	ldi	r20, 0x00	; 0
    60f8:	50 e0       	ldi	r21, 0x00	; 0
}
    60fa:	96 cf       	rjmp	.-212    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

000060fc <_ZN13Accelerometer20isInactivityYEnabledEv>:
}
bool Accelerometer::isInactivityXEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 2); 
}
bool Accelerometer::isInactivityYEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 1); 
    60fc:	67 e2       	ldi	r22, 0x27	; 39
    60fe:	41 e0       	ldi	r20, 0x01	; 1
    6100:	50 e0       	ldi	r21, 0x00	; 0
}
    6102:	92 cf       	rjmp	.-220    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006104 <_ZN13Accelerometer20isInactivityXEnabledEv>:
}
bool Accelerometer::isActivityZEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 4); 
}
bool Accelerometer::isInactivityXEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 2); 
    6104:	67 e2       	ldi	r22, 0x27	; 39
    6106:	42 e0       	ldi	r20, 0x02	; 2
    6108:	50 e0       	ldi	r21, 0x00	; 0
}
    610a:	8e cf       	rjmp	.-228    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000610c <_ZN13Accelerometer18isActivityZEnabledEv>:
}
bool Accelerometer::isActivityYEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 5); 
}
bool Accelerometer::isActivityZEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 4); 
    610c:	67 e2       	ldi	r22, 0x27	; 39
    610e:	44 e0       	ldi	r20, 0x04	; 4
    6110:	50 e0       	ldi	r21, 0x00	; 0
}
    6112:	8a cf       	rjmp	.-236    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006114 <_ZN13Accelerometer18isActivityYEnabledEv>:

bool Accelerometer::isActivityXEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 6); 
}
bool Accelerometer::isActivityYEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 5); 
    6114:	67 e2       	ldi	r22, 0x27	; 39
    6116:	45 e0       	ldi	r20, 0x05	; 5
    6118:	50 e0       	ldi	r21, 0x00	; 0
}
    611a:	86 cf       	rjmp	.-244    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000611c <_ZN13Accelerometer18isActivityXEnabledEv>:
  readFrom(DEVICE, ADXL345_TIME_FF, 1, &_b);  
  return int (_b);
}

bool Accelerometer::isActivityXEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 6); 
    611c:	67 e2       	ldi	r22, 0x27	; 39
    611e:	46 e0       	ldi	r20, 0x06	; 6
    6120:	50 e0       	ldi	r21, 0x00	; 0
}
    6122:	82 cf       	rjmp	.-252    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006124 <_ZN13Accelerometer13getJustifyBitEv>:
  setRegisterBit(ADXL345_DATA_FORMAT, 3, fullResBit);
}

// Gets the state of the justify bit
bool Accelerometer::getJustifyBit() {
  return getRegisterBit(ADXL345_DATA_FORMAT, 2);
    6124:	61 e3       	ldi	r22, 0x31	; 49
    6126:	42 e0       	ldi	r20, 0x02	; 2
    6128:	50 e0       	ldi	r21, 0x00	; 0
}
    612a:	7e cf       	rjmp	.-260    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000612c <_ZN13Accelerometer13getFullResBitEv>:
  setRegisterBit(ADXL345_DATA_FORMAT, 5, interruptLevelBit);
}

// Gets the state of the FULL_RES bit
bool Accelerometer::getFullResBit() {
  return getRegisterBit(ADXL345_DATA_FORMAT, 3);
    612c:	61 e3       	ldi	r22, 0x31	; 49
    612e:	43 e0       	ldi	r20, 0x03	; 3
    6130:	50 e0       	ldi	r21, 0x00	; 0
}
    6132:	7a cf       	rjmp	.-268    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006134 <_ZN13Accelerometer20getInterruptLevelBitEv>:
  setRegisterBit(ADXL345_DATA_FORMAT, 6, spiBit);
}

// Gets the state of the INT_INVERT bit
bool Accelerometer::getInterruptLevelBit() {
  return getRegisterBit(ADXL345_DATA_FORMAT, 5);
    6134:	61 e3       	ldi	r22, 0x31	; 49
    6136:	45 e0       	ldi	r20, 0x05	; 5
    6138:	50 e0       	ldi	r21, 0x00	; 0
}
    613a:	76 cf       	rjmp	.-276    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000613c <_ZN13Accelerometer9getSpiBitEv>:
  setRegisterBit(ADXL345_DATA_FORMAT, 7, selfTestBit);
}

// Gets the state of the SPI bit
bool Accelerometer::getSpiBit() {
  return getRegisterBit(ADXL345_DATA_FORMAT, 6);
    613c:	61 e3       	ldi	r22, 0x31	; 49
    613e:	46 e0       	ldi	r20, 0x06	; 6
    6140:	50 e0       	ldi	r21, 0x00	; 0
}
    6142:	72 cf       	rjmp	.-284    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

00006144 <_ZN13Accelerometer14getSelfTestBitEv>:
  _s |= (_b & 0B11101100);
  writeTo(DEVICE, ADXL345_DATA_FORMAT, _s);
}
// gets the state of the SELF_TEST bit
bool Accelerometer::getSelfTestBit() {
  return getRegisterBit(ADXL345_DATA_FORMAT, 7);
    6144:	61 e3       	ldi	r22, 0x31	; 49
    6146:	47 e0       	ldi	r20, 0x07	; 7
    6148:	50 e0       	ldi	r21, 0x00	; 0
}
    614a:	6e cf       	rjmp	.-292    	; 0x6028 <_ZN13Accelerometer14getRegisterBitEhi>

0000614c <_ZN13Accelerometer14setRegisterBitEhib>:

void Accelerometer::setInterrupt(byte interruptBit, bool state) {
  setRegisterBit(ADXL345_INT_ENABLE, interruptBit, state);
}

void Accelerometer::setRegisterBit(byte regAdress, int bitPos, bool state) {
    614c:	bf 92       	push	r11
    614e:	cf 92       	push	r12
    6150:	df 92       	push	r13
    6152:	ef 92       	push	r14
    6154:	ff 92       	push	r15
    6156:	0f 93       	push	r16
    6158:	1f 93       	push	r17
    615a:	df 93       	push	r29
    615c:	cf 93       	push	r28
    615e:	0f 92       	push	r0
    6160:	cd b7       	in	r28, 0x3d	; 61
    6162:	de b7       	in	r29, 0x3e	; 62
    6164:	6c 01       	movw	r12, r24
    6166:	b6 2e       	mov	r11, r22
    6168:	e4 2e       	mov	r14, r20
    616a:	f2 2e       	mov	r15, r18
  byte _b;
  readFrom(DEVICE, regAdress, 1, &_b);
    616c:	63 e5       	ldi	r22, 0x53	; 83
    616e:	70 e0       	ldi	r23, 0x00	; 0
    6170:	4b 2d       	mov	r20, r11
    6172:	21 e0       	ldi	r18, 0x01	; 1
    6174:	30 e0       	ldi	r19, 0x00	; 0
    6176:	8e 01       	movw	r16, r28
    6178:	0f 5f       	subi	r16, 0xFF	; 255
    617a:	1f 4f       	sbci	r17, 0xFF	; 255
    617c:	b9 de       	rcall	.-654    	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
    617e:	29 81       	ldd	r18, Y+1	; 0x01
  if (state) {
    6180:	ff 20       	and	r15, r15
    6182:	49 f0       	breq	.+18     	; 0x6196 <_ZN13Accelerometer14setRegisterBitEhib+0x4a>
    _b |= (1 << bitPos);  // forces nth bit of _b to be 1.  all other bits left alone.
    6184:	81 e0       	ldi	r24, 0x01	; 1
    6186:	90 e0       	ldi	r25, 0x00	; 0
    6188:	02 c0       	rjmp	.+4      	; 0x618e <_ZN13Accelerometer14setRegisterBitEhib+0x42>
    618a:	88 0f       	add	r24, r24
    618c:	99 1f       	adc	r25, r25
    618e:	ea 94       	dec	r14
    6190:	e2 f7       	brpl	.-8      	; 0x618a <_ZN13Accelerometer14setRegisterBitEhib+0x3e>
    6192:	28 2b       	or	r18, r24
    6194:	09 c0       	rjmp	.+18     	; 0x61a8 <_ZN13Accelerometer14setRegisterBitEhib+0x5c>
  } 
  else {
    _b &= ~(1 << bitPos); // forces nth bit of _b to be 0.  all other bits left alone.
    6196:	81 e0       	ldi	r24, 0x01	; 1
    6198:	90 e0       	ldi	r25, 0x00	; 0
    619a:	02 c0       	rjmp	.+4      	; 0x61a0 <_ZN13Accelerometer14setRegisterBitEhib+0x54>
    619c:	88 0f       	add	r24, r24
    619e:	99 1f       	adc	r25, r25
    61a0:	ea 94       	dec	r14
    61a2:	e2 f7       	brpl	.-8      	; 0x619c <_ZN13Accelerometer14setRegisterBitEhib+0x50>
    61a4:	80 95       	com	r24
    61a6:	28 23       	and	r18, r24
    61a8:	29 83       	std	Y+1, r18	; 0x01
  }
  writeTo(DEVICE, regAdress, _b);  
    61aa:	c6 01       	movw	r24, r12
    61ac:	63 e5       	ldi	r22, 0x53	; 83
    61ae:	70 e0       	ldi	r23, 0x00	; 0
    61b0:	4b 2d       	mov	r20, r11
    61b2:	29 81       	ldd	r18, Y+1	; 0x01
    61b4:	eb dd       	rcall	.-1066   	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
}
    61b6:	0f 90       	pop	r0
    61b8:	cf 91       	pop	r28
    61ba:	df 91       	pop	r29
    61bc:	1f 91       	pop	r17
    61be:	0f 91       	pop	r16
    61c0:	ff 90       	pop	r15
    61c2:	ef 90       	pop	r14
    61c4:	df 90       	pop	r13
    61c6:	cf 90       	pop	r12
    61c8:	bf 90       	pop	r11
    61ca:	08 95       	ret

000061cc <_ZN13Accelerometer12setInterruptEhb>:

bool Accelerometer::isInterruptEnabled(byte interruptBit) {
  return getRegisterBit(ADXL345_INT_ENABLE,interruptBit);
}

void Accelerometer::setInterrupt(byte interruptBit, bool state) {
    61cc:	36 2f       	mov	r19, r22
    61ce:	24 2f       	mov	r18, r20
  setRegisterBit(ADXL345_INT_ENABLE, interruptBit, state);
    61d0:	6e e2       	ldi	r22, 0x2E	; 46
    61d2:	43 2f       	mov	r20, r19
    61d4:	50 e0       	ldi	r21, 0x00	; 0
}
    61d6:	ba cf       	rjmp	.-140    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

000061d8 <_ZN13Accelerometer19setInterruptMappingEhb>:
  return getRegisterBit(ADXL345_INT_MAP,interruptBit);
}

// Set the mapping of an interrupt to pin1 or pin2
// eg: setInterruptMapping(ADXL345_INT_DOUBLE_TAP_BIT,ADXL345_INT2_PIN);
void Accelerometer::setInterruptMapping(byte interruptBit, bool interruptPin) {
    61d8:	36 2f       	mov	r19, r22
    61da:	24 2f       	mov	r18, r20
  setRegisterBit(ADXL345_INT_MAP, interruptBit, interruptPin);
    61dc:	6f e2       	ldi	r22, 0x2F	; 47
    61de:	43 2f       	mov	r20, r19
    61e0:	50 e0       	ldi	r21, 0x00	; 0
}
    61e2:	b4 cf       	rjmp	.-152    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

000061e4 <_ZN13Accelerometer11setLowPowerEb>:
}

bool Accelerometer::isLowPower(){ 
  return getRegisterBit(ADXL345_BW_RATE, 4); 
}
void Accelerometer::setLowPower(bool state) {  
    61e4:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_BW_RATE, 4, state); 
    61e6:	6c e2       	ldi	r22, 0x2C	; 44
    61e8:	44 e0       	ldi	r20, 0x04	; 4
    61ea:	50 e0       	ldi	r21, 0x00	; 0
}
    61ec:	af cf       	rjmp	.-162    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

000061ee <_ZN13Accelerometer18setTapDetectionOnZEb>:
  setRegisterBit(ADXL345_TAP_AXES, 1, state); 
}
bool Accelerometer::isTapDetectionOnZ(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 0); 
}
void Accelerometer::setTapDetectionOnZ(bool state) {  
    61ee:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_TAP_AXES, 0, state); 
    61f0:	6a e2       	ldi	r22, 0x2A	; 42
    61f2:	40 e0       	ldi	r20, 0x00	; 0
    61f4:	50 e0       	ldi	r21, 0x00	; 0
}
    61f6:	aa cf       	rjmp	.-172    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

000061f8 <_ZN13Accelerometer18setTapDetectionOnYEb>:
  setRegisterBit(ADXL345_TAP_AXES, 2, state); 
}
bool Accelerometer::isTapDetectionOnY(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 1); 
}
void Accelerometer::setTapDetectionOnY(bool state) {  
    61f8:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_TAP_AXES, 1, state); 
    61fa:	6a e2       	ldi	r22, 0x2A	; 42
    61fc:	41 e0       	ldi	r20, 0x01	; 1
    61fe:	50 e0       	ldi	r21, 0x00	; 0
}
    6200:	a5 cf       	rjmp	.-182    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006202 <_ZN13Accelerometer18setTapDetectionOnXEb>:
}

bool Accelerometer::isTapDetectionOnX(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 2); 
}
void Accelerometer::setTapDetectionOnX(bool state) {  
    6202:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_TAP_AXES, 2, state); 
    6204:	6a e2       	ldi	r22, 0x2A	; 42
    6206:	42 e0       	ldi	r20, 0x02	; 2
    6208:	50 e0       	ldi	r21, 0x00	; 0
}
    620a:	a0 cf       	rjmp	.-192    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

0000620c <_ZN13Accelerometer14setSuppressBitEb>:
}

bool Accelerometer::getSuppressBit(){ 
  return getRegisterBit(ADXL345_TAP_AXES, 3); 
}
void Accelerometer::setSuppressBit(bool state) {  
    620c:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_TAP_AXES, 3, state); 
    620e:	6a e2       	ldi	r22, 0x2A	; 42
    6210:	43 e0       	ldi	r20, 0x03	; 3
    6212:	50 e0       	ldi	r21, 0x00	; 0
}
    6214:	9b cf       	rjmp	.-202    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006216 <_ZN13Accelerometer15setInactivityAcEb>:
}

void Accelerometer::setActivityAc(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 7, state); 
}
void Accelerometer::setInactivityAc(bool state) {  
    6216:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 3, state); 
    6218:	67 e2       	ldi	r22, 0x27	; 39
    621a:	43 e0       	ldi	r20, 0x03	; 3
    621c:	50 e0       	ldi	r21, 0x00	; 0
}
    621e:	96 cf       	rjmp	.-212    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006220 <_ZN13Accelerometer13setActivityAcEb>:
}
bool Accelerometer::isInactivityAc(){ 
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 3); 
}

void Accelerometer::setActivityAc(bool state) {  
    6220:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 7, state); 
    6222:	67 e2       	ldi	r22, 0x27	; 39
    6224:	47 e0       	ldi	r20, 0x07	; 7
    6226:	50 e0       	ldi	r21, 0x00	; 0
}
    6228:	91 cf       	rjmp	.-222    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

0000622a <_ZN13Accelerometer14setInactivityZEb>:
  setRegisterBit(ADXL345_ACT_INACT_CTL, 2, state); 
}
void Accelerometer::setInactivityY(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 1, state); 
}
void Accelerometer::setInactivityZ(bool state) {  
    622a:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 0, state); 
    622c:	67 e2       	ldi	r22, 0x27	; 39
    622e:	40 e0       	ldi	r20, 0x00	; 0
    6230:	50 e0       	ldi	r21, 0x00	; 0
}
    6232:	8c cf       	rjmp	.-232    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006234 <_ZN13Accelerometer14setInactivityYEb>:
  setRegisterBit(ADXL345_ACT_INACT_CTL, 4, state); 
}
void Accelerometer::setInactivityX(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 2, state); 
}
void Accelerometer::setInactivityY(bool state) {  
    6234:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 1, state); 
    6236:	67 e2       	ldi	r22, 0x27	; 39
    6238:	41 e0       	ldi	r20, 0x01	; 1
    623a:	50 e0       	ldi	r21, 0x00	; 0
}
    623c:	87 cf       	rjmp	.-242    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

0000623e <_ZN13Accelerometer14setInactivityXEb>:
  setRegisterBit(ADXL345_ACT_INACT_CTL, 5, state); 
}
void Accelerometer::setActivityZ(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 4, state); 
}
void Accelerometer::setInactivityX(bool state) {  
    623e:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 2, state); 
    6240:	67 e2       	ldi	r22, 0x27	; 39
    6242:	42 e0       	ldi	r20, 0x02	; 2
    6244:	50 e0       	ldi	r21, 0x00	; 0
}
    6246:	82 cf       	rjmp	.-252    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006248 <_ZN13Accelerometer12setActivityZEb>:
  setRegisterBit(ADXL345_ACT_INACT_CTL, 6, state); 
}
void Accelerometer::setActivityY(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 5, state); 
}
void Accelerometer::setActivityZ(bool state) {  
    6248:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 4, state); 
    624a:	67 e2       	ldi	r22, 0x27	; 39
    624c:	44 e0       	ldi	r20, 0x04	; 4
    624e:	50 e0       	ldi	r21, 0x00	; 0
}
    6250:	7d cf       	rjmp	.-262    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006252 <_ZN13Accelerometer12setActivityYEb>:
}

void Accelerometer::setActivityX(bool state) {  
  setRegisterBit(ADXL345_ACT_INACT_CTL, 6, state); 
}
void Accelerometer::setActivityY(bool state) {  
    6252:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 5, state); 
    6254:	67 e2       	ldi	r22, 0x27	; 39
    6256:	45 e0       	ldi	r20, 0x05	; 5
    6258:	50 e0       	ldi	r21, 0x00	; 0
}
    625a:	78 cf       	rjmp	.-272    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

0000625c <_ZN13Accelerometer12setActivityXEb>:
}
bool Accelerometer::isInactivityZEnabled() {  
  return getRegisterBit(ADXL345_ACT_INACT_CTL, 0); 
}

void Accelerometer::setActivityX(bool state) {  
    625c:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_ACT_INACT_CTL, 6, state); 
    625e:	67 e2       	ldi	r22, 0x27	; 39
    6260:	46 e0       	ldi	r20, 0x06	; 6
    6262:	50 e0       	ldi	r21, 0x00	; 0
}
    6264:	73 cf       	rjmp	.-282    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006266 <_ZN13Accelerometer13setJustifyBitEb>:
}

// Sets the JUSTIFY bit
// if sets to 1 selects the left justified mode
// if sets to 0 selects right justified mode with sign extension
void Accelerometer::setJustifyBit(bool justifyBit) {
    6266:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_DATA_FORMAT, 2, justifyBit);
    6268:	61 e3       	ldi	r22, 0x31	; 49
    626a:	42 e0       	ldi	r20, 0x02	; 2
    626c:	50 e0       	ldi	r21, 0x00	; 0
}
    626e:	6e cf       	rjmp	.-292    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006270 <_ZN13Accelerometer13setFullResBitEb>:
// Sets the FULL_RES bit
// if set to 1, the device is in full resolution mode, where the output resolution increases with the
//   g range set by the range bits to maintain a 4mg/LSB scal factor
// if set to 0, the device is in 10-bit mode, and the range buts determine the maximum g range
//   and scale factor
void Accelerometer::setFullResBit(bool fullResBit) {
    6270:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_DATA_FORMAT, 3, fullResBit);
    6272:	61 e3       	ldi	r22, 0x31	; 49
    6274:	43 e0       	ldi	r20, 0x03	; 3
    6276:	50 e0       	ldi	r21, 0x00	; 0
}
    6278:	69 cf       	rjmp	.-302    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

0000627a <_ZN13Accelerometer20setInterruptLevelBitEb>:
}

// Sets the INT_INVERT bit
// if set to 0 sets the interrupts to active high
// if set to 1 sets the interrupts to active low
void Accelerometer::setInterruptLevelBit(bool interruptLevelBit) {
    627a:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_DATA_FORMAT, 5, interruptLevelBit);
    627c:	61 e3       	ldi	r22, 0x31	; 49
    627e:	45 e0       	ldi	r20, 0x05	; 5
    6280:	50 e0       	ldi	r21, 0x00	; 0
}
    6282:	64 cf       	rjmp	.-312    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006284 <_ZN13Accelerometer9setSpiBitEb>:
}

// Sets the SPI bit
// if set to 1 it sets the device to 3-wire mode
// if set to 0 it sets the device to 4-wire SPI mode
void Accelerometer::setSpiBit(bool spiBit) {
    6284:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_DATA_FORMAT, 6, spiBit);
    6286:	61 e3       	ldi	r22, 0x31	; 49
    6288:	46 e0       	ldi	r20, 0x06	; 6
    628a:	50 e0       	ldi	r21, 0x00	; 0
}
    628c:	5f cf       	rjmp	.-322    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

0000628e <_ZN13Accelerometer14setSelfTestBitEb>:
}

// Sets the SELF-TEST bit
// if set to 1 it applies a self-test force to the sensor causing a shift in the output data
// if set to 0 it disables the self-test force
void Accelerometer::setSelfTestBit(bool selfTestBit) {
    628e:	26 2f       	mov	r18, r22
  setRegisterBit(ADXL345_DATA_FORMAT, 7, selfTestBit);
    6290:	61 e3       	ldi	r22, 0x31	; 49
    6292:	47 e0       	ldi	r20, 0x07	; 7
    6294:	50 e0       	ldi	r21, 0x00	; 0
}
    6296:	5a cf       	rjmp	.-332    	; 0x614c <_ZN13Accelerometer14setRegisterBitEhib>

00006298 <_ZN13Accelerometer18getInterruptSourceEv>:
    _s = (byte) (r + 6) | (_b & 0B11110000);
    writeTo(DEVICE, ADXL345_BW_RATE, _s);
  }
}

byte Accelerometer::getInterruptSource() {
    6298:	0f 93       	push	r16
    629a:	1f 93       	push	r17
    629c:	df 93       	push	r29
    629e:	cf 93       	push	r28
    62a0:	0f 92       	push	r0
    62a2:	cd b7       	in	r28, 0x3d	; 61
    62a4:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_INT_SOURCE, 1, &_b);
    62a6:	63 e5       	ldi	r22, 0x53	; 83
    62a8:	70 e0       	ldi	r23, 0x00	; 0
    62aa:	40 e3       	ldi	r20, 0x30	; 48
    62ac:	21 e0       	ldi	r18, 0x01	; 1
    62ae:	30 e0       	ldi	r19, 0x00	; 0
    62b0:	8e 01       	movw	r16, r28
    62b2:	0f 5f       	subi	r16, 0xFF	; 255
    62b4:	1f 4f       	sbci	r17, 0xFF	; 255
    62b6:	1c de       	rcall	.-968    	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return _b;
}
    62b8:	89 81       	ldd	r24, Y+1	; 0x01
    62ba:	0f 90       	pop	r0
    62bc:	cf 91       	pop	r28
    62be:	df 91       	pop	r29
    62c0:	1f 91       	pop	r17
    62c2:	0f 91       	pop	r16
    62c4:	08 95       	ret

000062c6 <_ZN13Accelerometer7setRateEf>:
  readFrom(DEVICE, ADXL345_BW_RATE, 1, &_b);
  _b &= 0B00001111;
  return (pow(2,((int) _b)-6)) * 6.25;
}

void Accelerometer::setRate(float rate){
    62c6:	cf 92       	push	r12
    62c8:	df 92       	push	r13
    62ca:	ef 92       	push	r14
    62cc:	ff 92       	push	r15
    62ce:	0f 93       	push	r16
    62d0:	1f 93       	push	r17
    62d2:	df 93       	push	r29
    62d4:	cf 93       	push	r28
    62d6:	0f 92       	push	r0
    62d8:	cd b7       	in	r28, 0x3d	; 61
    62da:	de b7       	in	r29, 0x3e	; 62
    62dc:	6c 01       	movw	r12, r24
  byte _b,_s;
  int v = (int) (rate / 6.25);
    62de:	cb 01       	movw	r24, r22
    62e0:	ba 01       	movw	r22, r20
    62e2:	20 e0       	ldi	r18, 0x00	; 0
    62e4:	30 e0       	ldi	r19, 0x00	; 0
    62e6:	48 ec       	ldi	r20, 0xC8	; 200
    62e8:	50 e4       	ldi	r21, 0x40	; 64
    62ea:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    62ee:	0e 94 88 40 	call	0x8110	; 0x8110 <__fixsfsi>
    62f2:	ee 24       	eor	r14, r14
    62f4:	ff 24       	eor	r15, r15
    62f6:	03 c0       	rjmp	.+6      	; 0x62fe <_ZN13Accelerometer7setRateEf+0x38>
  int r = 0;
  while (v >>= 1)
  {
    r++;
    62f8:	08 94       	sec
    62fa:	e1 1c       	adc	r14, r1
    62fc:	f1 1c       	adc	r15, r1

void Accelerometer::setRate(float rate){
  byte _b,_s;
  int v = (int) (rate / 6.25);
  int r = 0;
  while (v >>= 1)
    62fe:	75 95       	asr	r23
    6300:	67 95       	ror	r22
    6302:	61 15       	cp	r22, r1
    6304:	71 05       	cpc	r23, r1
    6306:	c1 f7       	brne	.-16     	; 0x62f8 <_ZN13Accelerometer7setRateEf+0x32>
  {
    r++;
  }
  if (r <= 9) { 
    6308:	8a e0       	ldi	r24, 0x0A	; 10
    630a:	e8 16       	cp	r14, r24
    630c:	f1 04       	cpc	r15, r1
    630e:	a4 f4       	brge	.+40     	; 0x6338 <_ZN13Accelerometer7setRateEf+0x72>
    readFrom(DEVICE, ADXL345_BW_RATE, 1, &_b);
    6310:	c6 01       	movw	r24, r12
    6312:	63 e5       	ldi	r22, 0x53	; 83
    6314:	70 e0       	ldi	r23, 0x00	; 0
    6316:	4c e2       	ldi	r20, 0x2C	; 44
    6318:	21 e0       	ldi	r18, 0x01	; 1
    631a:	30 e0       	ldi	r19, 0x00	; 0
    631c:	8e 01       	movw	r16, r28
    631e:	0f 5f       	subi	r16, 0xFF	; 255
    6320:	1f 4f       	sbci	r17, 0xFF	; 255
    6322:	e6 dd       	rcall	.-1076   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
    _s = (byte) (r + 6) | (_b & 0B11110000);
    writeTo(DEVICE, ADXL345_BW_RATE, _s);
    6324:	2e 2d       	mov	r18, r14
    6326:	2a 5f       	subi	r18, 0xFA	; 250
    6328:	89 81       	ldd	r24, Y+1	; 0x01
    632a:	80 7f       	andi	r24, 0xF0	; 240
    632c:	28 2b       	or	r18, r24
    632e:	c6 01       	movw	r24, r12
    6330:	63 e5       	ldi	r22, 0x53	; 83
    6332:	70 e0       	ldi	r23, 0x00	; 0
    6334:	4c e2       	ldi	r20, 0x2C	; 44
    6336:	2a dd       	rcall	.-1452   	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
  }
}
    6338:	0f 90       	pop	r0
    633a:	cf 91       	pop	r28
    633c:	df 91       	pop	r29
    633e:	1f 91       	pop	r17
    6340:	0f 91       	pop	r16
    6342:	ff 90       	pop	r15
    6344:	ef 90       	pop	r14
    6346:	df 90       	pop	r13
    6348:	cf 90       	pop	r12
    634a:	08 95       	ret

0000634c <_ZN13Accelerometer7getRateEv>:
}
void Accelerometer::setLowPower(bool state) {  
  setRegisterBit(ADXL345_BW_RATE, 4, state); 
}

float Accelerometer::getRate(){
    634c:	0f 93       	push	r16
    634e:	1f 93       	push	r17
    6350:	df 93       	push	r29
    6352:	cf 93       	push	r28
    6354:	0f 92       	push	r0
    6356:	cd b7       	in	r28, 0x3d	; 61
    6358:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_BW_RATE, 1, &_b);
    635a:	63 e5       	ldi	r22, 0x53	; 83
    635c:	70 e0       	ldi	r23, 0x00	; 0
    635e:	4c e2       	ldi	r20, 0x2C	; 44
    6360:	21 e0       	ldi	r18, 0x01	; 1
    6362:	30 e0       	ldi	r19, 0x00	; 0
    6364:	8e 01       	movw	r16, r28
    6366:	0f 5f       	subi	r16, 0xFF	; 255
    6368:	1f 4f       	sbci	r17, 0xFF	; 255
    636a:	c2 dd       	rcall	.-1148   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  _b &= 0B00001111;
  return (pow(2,((int) _b)-6)) * 6.25;
    636c:	69 81       	ldd	r22, Y+1	; 0x01
    636e:	6f 70       	andi	r22, 0x0F	; 15
    6370:	70 e0       	ldi	r23, 0x00	; 0
    6372:	66 50       	subi	r22, 0x06	; 6
    6374:	70 40       	sbci	r23, 0x00	; 0
    6376:	88 27       	eor	r24, r24
    6378:	77 fd       	sbrc	r23, 7
    637a:	80 95       	com	r24
    637c:	98 2f       	mov	r25, r24
    637e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    6382:	9b 01       	movw	r18, r22
    6384:	ac 01       	movw	r20, r24
    6386:	60 e0       	ldi	r22, 0x00	; 0
    6388:	70 e0       	ldi	r23, 0x00	; 0
    638a:	80 e0       	ldi	r24, 0x00	; 0
    638c:	90 e4       	ldi	r25, 0x40	; 64
    638e:	0e 94 d6 41 	call	0x83ac	; 0x83ac <pow>
    6392:	9b 01       	movw	r18, r22
    6394:	ac 01       	movw	r20, r24
    6396:	ca 01       	movw	r24, r20
    6398:	b9 01       	movw	r22, r18
    639a:	20 e0       	ldi	r18, 0x00	; 0
    639c:	30 e0       	ldi	r19, 0x00	; 0
    639e:	48 ec       	ldi	r20, 0xC8	; 200
    63a0:	50 e4       	ldi	r21, 0x40	; 64
    63a2:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
}
    63a6:	0f 90       	pop	r0
    63a8:	cf 91       	pop	r28
    63aa:	df 91       	pop	r29
    63ac:	1f 91       	pop	r17
    63ae:	0f 91       	pop	r16
    63b0:	08 95       	ret

000063b2 <_ZN13Accelerometer19getFreeFallDurationEv>:
  byte _b = byte (freeFallDuration);
  writeTo(DEVICE, ADXL345_TIME_FF, _b);  
}

// Gets the TIME_FF register.
int Accelerometer::getFreeFallDuration() {
    63b2:	0f 93       	push	r16
    63b4:	1f 93       	push	r17
    63b6:	df 93       	push	r29
    63b8:	cf 93       	push	r28
    63ba:	0f 92       	push	r0
    63bc:	cd b7       	in	r28, 0x3d	; 61
    63be:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_TIME_FF, 1, &_b);  
    63c0:	63 e5       	ldi	r22, 0x53	; 83
    63c2:	70 e0       	ldi	r23, 0x00	; 0
    63c4:	49 e2       	ldi	r20, 0x29	; 41
    63c6:	21 e0       	ldi	r18, 0x01	; 1
    63c8:	30 e0       	ldi	r19, 0x00	; 0
    63ca:	8e 01       	movw	r16, r28
    63cc:	0f 5f       	subi	r16, 0xFF	; 255
    63ce:	1f 4f       	sbci	r17, 0xFF	; 255
    63d0:	8f dd       	rcall	.-1250   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    63d2:	89 81       	ldd	r24, Y+1	; 0x01
    63d4:	90 e0       	ldi	r25, 0x00	; 0
    63d6:	0f 90       	pop	r0
    63d8:	cf 91       	pop	r28
    63da:	df 91       	pop	r29
    63dc:	1f 91       	pop	r17
    63de:	0f 91       	pop	r16
    63e0:	08 95       	ret

000063e2 <_ZN13Accelerometer20getFreeFallThresholdEv>:
  byte _b = byte (freeFallThreshold);
  writeTo(DEVICE, ADXL345_THRESH_FF, _b);  
}

// Gets the THRESH_FF register.
int Accelerometer::getFreeFallThreshold() {
    63e2:	0f 93       	push	r16
    63e4:	1f 93       	push	r17
    63e6:	df 93       	push	r29
    63e8:	cf 93       	push	r28
    63ea:	0f 92       	push	r0
    63ec:	cd b7       	in	r28, 0x3d	; 61
    63ee:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_THRESH_FF, 1, &_b);  
    63f0:	63 e5       	ldi	r22, 0x53	; 83
    63f2:	70 e0       	ldi	r23, 0x00	; 0
    63f4:	48 e2       	ldi	r20, 0x28	; 40
    63f6:	21 e0       	ldi	r18, 0x01	; 1
    63f8:	30 e0       	ldi	r19, 0x00	; 0
    63fa:	8e 01       	movw	r16, r28
    63fc:	0f 5f       	subi	r16, 0xFF	; 255
    63fe:	1f 4f       	sbci	r17, 0xFF	; 255
    6400:	77 dd       	rcall	.-1298   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    6402:	89 81       	ldd	r24, Y+1	; 0x01
    6404:	90 e0       	ldi	r25, 0x00	; 0
    6406:	0f 90       	pop	r0
    6408:	cf 91       	pop	r28
    640a:	df 91       	pop	r29
    640c:	1f 91       	pop	r17
    640e:	0f 91       	pop	r16
    6410:	08 95       	ret

00006412 <_ZN13Accelerometer17getTimeInactivityEv>:
  byte _b = byte (timeInactivity);
  writeTo(DEVICE, ADXL345_TIME_INACT, _b);  
}

// Gets the TIME_INACT register
int Accelerometer::getTimeInactivity() {
    6412:	0f 93       	push	r16
    6414:	1f 93       	push	r17
    6416:	df 93       	push	r29
    6418:	cf 93       	push	r28
    641a:	0f 92       	push	r0
    641c:	cd b7       	in	r28, 0x3d	; 61
    641e:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_TIME_INACT, 1, &_b);  
    6420:	63 e5       	ldi	r22, 0x53	; 83
    6422:	70 e0       	ldi	r23, 0x00	; 0
    6424:	46 e2       	ldi	r20, 0x26	; 38
    6426:	21 e0       	ldi	r18, 0x01	; 1
    6428:	30 e0       	ldi	r19, 0x00	; 0
    642a:	8e 01       	movw	r16, r28
    642c:	0f 5f       	subi	r16, 0xFF	; 255
    642e:	1f 4f       	sbci	r17, 0xFF	; 255
    6430:	5f dd       	rcall	.-1346   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    6432:	89 81       	ldd	r24, Y+1	; 0x01
    6434:	90 e0       	ldi	r25, 0x00	; 0
    6436:	0f 90       	pop	r0
    6438:	cf 91       	pop	r28
    643a:	df 91       	pop	r29
    643c:	1f 91       	pop	r17
    643e:	0f 91       	pop	r16
    6440:	08 95       	ret

00006442 <_ZN13Accelerometer22getInactivityThresholdEv>:
  byte _b = byte (inactivityThreshold);
  writeTo(DEVICE, ADXL345_THRESH_INACT, _b);  
}

// Gets the THRESH_INACT byte
int Accelerometer::getInactivityThreshold() {
    6442:	0f 93       	push	r16
    6444:	1f 93       	push	r17
    6446:	df 93       	push	r29
    6448:	cf 93       	push	r28
    644a:	0f 92       	push	r0
    644c:	cd b7       	in	r28, 0x3d	; 61
    644e:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_THRESH_INACT, 1, &_b);  
    6450:	63 e5       	ldi	r22, 0x53	; 83
    6452:	70 e0       	ldi	r23, 0x00	; 0
    6454:	45 e2       	ldi	r20, 0x25	; 37
    6456:	21 e0       	ldi	r18, 0x01	; 1
    6458:	30 e0       	ldi	r19, 0x00	; 0
    645a:	8e 01       	movw	r16, r28
    645c:	0f 5f       	subi	r16, 0xFF	; 255
    645e:	1f 4f       	sbci	r17, 0xFF	; 255
    6460:	47 dd       	rcall	.-1394   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    6462:	89 81       	ldd	r24, Y+1	; 0x01
    6464:	90 e0       	ldi	r25, 0x00	; 0
    6466:	0f 90       	pop	r0
    6468:	cf 91       	pop	r28
    646a:	df 91       	pop	r29
    646c:	1f 91       	pop	r17
    646e:	0f 91       	pop	r16
    6470:	08 95       	ret

00006472 <_ZN13Accelerometer20getActivityThresholdEv>:
  byte _b = byte (activityThreshold);
  writeTo(DEVICE, ADXL345_THRESH_ACT, _b);  
}

// Gets the THRESH_ACT byte
int Accelerometer::getActivityThreshold() {
    6472:	0f 93       	push	r16
    6474:	1f 93       	push	r17
    6476:	df 93       	push	r29
    6478:	cf 93       	push	r28
    647a:	0f 92       	push	r0
    647c:	cd b7       	in	r28, 0x3d	; 61
    647e:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_THRESH_ACT, 1, &_b);  
    6480:	63 e5       	ldi	r22, 0x53	; 83
    6482:	70 e0       	ldi	r23, 0x00	; 0
    6484:	44 e2       	ldi	r20, 0x24	; 36
    6486:	21 e0       	ldi	r18, 0x01	; 1
    6488:	30 e0       	ldi	r19, 0x00	; 0
    648a:	8e 01       	movw	r16, r28
    648c:	0f 5f       	subi	r16, 0xFF	; 255
    648e:	1f 4f       	sbci	r17, 0xFF	; 255
    6490:	2f dd       	rcall	.-1442   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    6492:	89 81       	ldd	r24, Y+1	; 0x01
    6494:	90 e0       	ldi	r25, 0x00	; 0
    6496:	0f 90       	pop	r0
    6498:	cf 91       	pop	r28
    649a:	df 91       	pop	r29
    649c:	1f 91       	pop	r17
    649e:	0f 91       	pop	r16
    64a0:	08 95       	ret

000064a2 <_ZN13Accelerometer18getDoubleTapWindowEv>:
  byte _b = byte (doubleTapWindow);
  writeTo(DEVICE, ADXL345_WINDOW, _b);  
}

// Gets the Window register
int Accelerometer::getDoubleTapWindow() {
    64a2:	0f 93       	push	r16
    64a4:	1f 93       	push	r17
    64a6:	df 93       	push	r29
    64a8:	cf 93       	push	r28
    64aa:	0f 92       	push	r0
    64ac:	cd b7       	in	r28, 0x3d	; 61
    64ae:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_WINDOW, 1, &_b);  
    64b0:	63 e5       	ldi	r22, 0x53	; 83
    64b2:	70 e0       	ldi	r23, 0x00	; 0
    64b4:	43 e2       	ldi	r20, 0x23	; 35
    64b6:	21 e0       	ldi	r18, 0x01	; 1
    64b8:	30 e0       	ldi	r19, 0x00	; 0
    64ba:	8e 01       	movw	r16, r28
    64bc:	0f 5f       	subi	r16, 0xFF	; 255
    64be:	1f 4f       	sbci	r17, 0xFF	; 255
    64c0:	17 dd       	rcall	.-1490   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    64c2:	89 81       	ldd	r24, Y+1	; 0x01
    64c4:	90 e0       	ldi	r25, 0x00	; 0
    64c6:	0f 90       	pop	r0
    64c8:	cf 91       	pop	r28
    64ca:	df 91       	pop	r29
    64cc:	1f 91       	pop	r17
    64ce:	0f 91       	pop	r16
    64d0:	08 95       	ret

000064d2 <_ZN13Accelerometer19getDoubleTapLatencyEv>:
  byte _b = byte (doubleTapLatency);
  writeTo(DEVICE, ADXL345_LATENT, _b);  
}

// Gets the Latent value
int Accelerometer::getDoubleTapLatency() {
    64d2:	0f 93       	push	r16
    64d4:	1f 93       	push	r17
    64d6:	df 93       	push	r29
    64d8:	cf 93       	push	r28
    64da:	0f 92       	push	r0
    64dc:	cd b7       	in	r28, 0x3d	; 61
    64de:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_LATENT, 1, &_b);  
    64e0:	63 e5       	ldi	r22, 0x53	; 83
    64e2:	70 e0       	ldi	r23, 0x00	; 0
    64e4:	42 e2       	ldi	r20, 0x22	; 34
    64e6:	21 e0       	ldi	r18, 0x01	; 1
    64e8:	30 e0       	ldi	r19, 0x00	; 0
    64ea:	8e 01       	movw	r16, r28
    64ec:	0f 5f       	subi	r16, 0xFF	; 255
    64ee:	1f 4f       	sbci	r17, 0xFF	; 255
    64f0:	ff dc       	rcall	.-1538   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    64f2:	89 81       	ldd	r24, Y+1	; 0x01
    64f4:	90 e0       	ldi	r25, 0x00	; 0
    64f6:	0f 90       	pop	r0
    64f8:	cf 91       	pop	r28
    64fa:	df 91       	pop	r29
    64fc:	1f 91       	pop	r17
    64fe:	0f 91       	pop	r16
    6500:	08 95       	ret

00006502 <_ZN13Accelerometer14getTapDurationEv>:
  byte _b = byte (tapDuration);
  writeTo(DEVICE, ADXL345_DUR, _b);  
}

// Gets the DUR byte
int Accelerometer::getTapDuration() {
    6502:	0f 93       	push	r16
    6504:	1f 93       	push	r17
    6506:	df 93       	push	r29
    6508:	cf 93       	push	r28
    650a:	0f 92       	push	r0
    650c:	cd b7       	in	r28, 0x3d	; 61
    650e:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_DUR, 1, &_b);  
    6510:	63 e5       	ldi	r22, 0x53	; 83
    6512:	70 e0       	ldi	r23, 0x00	; 0
    6514:	41 e2       	ldi	r20, 0x21	; 33
    6516:	21 e0       	ldi	r18, 0x01	; 1
    6518:	30 e0       	ldi	r19, 0x00	; 0
    651a:	8e 01       	movw	r16, r28
    651c:	0f 5f       	subi	r16, 0xFF	; 255
    651e:	1f 4f       	sbci	r17, 0xFF	; 255
    6520:	e7 dc       	rcall	.-1586   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    6522:	89 81       	ldd	r24, Y+1	; 0x01
    6524:	90 e0       	ldi	r25, 0x00	; 0
    6526:	0f 90       	pop	r0
    6528:	cf 91       	pop	r28
    652a:	df 91       	pop	r29
    652c:	1f 91       	pop	r17
    652e:	0f 91       	pop	r16
    6530:	08 95       	ret

00006532 <_ZN13Accelerometer13getAxisOffsetEPiS0_S0_>:
  writeTo(DEVICE, ADXL345_OFSY, byte (y));  
  writeTo(DEVICE, ADXL345_OFSZ, byte (z));  
}

// Gets the OFSX, OFSY and OFSZ bytes
void Accelerometer::getAxisOffset(int* x, int* y, int*z) {
    6532:	6f 92       	push	r6
    6534:	7f 92       	push	r7
    6536:	8f 92       	push	r8
    6538:	9f 92       	push	r9
    653a:	af 92       	push	r10
    653c:	bf 92       	push	r11
    653e:	cf 92       	push	r12
    6540:	df 92       	push	r13
    6542:	ef 92       	push	r14
    6544:	ff 92       	push	r15
    6546:	0f 93       	push	r16
    6548:	1f 93       	push	r17
    654a:	df 93       	push	r29
    654c:	cf 93       	push	r28
    654e:	0f 92       	push	r0
    6550:	cd b7       	in	r28, 0x3d	; 61
    6552:	de b7       	in	r29, 0x3e	; 62
    6554:	6c 01       	movw	r12, r24
    6556:	5b 01       	movw	r10, r22
    6558:	4a 01       	movw	r8, r20
    655a:	39 01       	movw	r6, r18
  byte _b;
  readFrom(DEVICE, ADXL345_OFSX, 1, &_b);  
    655c:	63 e5       	ldi	r22, 0x53	; 83
    655e:	70 e0       	ldi	r23, 0x00	; 0
    6560:	4e e1       	ldi	r20, 0x1E	; 30
    6562:	21 e0       	ldi	r18, 0x01	; 1
    6564:	30 e0       	ldi	r19, 0x00	; 0
    6566:	7e 01       	movw	r14, r28
    6568:	08 94       	sec
    656a:	e1 1c       	adc	r14, r1
    656c:	f1 1c       	adc	r15, r1
    656e:	87 01       	movw	r16, r14
    6570:	bf dc       	rcall	.-1666   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  *x = int (_b);
    6572:	89 81       	ldd	r24, Y+1	; 0x01
    6574:	f5 01       	movw	r30, r10
    6576:	80 83       	st	Z, r24
    6578:	11 82       	std	Z+1, r1	; 0x01
  readFrom(DEVICE, ADXL345_OFSY, 1, &_b);  
    657a:	c6 01       	movw	r24, r12
    657c:	63 e5       	ldi	r22, 0x53	; 83
    657e:	70 e0       	ldi	r23, 0x00	; 0
    6580:	4f e1       	ldi	r20, 0x1F	; 31
    6582:	21 e0       	ldi	r18, 0x01	; 1
    6584:	30 e0       	ldi	r19, 0x00	; 0
    6586:	b4 dc       	rcall	.-1688   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  *y = int (_b);
    6588:	89 81       	ldd	r24, Y+1	; 0x01
    658a:	f4 01       	movw	r30, r8
    658c:	80 83       	st	Z, r24
    658e:	11 82       	std	Z+1, r1	; 0x01
  readFrom(DEVICE, ADXL345_OFSZ, 1, &_b);  
    6590:	c6 01       	movw	r24, r12
    6592:	63 e5       	ldi	r22, 0x53	; 83
    6594:	70 e0       	ldi	r23, 0x00	; 0
    6596:	40 e2       	ldi	r20, 0x20	; 32
    6598:	21 e0       	ldi	r18, 0x01	; 1
    659a:	30 e0       	ldi	r19, 0x00	; 0
    659c:	a9 dc       	rcall	.-1710   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  *z = int (_b);
    659e:	89 81       	ldd	r24, Y+1	; 0x01
    65a0:	f3 01       	movw	r30, r6
    65a2:	80 83       	st	Z, r24
    65a4:	11 82       	std	Z+1, r1	; 0x01
}
    65a6:	0f 90       	pop	r0
    65a8:	cf 91       	pop	r28
    65aa:	df 91       	pop	r29
    65ac:	1f 91       	pop	r17
    65ae:	0f 91       	pop	r16
    65b0:	ff 90       	pop	r15
    65b2:	ef 90       	pop	r14
    65b4:	df 90       	pop	r13
    65b6:	cf 90       	pop	r12
    65b8:	bf 90       	pop	r11
    65ba:	af 90       	pop	r10
    65bc:	9f 90       	pop	r9
    65be:	8f 90       	pop	r8
    65c0:	7f 90       	pop	r7
    65c2:	6f 90       	pop	r6
    65c4:	08 95       	ret

000065c6 <_ZN13Accelerometer15getTapThresholdEv>:
}

// Gets the THRESH_TAP byte value
// return value is comprised between 0 and 255
// the scale factor is 62.5 mg/LSB
int Accelerometer::getTapThreshold() {
    65c6:	0f 93       	push	r16
    65c8:	1f 93       	push	r17
    65ca:	df 93       	push	r29
    65cc:	cf 93       	push	r28
    65ce:	0f 92       	push	r0
    65d0:	cd b7       	in	r28, 0x3d	; 61
    65d2:	de b7       	in	r29, 0x3e	; 62
  byte _b;
  readFrom(DEVICE, ADXL345_THRESH_TAP, 1, &_b);  
    65d4:	63 e5       	ldi	r22, 0x53	; 83
    65d6:	70 e0       	ldi	r23, 0x00	; 0
    65d8:	4d e1       	ldi	r20, 0x1D	; 29
    65da:	21 e0       	ldi	r18, 0x01	; 1
    65dc:	30 e0       	ldi	r19, 0x00	; 0
    65de:	8e 01       	movw	r16, r28
    65e0:	0f 5f       	subi	r16, 0xFF	; 255
    65e2:	1f 4f       	sbci	r17, 0xFF	; 255
    65e4:	85 dc       	rcall	.-1782   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  return int (_b);
}
    65e6:	89 81       	ldd	r24, Y+1	; 0x01
    65e8:	90 e0       	ldi	r25, 0x00	; 0
    65ea:	0f 90       	pop	r0
    65ec:	cf 91       	pop	r28
    65ee:	df 91       	pop	r29
    65f0:	1f 91       	pop	r17
    65f2:	0f 91       	pop	r16
    65f4:	08 95       	ret

000065f6 <_ZN13Accelerometer15setRangeSettingEi>:
  readFrom(DEVICE, ADXL345_DATA_FORMAT, 1, &_b);
  *rangeSetting = _b & 0B00000011;
}

// Sets the range setting, possible values are: 2, 4, 8, 16
void Accelerometer::setRangeSetting(int val) {
    65f6:	cf 92       	push	r12
    65f8:	df 92       	push	r13
    65fa:	ff 92       	push	r15
    65fc:	0f 93       	push	r16
    65fe:	1f 93       	push	r17
    6600:	df 93       	push	r29
    6602:	cf 93       	push	r28
    6604:	0f 92       	push	r0
    6606:	cd b7       	in	r28, 0x3d	; 61
    6608:	de b7       	in	r29, 0x3e	; 62
    660a:	6c 01       	movw	r12, r24
  byte _s;
  byte _b;

  switch (val) {
    660c:	68 30       	cpi	r22, 0x08	; 8
    660e:	71 05       	cpc	r23, r1
    6610:	59 f0       	breq	.+22     	; 0x6628 <_ZN13Accelerometer15setRangeSettingEi+0x32>
    6612:	60 31       	cpi	r22, 0x10	; 16
    6614:	71 05       	cpc	r23, r1
    6616:	59 f0       	breq	.+22     	; 0x662e <_ZN13Accelerometer15setRangeSettingEi+0x38>
    6618:	64 30       	cpi	r22, 0x04	; 4
    661a:	71 05       	cpc	r23, r1
    661c:	19 f4       	brne	.+6      	; 0x6624 <_ZN13Accelerometer15setRangeSettingEi+0x2e>
    661e:	ff 24       	eor	r15, r15
    6620:	f3 94       	inc	r15
    6622:	07 c0       	rjmp	.+14     	; 0x6632 <_ZN13Accelerometer15setRangeSettingEi+0x3c>
    6624:	ff 24       	eor	r15, r15
    6626:	05 c0       	rjmp	.+10     	; 0x6632 <_ZN13Accelerometer15setRangeSettingEi+0x3c>
    6628:	32 e0       	ldi	r19, 0x02	; 2
    662a:	f3 2e       	mov	r15, r19
    662c:	02 c0       	rjmp	.+4      	; 0x6632 <_ZN13Accelerometer15setRangeSettingEi+0x3c>
  case 4:  
    _s = 0B00000001;
    break;
  case 8:  
    _s = 0B00000010;
    break;
    662e:	23 e0       	ldi	r18, 0x03	; 3
    6630:	f2 2e       	mov	r15, r18
    _s = 0B00000011;
    break;
  default: 
    _s = 0B00000000;
  }
  readFrom(DEVICE, ADXL345_DATA_FORMAT, 1, &_b);
    6632:	c6 01       	movw	r24, r12
    6634:	63 e5       	ldi	r22, 0x53	; 83
    6636:	70 e0       	ldi	r23, 0x00	; 0
    6638:	41 e3       	ldi	r20, 0x31	; 49
    663a:	21 e0       	ldi	r18, 0x01	; 1
    663c:	30 e0       	ldi	r19, 0x00	; 0
    663e:	8e 01       	movw	r16, r28
    6640:	0f 5f       	subi	r16, 0xFF	; 255
    6642:	1f 4f       	sbci	r17, 0xFF	; 255
    6644:	55 dc       	rcall	.-1878   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  _s |= (_b & 0B11101100);
    6646:	89 81       	ldd	r24, Y+1	; 0x01
    6648:	8c 7e       	andi	r24, 0xEC	; 236
    664a:	f8 2a       	or	r15, r24
  writeTo(DEVICE, ADXL345_DATA_FORMAT, _s);
    664c:	c6 01       	movw	r24, r12
    664e:	63 e5       	ldi	r22, 0x53	; 83
    6650:	70 e0       	ldi	r23, 0x00	; 0
    6652:	41 e3       	ldi	r20, 0x31	; 49
    6654:	2f 2d       	mov	r18, r15
    6656:	9a db       	rcall	.-2252   	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
}
    6658:	0f 90       	pop	r0
    665a:	cf 91       	pop	r28
    665c:	df 91       	pop	r29
    665e:	1f 91       	pop	r17
    6660:	0f 91       	pop	r16
    6662:	ff 90       	pop	r15
    6664:	df 90       	pop	r13
    6666:	cf 90       	pop	r12
    6668:	08 95       	ret

0000666a <_ZN13Accelerometer15getRangeSettingEPh>:
  Wire.endTransmission();         // end transmission
}

// Gets the range setting and return it into rangeSetting
// it can be 2, 4, 8 or 16
void Accelerometer::getRangeSetting(byte* rangeSetting) {
    666a:	ef 92       	push	r14
    666c:	ff 92       	push	r15
    666e:	0f 93       	push	r16
    6670:	1f 93       	push	r17
    6672:	df 93       	push	r29
    6674:	cf 93       	push	r28
    6676:	0f 92       	push	r0
    6678:	cd b7       	in	r28, 0x3d	; 61
    667a:	de b7       	in	r29, 0x3e	; 62
    667c:	7b 01       	movw	r14, r22
  byte _b;
  readFrom(DEVICE, ADXL345_DATA_FORMAT, 1, &_b);
    667e:	63 e5       	ldi	r22, 0x53	; 83
    6680:	70 e0       	ldi	r23, 0x00	; 0
    6682:	41 e3       	ldi	r20, 0x31	; 49
    6684:	21 e0       	ldi	r18, 0x01	; 1
    6686:	30 e0       	ldi	r19, 0x00	; 0
    6688:	8e 01       	movw	r16, r28
    668a:	0f 5f       	subi	r16, 0xFF	; 255
    668c:	1f 4f       	sbci	r17, 0xFF	; 255
    668e:	30 dc       	rcall	.-1952   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>
  *rangeSetting = _b & 0B00000011;
    6690:	89 81       	ldd	r24, Y+1	; 0x01
    6692:	83 70       	andi	r24, 0x03	; 3
    6694:	f7 01       	movw	r30, r14
    6696:	80 83       	st	Z, r24
}
    6698:	0f 90       	pop	r0
    669a:	cf 91       	pop	r28
    669c:	df 91       	pop	r29
    669e:	1f 91       	pop	r17
    66a0:	0f 91       	pop	r16
    66a2:	ff 90       	pop	r15
    66a4:	ef 90       	pop	r14
    66a6:	08 95       	ret

000066a8 <_ZN13Accelerometer9readAccelEPiS0_S0_>:
  writeTo(DEVICE, ADXL345_POWER_CTL, 16);
  writeTo(DEVICE, ADXL345_POWER_CTL, 8); 
}

// Reads the acceleration into three variable x, y and z
void Accelerometer::readAccel(int* x, int* y, int* z) {
    66a8:	8f 92       	push	r8
    66aa:	9f 92       	push	r9
    66ac:	af 92       	push	r10
    66ae:	bf 92       	push	r11
    66b0:	cf 92       	push	r12
    66b2:	df 92       	push	r13
    66b4:	ef 92       	push	r14
    66b6:	ff 92       	push	r15
    66b8:	0f 93       	push	r16
    66ba:	1f 93       	push	r17
    66bc:	7c 01       	movw	r14, r24
    66be:	6b 01       	movw	r12, r22
    66c0:	5a 01       	movw	r10, r20
    66c2:	49 01       	movw	r8, r18
  readFrom(DEVICE, ADXL345_DATAX0, TO_READ, _buff); //read the acceleration data from the ADXL345
    66c4:	63 e5       	ldi	r22, 0x53	; 83
    66c6:	70 e0       	ldi	r23, 0x00	; 0
    66c8:	42 e3       	ldi	r20, 0x32	; 50
    66ca:	26 e0       	ldi	r18, 0x06	; 6
    66cc:	30 e0       	ldi	r19, 0x00	; 0
    66ce:	87 01       	movw	r16, r14
    66d0:	0f dc       	rcall	.-2018   	; 0x5ef0 <_ZN13Accelerometer8readFromEihiPh>

  // each axis reading comes in 10 bit resolution, ie 2 bytes.  Least Significat Byte first!!
  // thus we are converting both bytes in to one int
  *x = (((int)_buff[1]) << 8) | _buff[0];   
    66d2:	f7 01       	movw	r30, r14
    66d4:	91 81       	ldd	r25, Z+1	; 0x01
    66d6:	80 e0       	ldi	r24, 0x00	; 0
    66d8:	20 81       	ld	r18, Z
    66da:	30 e0       	ldi	r19, 0x00	; 0
    66dc:	82 2b       	or	r24, r18
    66de:	93 2b       	or	r25, r19
    66e0:	f6 01       	movw	r30, r12
    66e2:	91 83       	std	Z+1, r25	; 0x01
    66e4:	80 83       	st	Z, r24
  *y = (((int)_buff[3]) << 8) | _buff[2];
    66e6:	f7 01       	movw	r30, r14
    66e8:	93 81       	ldd	r25, Z+3	; 0x03
    66ea:	80 e0       	ldi	r24, 0x00	; 0
    66ec:	22 81       	ldd	r18, Z+2	; 0x02
    66ee:	30 e0       	ldi	r19, 0x00	; 0
    66f0:	82 2b       	or	r24, r18
    66f2:	93 2b       	or	r25, r19
    66f4:	f5 01       	movw	r30, r10
    66f6:	91 83       	std	Z+1, r25	; 0x01
    66f8:	80 83       	st	Z, r24
  *z = (((int)_buff[5]) << 8) | _buff[4];
    66fa:	f7 01       	movw	r30, r14
    66fc:	95 81       	ldd	r25, Z+5	; 0x05
    66fe:	80 e0       	ldi	r24, 0x00	; 0
    6700:	24 81       	ldd	r18, Z+4	; 0x04
    6702:	30 e0       	ldi	r19, 0x00	; 0
    6704:	82 2b       	or	r24, r18
    6706:	93 2b       	or	r25, r19
    6708:	f4 01       	movw	r30, r8
    670a:	91 83       	std	Z+1, r25	; 0x01
    670c:	80 83       	st	Z, r24
}
    670e:	1f 91       	pop	r17
    6710:	0f 91       	pop	r16
    6712:	ff 90       	pop	r15
    6714:	ef 90       	pop	r14
    6716:	df 90       	pop	r13
    6718:	cf 90       	pop	r12
    671a:	bf 90       	pop	r11
    671c:	af 90       	pop	r10
    671e:	9f 90       	pop	r9
    6720:	8f 90       	pop	r8
    6722:	08 95       	ret

00006724 <_ZN13Accelerometer7powerOnEv>:

Accelerometer::Accelerometer() {

}

void Accelerometer::powerOn() {
    6724:	0f 93       	push	r16
    6726:	1f 93       	push	r17
    6728:	8c 01       	movw	r16, r24
  Wire.begin();        // join i2c bus (address optional for master)
    672a:	80 e2       	ldi	r24, 0x20	; 32
    672c:	99 e0       	ldi	r25, 0x09	; 9
    672e:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <_ZN7WireI2C5beginEv>
  //Turning on the ADXL345
  writeTo(DEVICE, ADXL345_POWER_CTL, 0);      
    6732:	c8 01       	movw	r24, r16
    6734:	63 e5       	ldi	r22, 0x53	; 83
    6736:	70 e0       	ldi	r23, 0x00	; 0
    6738:	4d e2       	ldi	r20, 0x2D	; 45
    673a:	20 e0       	ldi	r18, 0x00	; 0
    673c:	27 db       	rcall	.-2482   	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
  writeTo(DEVICE, ADXL345_POWER_CTL, 16);
    673e:	c8 01       	movw	r24, r16
    6740:	63 e5       	ldi	r22, 0x53	; 83
    6742:	70 e0       	ldi	r23, 0x00	; 0
    6744:	4d e2       	ldi	r20, 0x2D	; 45
    6746:	20 e1       	ldi	r18, 0x10	; 16
    6748:	21 db       	rcall	.-2494   	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
  writeTo(DEVICE, ADXL345_POWER_CTL, 8); 
    674a:	c8 01       	movw	r24, r16
    674c:	63 e5       	ldi	r22, 0x53	; 83
    674e:	70 e0       	ldi	r23, 0x00	; 0
    6750:	4d e2       	ldi	r20, 0x2D	; 45
    6752:	28 e0       	ldi	r18, 0x08	; 8
    6754:	1b db       	rcall	.-2506   	; 0x5d8c <_ZN13Accelerometer7writeToEihh>
}
    6756:	1f 91       	pop	r17
    6758:	0f 91       	pop	r16
    675a:	08 95       	ret

0000675c <_ZN7ITG320010getDevAddrEv>:

byte ITG3200::getDevAddr() {
  /*readmem(WHO_AM_I, 1, &_buff[0]); 
  return _buff[0];  */
  return _dev_address;
}
    675c:	fc 01       	movw	r30, r24
    675e:	82 89       	ldd	r24, Z+18	; 0x12
    6760:	08 95       	ret

00006762 <_ZN7ITG320014setScaleFactorEfffb>:

void ITG3200::readGyroRaw( int *_GyroXYZ){
  readGyroRaw(_GyroXYZ, _GyroXYZ+1, _GyroXYZ+2);
}

void ITG3200::setScaleFactor(float _Xcoeff, float _Ycoeff, float _Zcoeff, bool _Radians) { 
    6762:	2f 92       	push	r2
    6764:	3f 92       	push	r3
    6766:	4f 92       	push	r4
    6768:	5f 92       	push	r5
    676a:	6f 92       	push	r6
    676c:	7f 92       	push	r7
    676e:	8f 92       	push	r8
    6770:	9f 92       	push	r9
    6772:	af 92       	push	r10
    6774:	cf 92       	push	r12
    6776:	df 92       	push	r13
    6778:	ef 92       	push	r14
    677a:	ff 92       	push	r15
    677c:	0f 93       	push	r16
    677e:	1f 93       	push	r17
    6780:	cf 93       	push	r28
    6782:	df 93       	push	r29
    6784:	ec 01       	movw	r28, r24
    6786:	38 01       	movw	r6, r16
    6788:	49 01       	movw	r8, r18
  scalefactor[0] = 14.375 * _Xcoeff;   
    678a:	cb 01       	movw	r24, r22
    678c:	ba 01       	movw	r22, r20
    678e:	20 e0       	ldi	r18, 0x00	; 0
    6790:	30 e0       	ldi	r19, 0x00	; 0
    6792:	46 e6       	ldi	r20, 0x66	; 102
    6794:	51 e4       	ldi	r21, 0x41	; 65
    6796:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    679a:	1b 01       	movw	r2, r22
    679c:	2c 01       	movw	r4, r24
    679e:	68 83       	st	Y, r22
    67a0:	79 83       	std	Y+1, r23	; 0x01
    67a2:	8a 83       	std	Y+2, r24	; 0x02
    67a4:	9b 83       	std	Y+3, r25	; 0x03
  scalefactor[1] = 14.375 * _Ycoeff;
    67a6:	c4 01       	movw	r24, r8
    67a8:	b3 01       	movw	r22, r6
    67aa:	20 e0       	ldi	r18, 0x00	; 0
    67ac:	30 e0       	ldi	r19, 0x00	; 0
    67ae:	46 e6       	ldi	r20, 0x66	; 102
    67b0:	51 e4       	ldi	r21, 0x41	; 65
    67b2:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    67b6:	3b 01       	movw	r6, r22
    67b8:	4c 01       	movw	r8, r24
    67ba:	6c 83       	std	Y+4, r22	; 0x04
    67bc:	7d 83       	std	Y+5, r23	; 0x05
    67be:	8e 83       	std	Y+6, r24	; 0x06
    67c0:	9f 83       	std	Y+7, r25	; 0x07
  scalefactor[2] = 14.375 * _Zcoeff;    
    67c2:	c7 01       	movw	r24, r14
    67c4:	b6 01       	movw	r22, r12
    67c6:	20 e0       	ldi	r18, 0x00	; 0
    67c8:	30 e0       	ldi	r19, 0x00	; 0
    67ca:	46 e6       	ldi	r20, 0x66	; 102
    67cc:	51 e4       	ldi	r21, 0x41	; 65
    67ce:	0e 94 73 41 	call	0x82e6	; 0x82e6 <__mulsf3>
    67d2:	7b 01       	movw	r14, r22
    67d4:	8c 01       	movw	r16, r24
    67d6:	68 87       	std	Y+8, r22	; 0x08
    67d8:	79 87       	std	Y+9, r23	; 0x09
    67da:	8a 87       	std	Y+10, r24	; 0x0a
    67dc:	9b 87       	std	Y+11, r25	; 0x0b
    
  if (_Radians){
    67de:	aa 20       	and	r10, r10
    67e0:	21 f1       	breq	.+72     	; 0x682a <_ZN7ITG320014setScaleFactorEfffb+0xc8>
    scalefactor[0] /= 0.0174532925;//0.0174532925 = PI/180
    67e2:	c2 01       	movw	r24, r4
    67e4:	b1 01       	movw	r22, r2
    67e6:	25 e3       	ldi	r18, 0x35	; 53
    67e8:	3a ef       	ldi	r19, 0xFA	; 250
    67ea:	4e e8       	ldi	r20, 0x8E	; 142
    67ec:	5c e3       	ldi	r21, 0x3C	; 60
    67ee:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    67f2:	68 83       	st	Y, r22
    67f4:	79 83       	std	Y+1, r23	; 0x01
    67f6:	8a 83       	std	Y+2, r24	; 0x02
    67f8:	9b 83       	std	Y+3, r25	; 0x03
    scalefactor[1] /= 0.0174532925;
    67fa:	c4 01       	movw	r24, r8
    67fc:	b3 01       	movw	r22, r6
    67fe:	25 e3       	ldi	r18, 0x35	; 53
    6800:	3a ef       	ldi	r19, 0xFA	; 250
    6802:	4e e8       	ldi	r20, 0x8E	; 142
    6804:	5c e3       	ldi	r21, 0x3C	; 60
    6806:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    680a:	6c 83       	std	Y+4, r22	; 0x04
    680c:	7d 83       	std	Y+5, r23	; 0x05
    680e:	8e 83       	std	Y+6, r24	; 0x06
    6810:	9f 83       	std	Y+7, r25	; 0x07
    scalefactor[2] /= 0.0174532925;
    6812:	c8 01       	movw	r24, r16
    6814:	b7 01       	movw	r22, r14
    6816:	25 e3       	ldi	r18, 0x35	; 53
    6818:	3a ef       	ldi	r19, 0xFA	; 250
    681a:	4e e8       	ldi	r20, 0x8E	; 142
    681c:	5c e3       	ldi	r21, 0x3C	; 60
    681e:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    6822:	68 87       	std	Y+8, r22	; 0x08
    6824:	79 87       	std	Y+9, r23	; 0x09
    6826:	8a 87       	std	Y+10, r24	; 0x0a
    6828:	9b 87       	std	Y+11, r25	; 0x0b
  }
}
    682a:	df 91       	pop	r29
    682c:	cf 91       	pop	r28
    682e:	1f 91       	pop	r17
    6830:	0f 91       	pop	r16
    6832:	ff 90       	pop	r15
    6834:	ef 90       	pop	r14
    6836:	df 90       	pop	r13
    6838:	cf 90       	pop	r12
    683a:	af 90       	pop	r10
    683c:	9f 90       	pop	r9
    683e:	8f 90       	pop	r8
    6840:	7f 90       	pop	r7
    6842:	6f 90       	pop	r6
    6844:	5f 90       	pop	r5
    6846:	4f 90       	pop	r4
    6848:	3f 90       	pop	r3
    684a:	2f 90       	pop	r2
    684c:	08 95       	ret

0000684e <_ZN7ITG3200C1Ev>:

#ifndef USE_LUFA
    #include <Wire.h>
#endif

ITG3200::ITG3200() {
    684e:	af 92       	push	r10
    6850:	cf 92       	push	r12
    6852:	df 92       	push	r13
    6854:	ef 92       	push	r14
    6856:	ff 92       	push	r15
    6858:	0f 93       	push	r16
    685a:	1f 93       	push	r17
    685c:	fc 01       	movw	r30, r24
    scalefactor[2] /= 0.0174532925;
  }
}

void ITG3200::setOffsets(int _Xoffset, int _Yoffset, int _Zoffset) {
  offsets[0] = _Xoffset;
    685e:	15 86       	std	Z+13, r1	; 0x0d
    6860:	14 86       	std	Z+12, r1	; 0x0c
  offsets[1] = _Yoffset;
    6862:	17 86       	std	Z+15, r1	; 0x0f
    6864:	16 86       	std	Z+14, r1	; 0x0e
  offsets[2] = _Zoffset;
    6866:	11 8a       	std	Z+17, r1	; 0x11
    6868:	10 8a       	std	Z+16, r1	; 0x10
    #include <Wire.h>
#endif

ITG3200::ITG3200() {
  setOffsets(0,0,0);
  setScaleFactor(1.0, 1.0, 1.0, false);  // true to change readGyro output to radians
    686a:	40 e0       	ldi	r20, 0x00	; 0
    686c:	50 e0       	ldi	r21, 0x00	; 0
    686e:	60 e8       	ldi	r22, 0x80	; 128
    6870:	7f e3       	ldi	r23, 0x3F	; 63
    6872:	8a 01       	movw	r16, r20
    6874:	9b 01       	movw	r18, r22
    6876:	6a 01       	movw	r12, r20
    6878:	7b 01       	movw	r14, r22
    687a:	aa 24       	eor	r10, r10
    687c:	72 df       	rcall	.-284    	; 0x6762 <_ZN7ITG320014setScaleFactorEfffb>
  //Wire.begin();       //Normally this code is called from setup() at user code
                        //but some people reported that joining I2C bus earlier
                        //apparently solved problems with master/slave conditions.
                        //Uncomment if needed.
}
    687e:	1f 91       	pop	r17
    6880:	0f 91       	pop	r16
    6882:	ff 90       	pop	r15
    6884:	ef 90       	pop	r14
    6886:	df 90       	pop	r13
    6888:	cf 90       	pop	r12
    688a:	af 90       	pop	r10
    688c:	08 95       	ret

0000688e <_ZN7ITG3200C2Ev>:

#ifndef USE_LUFA
    #include <Wire.h>
#endif

ITG3200::ITG3200() {
    688e:	af 92       	push	r10
    6890:	cf 92       	push	r12
    6892:	df 92       	push	r13
    6894:	ef 92       	push	r14
    6896:	ff 92       	push	r15
    6898:	0f 93       	push	r16
    689a:	1f 93       	push	r17
    689c:	fc 01       	movw	r30, r24
    scalefactor[2] /= 0.0174532925;
  }
}

void ITG3200::setOffsets(int _Xoffset, int _Yoffset, int _Zoffset) {
  offsets[0] = _Xoffset;
    689e:	15 86       	std	Z+13, r1	; 0x0d
    68a0:	14 86       	std	Z+12, r1	; 0x0c
  offsets[1] = _Yoffset;
    68a2:	17 86       	std	Z+15, r1	; 0x0f
    68a4:	16 86       	std	Z+14, r1	; 0x0e
  offsets[2] = _Zoffset;
    68a6:	11 8a       	std	Z+17, r1	; 0x11
    68a8:	10 8a       	std	Z+16, r1	; 0x10
    #include <Wire.h>
#endif

ITG3200::ITG3200() {
  setOffsets(0,0,0);
  setScaleFactor(1.0, 1.0, 1.0, false);  // true to change readGyro output to radians
    68aa:	40 e0       	ldi	r20, 0x00	; 0
    68ac:	50 e0       	ldi	r21, 0x00	; 0
    68ae:	60 e8       	ldi	r22, 0x80	; 128
    68b0:	7f e3       	ldi	r23, 0x3F	; 63
    68b2:	8a 01       	movw	r16, r20
    68b4:	9b 01       	movw	r18, r22
    68b6:	6a 01       	movw	r12, r20
    68b8:	7b 01       	movw	r14, r22
    68ba:	aa 24       	eor	r10, r10
    68bc:	52 df       	rcall	.-348    	; 0x6762 <_ZN7ITG320014setScaleFactorEfffb>
  //Wire.begin();       //Normally this code is called from setup() at user code
                        //but some people reported that joining I2C bus earlier
                        //apparently solved problems with master/slave conditions.
                        //Uncomment if needed.
}
    68be:	1f 91       	pop	r17
    68c0:	0f 91       	pop	r16
    68c2:	ff 90       	pop	r15
    68c4:	ef 90       	pop	r14
    68c6:	df 90       	pop	r13
    68c8:	cf 90       	pop	r12
    68ca:	af 90       	pop	r10
    68cc:	08 95       	ret

000068ce <_ZN7ITG320010setOffsetsEiii>:
    scalefactor[1] /= 0.0174532925;
    scalefactor[2] /= 0.0174532925;
  }
}

void ITG3200::setOffsets(int _Xoffset, int _Yoffset, int _Zoffset) {
    68ce:	fc 01       	movw	r30, r24
  offsets[0] = _Xoffset;
    68d0:	75 87       	std	Z+13, r23	; 0x0d
    68d2:	64 87       	std	Z+12, r22	; 0x0c
  offsets[1] = _Yoffset;
    68d4:	57 87       	std	Z+15, r21	; 0x0f
    68d6:	46 87       	std	Z+14, r20	; 0x0e
  offsets[2] = _Zoffset;
    68d8:	31 8b       	std	Z+17, r19	; 0x11
    68da:	20 8b       	std	Z+16, r18	; 0x10
}
    68dc:	08 95       	ret

000068de <_ZN7ITG32008writememEhh>:
void ITG3200::setClockSource(byte _CLKsource) {   
  readmem(PWR_MGM, 1, &_buff[0]);
  writemem(PWR_MGM, ((_buff[0] & ~PWRMGM_CLK_SEL) | _CLKsource)); 
}

void ITG3200::writemem(uint8_t _addr, uint8_t _val) {
    68de:	ef 92       	push	r14
    68e0:	ff 92       	push	r15
    68e2:	0f 93       	push	r16
    68e4:	1f 93       	push	r17
    68e6:	f6 2e       	mov	r15, r22
    68e8:	e4 2e       	mov	r14, r20
  Wire.beginTransmission(_dev_address);   // start transmission to device 
    68ea:	00 e2       	ldi	r16, 0x20	; 32
    68ec:	19 e0       	ldi	r17, 0x09	; 9
    68ee:	fc 01       	movw	r30, r24
    68f0:	62 89       	ldd	r22, Z+18	; 0x12
    68f2:	c8 01       	movw	r24, r16
    68f4:	70 e0       	ldi	r23, 0x00	; 0
    68f6:	0e 94 f5 2a 	call	0x55ea	; 0x55ea <_ZN7WireI2C17beginTransmissionEi>
  Wire.send(_addr); // send register address
    68fa:	c8 01       	movw	r24, r16
    68fc:	6f 2d       	mov	r22, r15
    68fe:	0e 94 f7 2a 	call	0x55ee	; 0x55ee <_ZN7WireI2C4sendEh>
  Wire.send(_val); // send value to write
    6902:	c8 01       	movw	r24, r16
    6904:	6e 2d       	mov	r22, r14
    6906:	0e 94 f7 2a 	call	0x55ee	; 0x55ee <_ZN7WireI2C4sendEh>
  Wire.endTransmission(); // end transmission
    690a:	c8 01       	movw	r24, r16
    690c:	0e 94 f6 2a 	call	0x55ec	; 0x55ec <_ZN7WireI2C15endTransmissionEv>
}
    6910:	1f 91       	pop	r17
    6912:	0f 91       	pop	r16
    6914:	ff 90       	pop	r15
    6916:	ef 90       	pop	r14
    6918:	08 95       	ret

0000691a <_ZN7ITG320016setSampleRateDivEh>:
byte ITG3200::getSampleRateDiv() {
  readmem(SMPLRT_DIV, 1, &_buff[0]);
  return _buff[0];
}

void ITG3200::setSampleRateDiv(byte _SampleRate) {
    691a:	46 2f       	mov	r20, r22
  writemem(SMPLRT_DIV, _SampleRate);
    691c:	65 e1       	ldi	r22, 0x15	; 21
}
    691e:	df cf       	rjmp	.-66     	; 0x68de <_ZN7ITG32008writememEhh>

00006920 <_ZN7ITG320010setDevAddrEj>:
  /*readmem(WHO_AM_I, 1, &_buff[0]); 
  return _buff[0];  */
  return _dev_address;
}

void ITG3200::setDevAddr(unsigned int  _addr) {
    6920:	ff 92       	push	r15
    6922:	0f 93       	push	r16
    6924:	1f 93       	push	r17
    6926:	8c 01       	movw	r16, r24
    6928:	f6 2e       	mov	r15, r22
  writemem(WHO_AM_I, _addr); 
    692a:	60 e0       	ldi	r22, 0x00	; 0
    692c:	4f 2d       	mov	r20, r15
    692e:	d7 df       	rcall	.-82     	; 0x68de <_ZN7ITG32008writememEhh>
  _dev_address = _addr;
    6930:	f8 01       	movw	r30, r16
    6932:	f2 8a       	std	Z+18, r15	; 0x12
}
    6934:	1f 91       	pop	r17
    6936:	0f 91       	pop	r16
    6938:	ff 90       	pop	r15
    693a:	08 95       	ret

0000693c <_ZN7ITG32007readmemEhhPh>:
  Wire.send(_addr); // send register address
  Wire.send(_val); // send value to write
  Wire.endTransmission(); // end transmission
}

void ITG3200::readmem(uint8_t _addr, uint8_t _nbytes, uint8_t __buff[]) {
    693c:	ef 92       	push	r14
    693e:	ff 92       	push	r15
    6940:	0f 93       	push	r16
    6942:	1f 93       	push	r17
    6944:	cf 93       	push	r28
    6946:	df 93       	push	r29
    6948:	8c 01       	movw	r16, r24
    694a:	f6 2e       	mov	r15, r22
    694c:	e4 2e       	mov	r14, r20
    694e:	e9 01       	movw	r28, r18
  Wire.beginTransmission(_dev_address); // start transmission to device 
    6950:	fc 01       	movw	r30, r24
    6952:	62 89       	ldd	r22, Z+18	; 0x12
    6954:	80 e2       	ldi	r24, 0x20	; 32
    6956:	99 e0       	ldi	r25, 0x09	; 9
    6958:	70 e0       	ldi	r23, 0x00	; 0
    695a:	0e 94 f5 2a 	call	0x55ea	; 0x55ea <_ZN7WireI2C17beginTransmissionEi>
  Wire.send(_addr); // sends register address to read from
    695e:	80 e2       	ldi	r24, 0x20	; 32
    6960:	99 e0       	ldi	r25, 0x09	; 9
    6962:	6f 2d       	mov	r22, r15
    6964:	0e 94 f7 2a 	call	0x55ee	; 0x55ee <_ZN7WireI2C4sendEh>
  Wire.endTransmission(); // end transmission
    6968:	80 e2       	ldi	r24, 0x20	; 32
    696a:	99 e0       	ldi	r25, 0x09	; 9
    696c:	0e 94 f6 2a 	call	0x55ec	; 0x55ec <_ZN7WireI2C15endTransmissionEv>
  
  Wire.beginTransmission(_dev_address); // start transmission to device 
    6970:	f8 01       	movw	r30, r16
    6972:	62 89       	ldd	r22, Z+18	; 0x12
    6974:	80 e2       	ldi	r24, 0x20	; 32
    6976:	99 e0       	ldi	r25, 0x09	; 9
    6978:	70 e0       	ldi	r23, 0x00	; 0
    697a:	0e 94 f5 2a 	call	0x55ea	; 0x55ea <_ZN7WireI2C17beginTransmissionEi>
  Wire.requestFrom(_dev_address, _nbytes);// send data n-bytes read
    697e:	f8 01       	movw	r30, r16
    6980:	62 89       	ldd	r22, Z+18	; 0x12
    6982:	80 e2       	ldi	r24, 0x20	; 32
    6984:	99 e0       	ldi	r25, 0x09	; 9
    6986:	70 e0       	ldi	r23, 0x00	; 0
    6988:	4e 2d       	mov	r20, r14
    698a:	50 e0       	ldi	r21, 0x00	; 0
    698c:	0e 94 fa 2a 	call	0x55f4	; 0x55f4 <_ZN7WireI2C11requestFromEii>
    6990:	00 e0       	ldi	r16, 0x00	; 0
    6992:	09 c0       	rjmp	.+18     	; 0x69a6 <_ZN7ITG32007readmemEhhPh+0x6a>
  uint8_t i = 0; 
  while (Wire.available()) {
    __buff[i] = Wire.receive(); // receive DATA
    6994:	80 e2       	ldi	r24, 0x20	; 32
    6996:	99 e0       	ldi	r25, 0x09	; 9
    6998:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <_ZN7WireI2C7receiveEv>
    699c:	fe 01       	movw	r30, r28
    699e:	e0 0f       	add	r30, r16
    69a0:	f1 1d       	adc	r31, r1
    69a2:	80 83       	st	Z, r24
    i++;
    69a4:	0f 5f       	subi	r16, 0xFF	; 255
  Wire.endTransmission(); // end transmission
  
  Wire.beginTransmission(_dev_address); // start transmission to device 
  Wire.requestFrom(_dev_address, _nbytes);// send data n-bytes read
  uint8_t i = 0; 
  while (Wire.available()) {
    69a6:	80 e2       	ldi	r24, 0x20	; 32
    69a8:	99 e0       	ldi	r25, 0x09	; 9
    69aa:	0e 94 fb 2a 	call	0x55f6	; 0x55f6 <_ZN7WireI2C9availableEv>
    69ae:	88 23       	and	r24, r24
    69b0:	89 f7       	brne	.-30     	; 0x6994 <_ZN7ITG32007readmemEhhPh+0x58>
    __buff[i] = Wire.receive(); // receive DATA
    i++;
  }
  Wire.endTransmission(); // end transmission
    69b2:	80 e2       	ldi	r24, 0x20	; 32
    69b4:	99 e0       	ldi	r25, 0x09	; 9
    69b6:	0e 94 f6 2a 	call	0x55ec	; 0x55ec <_ZN7WireI2C15endTransmissionEv>
}
    69ba:	df 91       	pop	r29
    69bc:	cf 91       	pop	r28
    69be:	1f 91       	pop	r17
    69c0:	0f 91       	pop	r16
    69c2:	ff 90       	pop	r15
    69c4:	ef 90       	pop	r14
    69c6:	08 95       	ret

000069c8 <_ZN7ITG320014setClockSourceEh>:
byte ITG3200::getClockSource() {  
  readmem(PWR_MGM, 1, &_buff[0]);
  return (_buff[0] & PWRMGM_CLK_SEL);
}

void ITG3200::setClockSource(byte _CLKsource) {   
    69c8:	ff 92       	push	r15
    69ca:	0f 93       	push	r16
    69cc:	1f 93       	push	r17
    69ce:	8c 01       	movw	r16, r24
    69d0:	f6 2e       	mov	r15, r22
  readmem(PWR_MGM, 1, &_buff[0]);
    69d2:	9c 01       	movw	r18, r24
    69d4:	2d 5e       	subi	r18, 0xED	; 237
    69d6:	3f 4f       	sbci	r19, 0xFF	; 255
    69d8:	6e e3       	ldi	r22, 0x3E	; 62
    69da:	41 e0       	ldi	r20, 0x01	; 1
    69dc:	af df       	rcall	.-162    	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(PWR_MGM, ((_buff[0] & ~PWRMGM_CLK_SEL) | _CLKsource)); 
    69de:	f8 01       	movw	r30, r16
    69e0:	43 89       	ldd	r20, Z+19	; 0x13
    69e2:	48 7f       	andi	r20, 0xF8	; 248
    69e4:	4f 29       	or	r20, r15
    69e6:	c8 01       	movw	r24, r16
    69e8:	6e e3       	ldi	r22, 0x3E	; 62
    69ea:	79 df       	rcall	.-270    	; 0x68de <_ZN7ITG32008writememEhh>
}
    69ec:	1f 91       	pop	r17
    69ee:	0f 91       	pop	r16
    69f0:	ff 90       	pop	r15
    69f2:	08 95       	ret

000069f4 <_ZN7ITG320014getClockSourceEv>:
void ITG3200::setZgyroStandby(bool _Status) {
  readmem(PWR_MGM, 1, &_buff[0]);
  writemem(PWR_MGM, ((_buff[0] & PWRMGM_STBY_ZG) | _Status << 3));
}

byte ITG3200::getClockSource() {  
    69f4:	0f 93       	push	r16
    69f6:	1f 93       	push	r17
    69f8:	8c 01       	movw	r16, r24
  readmem(PWR_MGM, 1, &_buff[0]);
    69fa:	9c 01       	movw	r18, r24
    69fc:	2d 5e       	subi	r18, 0xED	; 237
    69fe:	3f 4f       	sbci	r19, 0xFF	; 255
    6a00:	6e e3       	ldi	r22, 0x3E	; 62
    6a02:	41 e0       	ldi	r20, 0x01	; 1
    6a04:	9b df       	rcall	.-202    	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6a06:	f8 01       	movw	r30, r16
    6a08:	83 89       	ldd	r24, Z+19	; 0x13
  return (_buff[0] & PWRMGM_CLK_SEL);
}
    6a0a:	87 70       	andi	r24, 0x07	; 7
    6a0c:	1f 91       	pop	r17
    6a0e:	0f 91       	pop	r16
    6a10:	08 95       	ret

00006a12 <_ZN7ITG320015setZgyroStandbyEb>:
void ITG3200::setYgyroStandby(bool _Status) {
  readmem(PWR_MGM, 1, &_buff[0]);
  writemem(PWR_MGM, ((_buff[0] & PWRMGM_STBY_YG) | _Status << 4));
}

void ITG3200::setZgyroStandby(bool _Status) {
    6a12:	ff 92       	push	r15
    6a14:	0f 93       	push	r16
    6a16:	1f 93       	push	r17
    6a18:	8c 01       	movw	r16, r24
    6a1a:	f6 2e       	mov	r15, r22
  readmem(PWR_MGM, 1, &_buff[0]);
    6a1c:	9c 01       	movw	r18, r24
    6a1e:	2d 5e       	subi	r18, 0xED	; 237
    6a20:	3f 4f       	sbci	r19, 0xFF	; 255
    6a22:	6e e3       	ldi	r22, 0x3E	; 62
    6a24:	41 e0       	ldi	r20, 0x01	; 1
    6a26:	8a df       	rcall	.-236    	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(PWR_MGM, ((_buff[0] & PWRMGM_STBY_ZG) | _Status << 3));
    6a28:	ff 0c       	add	r15, r15
    6a2a:	ff 0c       	add	r15, r15
    6a2c:	ff 0c       	add	r15, r15
    6a2e:	f8 01       	movw	r30, r16
    6a30:	43 89       	ldd	r20, Z+19	; 0x13
    6a32:	48 70       	andi	r20, 0x08	; 8
    6a34:	4f 29       	or	r20, r15
    6a36:	c8 01       	movw	r24, r16
    6a38:	6e e3       	ldi	r22, 0x3E	; 62
    6a3a:	51 df       	rcall	.-350    	; 0x68de <_ZN7ITG32008writememEhh>
}
    6a3c:	1f 91       	pop	r17
    6a3e:	0f 91       	pop	r16
    6a40:	ff 90       	pop	r15
    6a42:	08 95       	ret

00006a44 <_ZN7ITG320015setYgyroStandbyEb>:
void ITG3200::setXgyroStandby(bool _Status) {
  readmem(PWR_MGM, 1, &_buff[0]);
  writemem(PWR_MGM, ((_buff[0] & PWRMGM_STBY_XG) | _Status << 5));
}

void ITG3200::setYgyroStandby(bool _Status) {
    6a44:	ff 92       	push	r15
    6a46:	0f 93       	push	r16
    6a48:	1f 93       	push	r17
    6a4a:	8c 01       	movw	r16, r24
    6a4c:	f6 2e       	mov	r15, r22
  readmem(PWR_MGM, 1, &_buff[0]);
    6a4e:	9c 01       	movw	r18, r24
    6a50:	2d 5e       	subi	r18, 0xED	; 237
    6a52:	3f 4f       	sbci	r19, 0xFF	; 255
    6a54:	6e e3       	ldi	r22, 0x3E	; 62
    6a56:	41 e0       	ldi	r20, 0x01	; 1
    6a58:	71 df       	rcall	.-286    	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(PWR_MGM, ((_buff[0] & PWRMGM_STBY_YG) | _Status << 4));
    6a5a:	f2 94       	swap	r15
    6a5c:	80 ef       	ldi	r24, 0xF0	; 240
    6a5e:	f8 22       	and	r15, r24
    6a60:	f8 01       	movw	r30, r16
    6a62:	43 89       	ldd	r20, Z+19	; 0x13
    6a64:	40 71       	andi	r20, 0x10	; 16
    6a66:	4f 29       	or	r20, r15
    6a68:	c8 01       	movw	r24, r16
    6a6a:	6e e3       	ldi	r22, 0x3E	; 62
    6a6c:	38 df       	rcall	.-400    	; 0x68de <_ZN7ITG32008writememEhh>
}
    6a6e:	1f 91       	pop	r17
    6a70:	0f 91       	pop	r16
    6a72:	ff 90       	pop	r15
    6a74:	08 95       	ret

00006a76 <_ZN7ITG320015setXgyroStandbyEb>:
bool ITG3200::isZgyroStandby() {
  readmem(PWR_MGM, 1, &_buff[0]);
  return (_buff[0] & PWRMGM_STBY_ZG) >> 3;
}

void ITG3200::setXgyroStandby(bool _Status) {
    6a76:	ff 92       	push	r15
    6a78:	0f 93       	push	r16
    6a7a:	1f 93       	push	r17
    6a7c:	8c 01       	movw	r16, r24
    6a7e:	f6 2e       	mov	r15, r22
  readmem(PWR_MGM, 1, &_buff[0]);
    6a80:	9c 01       	movw	r18, r24
    6a82:	2d 5e       	subi	r18, 0xED	; 237
    6a84:	3f 4f       	sbci	r19, 0xFF	; 255
    6a86:	6e e3       	ldi	r22, 0x3E	; 62
    6a88:	41 e0       	ldi	r20, 0x01	; 1
    6a8a:	58 df       	rcall	.-336    	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(PWR_MGM, ((_buff[0] & PWRMGM_STBY_XG) | _Status << 5));
    6a8c:	f2 94       	swap	r15
    6a8e:	ff 0c       	add	r15, r15
    6a90:	90 ee       	ldi	r25, 0xE0	; 224
    6a92:	f9 22       	and	r15, r25
    6a94:	f8 01       	movw	r30, r16
    6a96:	43 89       	ldd	r20, Z+19	; 0x13
    6a98:	40 72       	andi	r20, 0x20	; 32
    6a9a:	4f 29       	or	r20, r15
    6a9c:	c8 01       	movw	r24, r16
    6a9e:	6e e3       	ldi	r22, 0x3E	; 62
    6aa0:	1e df       	rcall	.-452    	; 0x68de <_ZN7ITG32008writememEhh>
}
    6aa2:	1f 91       	pop	r17
    6aa4:	0f 91       	pop	r16
    6aa6:	ff 90       	pop	r15
    6aa8:	08 95       	ret

00006aaa <_ZN7ITG320014isZgyroStandbyEv>:
bool ITG3200::isYgyroStandby() {
  readmem(PWR_MGM, 1, &_buff[0]);
  return (_buff[0] & PWRMGM_STBY_YG) >> 4;
}

bool ITG3200::isZgyroStandby() {
    6aaa:	0f 93       	push	r16
    6aac:	1f 93       	push	r17
    6aae:	8c 01       	movw	r16, r24
  readmem(PWR_MGM, 1, &_buff[0]);
    6ab0:	9c 01       	movw	r18, r24
    6ab2:	2d 5e       	subi	r18, 0xED	; 237
    6ab4:	3f 4f       	sbci	r19, 0xFF	; 255
    6ab6:	6e e3       	ldi	r22, 0x3E	; 62
    6ab8:	41 e0       	ldi	r20, 0x01	; 1
    6aba:	40 df       	rcall	.-384    	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6abc:	90 e0       	ldi	r25, 0x00	; 0
    6abe:	f8 01       	movw	r30, r16
    6ac0:	83 89       	ldd	r24, Z+19	; 0x13
    6ac2:	83 fd       	sbrc	r24, 3
    6ac4:	91 e0       	ldi	r25, 0x01	; 1
  return (_buff[0] & PWRMGM_STBY_ZG) >> 3;
}
    6ac6:	89 2f       	mov	r24, r25
    6ac8:	1f 91       	pop	r17
    6aca:	0f 91       	pop	r16
    6acc:	08 95       	ret

00006ace <_ZN7ITG320014isYgyroStandbyEv>:
bool ITG3200::isXgyroStandby() {
  readmem(PWR_MGM, 1, &_buff[0]);
  return (_buff[0] & PWRMGM_STBY_XG) >> 5;
}

bool ITG3200::isYgyroStandby() {
    6ace:	0f 93       	push	r16
    6ad0:	1f 93       	push	r17
    6ad2:	8c 01       	movw	r16, r24
  readmem(PWR_MGM, 1, &_buff[0]);
    6ad4:	9c 01       	movw	r18, r24
    6ad6:	2d 5e       	subi	r18, 0xED	; 237
    6ad8:	3f 4f       	sbci	r19, 0xFF	; 255
    6ada:	6e e3       	ldi	r22, 0x3E	; 62
    6adc:	41 e0       	ldi	r20, 0x01	; 1
    6ade:	2e df       	rcall	.-420    	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6ae0:	90 e0       	ldi	r25, 0x00	; 0
    6ae2:	f8 01       	movw	r30, r16
    6ae4:	83 89       	ldd	r24, Z+19	; 0x13
    6ae6:	84 fd       	sbrc	r24, 4
    6ae8:	91 e0       	ldi	r25, 0x01	; 1
  return (_buff[0] & PWRMGM_STBY_YG) >> 4;
}
    6aea:	89 2f       	mov	r24, r25
    6aec:	1f 91       	pop	r17
    6aee:	0f 91       	pop	r16
    6af0:	08 95       	ret

00006af2 <_ZN7ITG320014isXgyroStandbyEv>:
void ITG3200::setPowerMode(bool _State) {
  readmem(PWR_MGM, 1, &_buff[0]);
  writemem(PWR_MGM, ((_buff[0] & ~PWRMGM_SLEEP) | _State << 6));  
}

bool ITG3200::isXgyroStandby() {
    6af2:	0f 93       	push	r16
    6af4:	1f 93       	push	r17
    6af6:	8c 01       	movw	r16, r24
  readmem(PWR_MGM, 1, &_buff[0]);
    6af8:	9c 01       	movw	r18, r24
    6afa:	2d 5e       	subi	r18, 0xED	; 237
    6afc:	3f 4f       	sbci	r19, 0xFF	; 255
    6afe:	6e e3       	ldi	r22, 0x3E	; 62
    6b00:	41 e0       	ldi	r20, 0x01	; 1
    6b02:	1c df       	rcall	.-456    	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6b04:	90 e0       	ldi	r25, 0x00	; 0
    6b06:	f8 01       	movw	r30, r16
    6b08:	83 89       	ldd	r24, Z+19	; 0x13
    6b0a:	85 fd       	sbrc	r24, 5
    6b0c:	91 e0       	ldi	r25, 0x01	; 1
  return (_buff[0] & PWRMGM_STBY_XG) >> 5;
}
    6b0e:	89 2f       	mov	r24, r25
    6b10:	1f 91       	pop	r17
    6b12:	0f 91       	pop	r16
    6b14:	08 95       	ret

00006b16 <_ZN7ITG320012setPowerModeEb>:
bool ITG3200::isLowPower() {   
  readmem(PWR_MGM, 1, &_buff[0]);
  return (_buff[0] & PWRMGM_SLEEP) >> 6;
}
  
void ITG3200::setPowerMode(bool _State) {
    6b16:	ff 92       	push	r15
    6b18:	0f 93       	push	r16
    6b1a:	1f 93       	push	r17
    6b1c:	8c 01       	movw	r16, r24
    6b1e:	f6 2e       	mov	r15, r22
  readmem(PWR_MGM, 1, &_buff[0]);
    6b20:	9c 01       	movw	r18, r24
    6b22:	2d 5e       	subi	r18, 0xED	; 237
    6b24:	3f 4f       	sbci	r19, 0xFF	; 255
    6b26:	6e e3       	ldi	r22, 0x3E	; 62
    6b28:	41 e0       	ldi	r20, 0x01	; 1
    6b2a:	08 df       	rcall	.-496    	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(PWR_MGM, ((_buff[0] & ~PWRMGM_SLEEP) | _State << 6));  
    6b2c:	f2 94       	swap	r15
    6b2e:	ff 0c       	add	r15, r15
    6b30:	ff 0c       	add	r15, r15
    6b32:	20 ec       	ldi	r18, 0xC0	; 192
    6b34:	f2 22       	and	r15, r18
    6b36:	f8 01       	movw	r30, r16
    6b38:	43 89       	ldd	r20, Z+19	; 0x13
    6b3a:	4f 7b       	andi	r20, 0xBF	; 191
    6b3c:	4f 29       	or	r20, r15
    6b3e:	c8 01       	movw	r24, r16
    6b40:	6e e3       	ldi	r22, 0x3E	; 62
    6b42:	cd de       	rcall	.-614    	; 0x68de <_ZN7ITG32008writememEhh>
}
    6b44:	1f 91       	pop	r17
    6b46:	0f 91       	pop	r16
    6b48:	ff 90       	pop	r15
    6b4a:	08 95       	ret

00006b4c <_ZN7ITG320010isLowPowerEv>:
void ITG3200::reset() {     
  writemem(PWR_MGM, PWRMGM_HRESET); 
  delay(GYROSTART_UP_DELAY); //gyro startup 
}

bool ITG3200::isLowPower() {   
    6b4c:	0f 93       	push	r16
    6b4e:	1f 93       	push	r17
    6b50:	8c 01       	movw	r16, r24
  readmem(PWR_MGM, 1, &_buff[0]);
    6b52:	9c 01       	movw	r18, r24
    6b54:	2d 5e       	subi	r18, 0xED	; 237
    6b56:	3f 4f       	sbci	r19, 0xFF	; 255
    6b58:	6e e3       	ldi	r22, 0x3E	; 62
    6b5a:	41 e0       	ldi	r20, 0x01	; 1
    6b5c:	ef de       	rcall	.-546    	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6b5e:	90 e0       	ldi	r25, 0x00	; 0
    6b60:	f8 01       	movw	r30, r16
    6b62:	83 89       	ldd	r24, Z+19	; 0x13
    6b64:	86 fd       	sbrc	r24, 6
    6b66:	91 e0       	ldi	r25, 0x01	; 1
  return (_buff[0] & PWRMGM_SLEEP) >> 6;
}
    6b68:	89 2f       	mov	r24, r25
    6b6a:	1f 91       	pop	r17
    6b6c:	0f 91       	pop	r16
    6b6e:	08 95       	ret

00006b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>:
void ITG3200::readTemp(float *_Temp) {
  readmem(TEMP_OUT,2,_buff);
  *_Temp = 35 + ((_buff[0] << 8 | _buff[1]) + 13200) / 280.0;    // F=C*9/5+32
}

void ITG3200::readGyroRaw( int *_GyroX, int *_GyroY, int *_GyroZ){
    6b70:	af 92       	push	r10
    6b72:	bf 92       	push	r11
    6b74:	cf 92       	push	r12
    6b76:	df 92       	push	r13
    6b78:	ef 92       	push	r14
    6b7a:	ff 92       	push	r15
    6b7c:	0f 93       	push	r16
    6b7e:	1f 93       	push	r17
    6b80:	8c 01       	movw	r16, r24
    6b82:	7b 01       	movw	r14, r22
    6b84:	6a 01       	movw	r12, r20
    6b86:	59 01       	movw	r10, r18
  readmem(GYRO_XOUT, 6, _buff);
    6b88:	9c 01       	movw	r18, r24
    6b8a:	2d 5e       	subi	r18, 0xED	; 237
    6b8c:	3f 4f       	sbci	r19, 0xFF	; 255
    6b8e:	6d e1       	ldi	r22, 0x1D	; 29
    6b90:	46 e0       	ldi	r20, 0x06	; 6
    6b92:	d4 de       	rcall	.-600    	; 0x693c <_ZN7ITG32007readmemEhhPh>
  *_GyroX = _buff[0] << 8 | _buff[1];
    6b94:	f8 01       	movw	r30, r16
    6b96:	93 89       	ldd	r25, Z+19	; 0x13
    6b98:	80 e0       	ldi	r24, 0x00	; 0
    6b9a:	24 89       	ldd	r18, Z+20	; 0x14
    6b9c:	30 e0       	ldi	r19, 0x00	; 0
    6b9e:	82 2b       	or	r24, r18
    6ba0:	93 2b       	or	r25, r19
    6ba2:	f7 01       	movw	r30, r14
    6ba4:	91 83       	std	Z+1, r25	; 0x01
    6ba6:	80 83       	st	Z, r24
  *_GyroY = _buff[2] << 8 | _buff[3]; 
    6ba8:	f8 01       	movw	r30, r16
    6baa:	95 89       	ldd	r25, Z+21	; 0x15
    6bac:	80 e0       	ldi	r24, 0x00	; 0
    6bae:	26 89       	ldd	r18, Z+22	; 0x16
    6bb0:	30 e0       	ldi	r19, 0x00	; 0
    6bb2:	82 2b       	or	r24, r18
    6bb4:	93 2b       	or	r25, r19
    6bb6:	f6 01       	movw	r30, r12
    6bb8:	91 83       	std	Z+1, r25	; 0x01
    6bba:	80 83       	st	Z, r24
  *_GyroZ = _buff[4] << 8 | _buff[5];
    6bbc:	f8 01       	movw	r30, r16
    6bbe:	97 89       	ldd	r25, Z+23	; 0x17
    6bc0:	80 e0       	ldi	r24, 0x00	; 0
    6bc2:	20 8d       	ldd	r18, Z+24	; 0x18
    6bc4:	30 e0       	ldi	r19, 0x00	; 0
    6bc6:	82 2b       	or	r24, r18
    6bc8:	93 2b       	or	r25, r19
    6bca:	f5 01       	movw	r30, r10
    6bcc:	91 83       	std	Z+1, r25	; 0x01
    6bce:	80 83       	st	Z, r24
}
    6bd0:	1f 91       	pop	r17
    6bd2:	0f 91       	pop	r16
    6bd4:	ff 90       	pop	r15
    6bd6:	ef 90       	pop	r14
    6bd8:	df 90       	pop	r13
    6bda:	cf 90       	pop	r12
    6bdc:	bf 90       	pop	r11
    6bde:	af 90       	pop	r10
    6be0:	08 95       	ret

00006be2 <_ZN7ITG320014readGyroRawCalEPiS0_S0_>:
    tmpOffsets[2] += xyz[2];
  }
  setOffsets(-tmpOffsets[0] / totSamples + 0.5, -tmpOffsets[1] / totSamples + 0.5, -tmpOffsets[2] / totSamples + 0.5);
}

void ITG3200::readGyroRawCal(int *_GyroX, int *_GyroY, int *_GyroZ) { 
    6be2:	af 92       	push	r10
    6be4:	bf 92       	push	r11
    6be6:	cf 92       	push	r12
    6be8:	df 92       	push	r13
    6bea:	ef 92       	push	r14
    6bec:	ff 92       	push	r15
    6bee:	0f 93       	push	r16
    6bf0:	1f 93       	push	r17
    6bf2:	6c 01       	movw	r12, r24
    6bf4:	8b 01       	movw	r16, r22
    6bf6:	7a 01       	movw	r14, r20
    6bf8:	59 01       	movw	r10, r18
  readGyroRaw(_GyroX, _GyroY, _GyroZ); 
    6bfa:	ba df       	rcall	.-140    	; 0x6b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>
  *_GyroX += offsets[0]; 
    6bfc:	f8 01       	movw	r30, r16
    6bfe:	80 81       	ld	r24, Z
    6c00:	91 81       	ldd	r25, Z+1	; 0x01
    6c02:	f6 01       	movw	r30, r12
    6c04:	24 85       	ldd	r18, Z+12	; 0x0c
    6c06:	35 85       	ldd	r19, Z+13	; 0x0d
    6c08:	82 0f       	add	r24, r18
    6c0a:	93 1f       	adc	r25, r19
    6c0c:	f8 01       	movw	r30, r16
    6c0e:	91 83       	std	Z+1, r25	; 0x01
    6c10:	80 83       	st	Z, r24
  *_GyroY += offsets[1]; 
    6c12:	f7 01       	movw	r30, r14
    6c14:	80 81       	ld	r24, Z
    6c16:	91 81       	ldd	r25, Z+1	; 0x01
    6c18:	f6 01       	movw	r30, r12
    6c1a:	26 85       	ldd	r18, Z+14	; 0x0e
    6c1c:	37 85       	ldd	r19, Z+15	; 0x0f
    6c1e:	82 0f       	add	r24, r18
    6c20:	93 1f       	adc	r25, r19
    6c22:	f7 01       	movw	r30, r14
    6c24:	91 83       	std	Z+1, r25	; 0x01
    6c26:	80 83       	st	Z, r24
  *_GyroZ += offsets[2]; 
    6c28:	f5 01       	movw	r30, r10
    6c2a:	80 81       	ld	r24, Z
    6c2c:	91 81       	ldd	r25, Z+1	; 0x01
    6c2e:	f6 01       	movw	r30, r12
    6c30:	20 89       	ldd	r18, Z+16	; 0x10
    6c32:	31 89       	ldd	r19, Z+17	; 0x11
    6c34:	82 0f       	add	r24, r18
    6c36:	93 1f       	adc	r25, r19
    6c38:	f5 01       	movw	r30, r10
    6c3a:	91 83       	std	Z+1, r25	; 0x01
    6c3c:	80 83       	st	Z, r24
} 
    6c3e:	1f 91       	pop	r17
    6c40:	0f 91       	pop	r16
    6c42:	ff 90       	pop	r15
    6c44:	ef 90       	pop	r14
    6c46:	df 90       	pop	r13
    6c48:	cf 90       	pop	r12
    6c4a:	bf 90       	pop	r11
    6c4c:	af 90       	pop	r10
    6c4e:	08 95       	ret

00006c50 <_ZN7ITG32008readGyroEPfS0_S0_>:

void ITG3200::readGyroRawCal(int *_GyroXYZ) { 
  readGyroRawCal(_GyroXYZ, _GyroXYZ+1, _GyroXYZ+2); 
} 

void ITG3200::readGyro(float *_GyroX, float *_GyroY, float *_GyroZ){
    6c50:	af 92       	push	r10
    6c52:	bf 92       	push	r11
    6c54:	cf 92       	push	r12
    6c56:	df 92       	push	r13
    6c58:	ef 92       	push	r14
    6c5a:	ff 92       	push	r15
    6c5c:	0f 93       	push	r16
    6c5e:	1f 93       	push	r17
    6c60:	df 93       	push	r29
    6c62:	cf 93       	push	r28
    6c64:	00 d0       	rcall	.+0      	; 0x6c66 <_ZN7ITG32008readGyroEPfS0_S0_+0x16>
    6c66:	00 d0       	rcall	.+0      	; 0x6c68 <_ZN7ITG32008readGyroEPfS0_S0_+0x18>
    6c68:	00 d0       	rcall	.+0      	; 0x6c6a <_ZN7ITG32008readGyroEPfS0_S0_+0x1a>
    6c6a:	cd b7       	in	r28, 0x3d	; 61
    6c6c:	de b7       	in	r29, 0x3e	; 62
    6c6e:	8c 01       	movw	r16, r24
    6c70:	7b 01       	movw	r14, r22
    6c72:	6a 01       	movw	r12, r20
    6c74:	59 01       	movw	r10, r18
  int x, y, z; 
  readGyroRawCal(&x, &y, &z); // x,y,z will contain calibrated integer values from the sensor 
    6c76:	be 01       	movw	r22, r28
    6c78:	6f 5f       	subi	r22, 0xFF	; 255
    6c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    6c7c:	ae 01       	movw	r20, r28
    6c7e:	4d 5f       	subi	r20, 0xFD	; 253
    6c80:	5f 4f       	sbci	r21, 0xFF	; 255
    6c82:	9e 01       	movw	r18, r28
    6c84:	2b 5f       	subi	r18, 0xFB	; 251
    6c86:	3f 4f       	sbci	r19, 0xFF	; 255
    6c88:	ac df       	rcall	.-168    	; 0x6be2 <_ZN7ITG320014readGyroRawCalEPiS0_S0_>
  *_GyroX =  x / scalefactor[0]; 
    6c8a:	69 81       	ldd	r22, Y+1	; 0x01
    6c8c:	7a 81       	ldd	r23, Y+2	; 0x02
    6c8e:	88 27       	eor	r24, r24
    6c90:	77 fd       	sbrc	r23, 7
    6c92:	80 95       	com	r24
    6c94:	98 2f       	mov	r25, r24
    6c96:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    6c9a:	f8 01       	movw	r30, r16
    6c9c:	20 81       	ld	r18, Z
    6c9e:	31 81       	ldd	r19, Z+1	; 0x01
    6ca0:	42 81       	ldd	r20, Z+2	; 0x02
    6ca2:	53 81       	ldd	r21, Z+3	; 0x03
    6ca4:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    6ca8:	f7 01       	movw	r30, r14
    6caa:	60 83       	st	Z, r22
    6cac:	71 83       	std	Z+1, r23	; 0x01
    6cae:	82 83       	std	Z+2, r24	; 0x02
    6cb0:	93 83       	std	Z+3, r25	; 0x03
  *_GyroY =  y / scalefactor[1]; 
    6cb2:	6b 81       	ldd	r22, Y+3	; 0x03
    6cb4:	7c 81       	ldd	r23, Y+4	; 0x04
    6cb6:	88 27       	eor	r24, r24
    6cb8:	77 fd       	sbrc	r23, 7
    6cba:	80 95       	com	r24
    6cbc:	98 2f       	mov	r25, r24
    6cbe:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    6cc2:	f8 01       	movw	r30, r16
    6cc4:	24 81       	ldd	r18, Z+4	; 0x04
    6cc6:	35 81       	ldd	r19, Z+5	; 0x05
    6cc8:	46 81       	ldd	r20, Z+6	; 0x06
    6cca:	57 81       	ldd	r21, Z+7	; 0x07
    6ccc:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    6cd0:	f6 01       	movw	r30, r12
    6cd2:	60 83       	st	Z, r22
    6cd4:	71 83       	std	Z+1, r23	; 0x01
    6cd6:	82 83       	std	Z+2, r24	; 0x02
    6cd8:	93 83       	std	Z+3, r25	; 0x03
  *_GyroZ =  z / scalefactor[2];     
    6cda:	6d 81       	ldd	r22, Y+5	; 0x05
    6cdc:	7e 81       	ldd	r23, Y+6	; 0x06
    6cde:	88 27       	eor	r24, r24
    6ce0:	77 fd       	sbrc	r23, 7
    6ce2:	80 95       	com	r24
    6ce4:	98 2f       	mov	r25, r24
    6ce6:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    6cea:	f8 01       	movw	r30, r16
    6cec:	20 85       	ldd	r18, Z+8	; 0x08
    6cee:	31 85       	ldd	r19, Z+9	; 0x09
    6cf0:	42 85       	ldd	r20, Z+10	; 0x0a
    6cf2:	53 85       	ldd	r21, Z+11	; 0x0b
    6cf4:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    6cf8:	f5 01       	movw	r30, r10
    6cfa:	60 83       	st	Z, r22
    6cfc:	71 83       	std	Z+1, r23	; 0x01
    6cfe:	82 83       	std	Z+2, r24	; 0x02
    6d00:	93 83       	std	Z+3, r25	; 0x03
} 
    6d02:	26 96       	adiw	r28, 0x06	; 6
    6d04:	0f b6       	in	r0, 0x3f	; 63
    6d06:	f8 94       	cli
    6d08:	de bf       	out	0x3e, r29	; 62
    6d0a:	0f be       	out	0x3f, r0	; 63
    6d0c:	cd bf       	out	0x3d, r28	; 61
    6d0e:	cf 91       	pop	r28
    6d10:	df 91       	pop	r29
    6d12:	1f 91       	pop	r17
    6d14:	0f 91       	pop	r16
    6d16:	ff 90       	pop	r15
    6d18:	ef 90       	pop	r14
    6d1a:	df 90       	pop	r13
    6d1c:	cf 90       	pop	r12
    6d1e:	bf 90       	pop	r11
    6d20:	af 90       	pop	r10
    6d22:	08 95       	ret

00006d24 <_ZN7ITG32008readGyroEPf>:

void ITG3200::readGyro(float *_GyroXYZ){
    6d24:	ab 01       	movw	r20, r22
  readGyro(_GyroXYZ, _GyroXYZ+1, _GyroXYZ+2);
    6d26:	9b 01       	movw	r18, r22
    6d28:	28 5f       	subi	r18, 0xF8	; 248
    6d2a:	3f 4f       	sbci	r19, 0xFF	; 255
    6d2c:	4c 5f       	subi	r20, 0xFC	; 252
    6d2e:	5f 4f       	sbci	r21, 0xFF	; 255
}
    6d30:	8f cf       	rjmp	.-226    	; 0x6c50 <_ZN7ITG32008readGyroEPfS0_S0_>

00006d32 <_ZN7ITG320014readGyroRawCalEPi>:
  *_GyroX += offsets[0]; 
  *_GyroY += offsets[1]; 
  *_GyroZ += offsets[2]; 
} 

void ITG3200::readGyroRawCal(int *_GyroXYZ) { 
    6d32:	ab 01       	movw	r20, r22
  readGyroRawCal(_GyroXYZ, _GyroXYZ+1, _GyroXYZ+2); 
    6d34:	9b 01       	movw	r18, r22
    6d36:	2c 5f       	subi	r18, 0xFC	; 252
    6d38:	3f 4f       	sbci	r19, 0xFF	; 255
    6d3a:	4e 5f       	subi	r20, 0xFE	; 254
    6d3c:	5f 4f       	sbci	r21, 0xFF	; 255
} 
    6d3e:	51 cf       	rjmp	.-350    	; 0x6be2 <_ZN7ITG320014readGyroRawCalEPiS0_S0_>

00006d40 <_ZN7ITG320011readGyroRawEPi>:
  *_GyroX = _buff[0] << 8 | _buff[1];
  *_GyroY = _buff[2] << 8 | _buff[3]; 
  *_GyroZ = _buff[4] << 8 | _buff[5];
}

void ITG3200::readGyroRaw( int *_GyroXYZ){
    6d40:	ab 01       	movw	r20, r22
  readGyroRaw(_GyroXYZ, _GyroXYZ+1, _GyroXYZ+2);
    6d42:	9b 01       	movw	r18, r22
    6d44:	2c 5f       	subi	r18, 0xFC	; 252
    6d46:	3f 4f       	sbci	r19, 0xFF	; 255
    6d48:	4e 5f       	subi	r20, 0xFE	; 254
    6d4a:	5f 4f       	sbci	r21, 0xFF	; 255
}
    6d4c:	11 cf       	rjmp	.-478    	; 0x6b70 <_ZN7ITG320011readGyroRawEPiS0_S0_>

00006d4e <_ZN7ITG32008readTempEPf>:
bool ITG3200::isRawDataReady() {
  readmem(INT_STATUS, 1, &_buff[0]);
  return (_buff[0] & INTSTATUS_RAW_DATA_RDY);
}

void ITG3200::readTemp(float *_Temp) {
    6d4e:	ef 92       	push	r14
    6d50:	ff 92       	push	r15
    6d52:	0f 93       	push	r16
    6d54:	1f 93       	push	r17
    6d56:	8c 01       	movw	r16, r24
    6d58:	7b 01       	movw	r14, r22
  readmem(TEMP_OUT,2,_buff);
    6d5a:	9c 01       	movw	r18, r24
    6d5c:	2d 5e       	subi	r18, 0xED	; 237
    6d5e:	3f 4f       	sbci	r19, 0xFF	; 255
    6d60:	6b e1       	ldi	r22, 0x1B	; 27
    6d62:	42 e0       	ldi	r20, 0x02	; 2
    6d64:	eb dd       	rcall	.-1066   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  *_Temp = 35 + ((_buff[0] << 8 | _buff[1]) + 13200) / 280.0;    // F=C*9/5+32
    6d66:	f8 01       	movw	r30, r16
    6d68:	73 89       	ldd	r23, Z+19	; 0x13
    6d6a:	60 e0       	ldi	r22, 0x00	; 0
    6d6c:	24 89       	ldd	r18, Z+20	; 0x14
    6d6e:	30 e0       	ldi	r19, 0x00	; 0
    6d70:	62 2b       	or	r22, r18
    6d72:	73 2b       	or	r23, r19
    6d74:	60 57       	subi	r22, 0x70	; 112
    6d76:	7c 4c       	sbci	r23, 0xCC	; 204
    6d78:	88 27       	eor	r24, r24
    6d7a:	77 fd       	sbrc	r23, 7
    6d7c:	80 95       	com	r24
    6d7e:	98 2f       	mov	r25, r24
    6d80:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    6d84:	20 e0       	ldi	r18, 0x00	; 0
    6d86:	30 e0       	ldi	r19, 0x00	; 0
    6d88:	4c e8       	ldi	r20, 0x8C	; 140
    6d8a:	53 e4       	ldi	r21, 0x43	; 67
    6d8c:	0e 94 20 40 	call	0x8040	; 0x8040 <__divsf3>
    6d90:	20 e0       	ldi	r18, 0x00	; 0
    6d92:	30 e0       	ldi	r19, 0x00	; 0
    6d94:	4c e0       	ldi	r20, 0x0C	; 12
    6d96:	52 e4       	ldi	r21, 0x42	; 66
    6d98:	0e 94 94 3f 	call	0x7f28	; 0x7f28 <__addsf3>
    6d9c:	f7 01       	movw	r30, r14
    6d9e:	60 83       	st	Z, r22
    6da0:	71 83       	std	Z+1, r23	; 0x01
    6da2:	82 83       	std	Z+2, r24	; 0x02
    6da4:	93 83       	std	Z+3, r25	; 0x03
}
    6da6:	1f 91       	pop	r17
    6da8:	0f 91       	pop	r16
    6daa:	ff 90       	pop	r15
    6dac:	ef 90       	pop	r14
    6dae:	08 95       	ret

00006db0 <_ZN7ITG320014isRawDataReadyEv>:
bool ITG3200::isITGReady() {
  readmem(INT_STATUS, 1, &_buff[0]);
  return ((_buff[0] & INTSTATUS_ITG_RDY) >> 2);
}

bool ITG3200::isRawDataReady() {
    6db0:	0f 93       	push	r16
    6db2:	1f 93       	push	r17
    6db4:	8c 01       	movw	r16, r24
  readmem(INT_STATUS, 1, &_buff[0]);
    6db6:	9c 01       	movw	r18, r24
    6db8:	2d 5e       	subi	r18, 0xED	; 237
    6dba:	3f 4f       	sbci	r19, 0xFF	; 255
    6dbc:	6a e1       	ldi	r22, 0x1A	; 26
    6dbe:	41 e0       	ldi	r20, 0x01	; 1
    6dc0:	bd dd       	rcall	.-1158   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6dc2:	f8 01       	movw	r30, r16
    6dc4:	83 89       	ldd	r24, Z+19	; 0x13
  return (_buff[0] & INTSTATUS_RAW_DATA_RDY);
}
    6dc6:	81 70       	andi	r24, 0x01	; 1
    6dc8:	1f 91       	pop	r17
    6dca:	0f 91       	pop	r16
    6dcc:	08 95       	ret

00006dce <_ZN7ITG320010isITGReadyEv>:
void ITG3200::setRawDataReady(bool _State) {
  readmem(INT_CFG, 1, &_buff[0]);
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_RAW_RDY_EN) | _State)); 
}

bool ITG3200::isITGReady() {
    6dce:	0f 93       	push	r16
    6dd0:	1f 93       	push	r17
    6dd2:	8c 01       	movw	r16, r24
  readmem(INT_STATUS, 1, &_buff[0]);
    6dd4:	9c 01       	movw	r18, r24
    6dd6:	2d 5e       	subi	r18, 0xED	; 237
    6dd8:	3f 4f       	sbci	r19, 0xFF	; 255
    6dda:	6a e1       	ldi	r22, 0x1A	; 26
    6ddc:	41 e0       	ldi	r20, 0x01	; 1
    6dde:	ae dd       	rcall	.-1188   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6de0:	90 e0       	ldi	r25, 0x00	; 0
    6de2:	f8 01       	movw	r30, r16
    6de4:	83 89       	ldd	r24, Z+19	; 0x13
    6de6:	82 fd       	sbrc	r24, 2
    6de8:	91 e0       	ldi	r25, 0x01	; 1
  return ((_buff[0] & INTSTATUS_ITG_RDY) >> 2);
}
    6dea:	89 2f       	mov	r24, r25
    6dec:	1f 91       	pop	r17
    6dee:	0f 91       	pop	r16
    6df0:	08 95       	ret

00006df2 <_ZN7ITG320015setRawDataReadyEb>:
bool ITG3200::isRawDataReadyOn() {
  readmem(INT_CFG, 1, &_buff[0]);
  return (_buff[0] & INTCFG_RAW_RDY_EN);
}

void ITG3200::setRawDataReady(bool _State) {
    6df2:	ff 92       	push	r15
    6df4:	0f 93       	push	r16
    6df6:	1f 93       	push	r17
    6df8:	8c 01       	movw	r16, r24
    6dfa:	f6 2e       	mov	r15, r22
  readmem(INT_CFG, 1, &_buff[0]);
    6dfc:	9c 01       	movw	r18, r24
    6dfe:	2d 5e       	subi	r18, 0xED	; 237
    6e00:	3f 4f       	sbci	r19, 0xFF	; 255
    6e02:	67 e1       	ldi	r22, 0x17	; 23
    6e04:	41 e0       	ldi	r20, 0x01	; 1
    6e06:	9a dd       	rcall	.-1228   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_RAW_RDY_EN) | _State)); 
    6e08:	f8 01       	movw	r30, r16
    6e0a:	43 89       	ldd	r20, Z+19	; 0x13
    6e0c:	4e 7f       	andi	r20, 0xFE	; 254
    6e0e:	4f 29       	or	r20, r15
    6e10:	c8 01       	movw	r24, r16
    6e12:	67 e1       	ldi	r22, 0x17	; 23
    6e14:	64 dd       	rcall	.-1336   	; 0x68de <_ZN7ITG32008writememEhh>
}
    6e16:	1f 91       	pop	r17
    6e18:	0f 91       	pop	r16
    6e1a:	ff 90       	pop	r15
    6e1c:	08 95       	ret

00006e1e <_ZN7ITG320016isRawDataReadyOnEv>:
void ITG3200::setITGReady(bool _State) {
  readmem(INT_CFG, 1, &_buff[0]);
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_ITG_RDY_EN) | _State << 2)); 
}

bool ITG3200::isRawDataReadyOn() {
    6e1e:	0f 93       	push	r16
    6e20:	1f 93       	push	r17
    6e22:	8c 01       	movw	r16, r24
  readmem(INT_CFG, 1, &_buff[0]);
    6e24:	9c 01       	movw	r18, r24
    6e26:	2d 5e       	subi	r18, 0xED	; 237
    6e28:	3f 4f       	sbci	r19, 0xFF	; 255
    6e2a:	67 e1       	ldi	r22, 0x17	; 23
    6e2c:	41 e0       	ldi	r20, 0x01	; 1
    6e2e:	86 dd       	rcall	.-1268   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6e30:	f8 01       	movw	r30, r16
    6e32:	83 89       	ldd	r24, Z+19	; 0x13
  return (_buff[0] & INTCFG_RAW_RDY_EN);
}
    6e34:	81 70       	andi	r24, 0x01	; 1
    6e36:	1f 91       	pop	r17
    6e38:	0f 91       	pop	r16
    6e3a:	08 95       	ret

00006e3c <_ZN7ITG320011setITGReadyEb>:
bool ITG3200::isITGReadyOn() {   
  readmem(INT_CFG, 1, &_buff[0]);
  return ((_buff[0] & INTCFG_ITG_RDY_EN) >> 2);
}

void ITG3200::setITGReady(bool _State) {
    6e3c:	ff 92       	push	r15
    6e3e:	0f 93       	push	r16
    6e40:	1f 93       	push	r17
    6e42:	8c 01       	movw	r16, r24
    6e44:	f6 2e       	mov	r15, r22
  readmem(INT_CFG, 1, &_buff[0]);
    6e46:	9c 01       	movw	r18, r24
    6e48:	2d 5e       	subi	r18, 0xED	; 237
    6e4a:	3f 4f       	sbci	r19, 0xFF	; 255
    6e4c:	67 e1       	ldi	r22, 0x17	; 23
    6e4e:	41 e0       	ldi	r20, 0x01	; 1
    6e50:	75 dd       	rcall	.-1302   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_ITG_RDY_EN) | _State << 2)); 
    6e52:	ff 0c       	add	r15, r15
    6e54:	ff 0c       	add	r15, r15
    6e56:	f8 01       	movw	r30, r16
    6e58:	43 89       	ldd	r20, Z+19	; 0x13
    6e5a:	4b 7f       	andi	r20, 0xFB	; 251
    6e5c:	4f 29       	or	r20, r15
    6e5e:	c8 01       	movw	r24, r16
    6e60:	67 e1       	ldi	r22, 0x17	; 23
    6e62:	3d dd       	rcall	.-1414   	; 0x68de <_ZN7ITG32008writememEhh>
}
    6e64:	1f 91       	pop	r17
    6e66:	0f 91       	pop	r16
    6e68:	ff 90       	pop	r15
    6e6a:	08 95       	ret

00006e6c <_ZN7ITG320012isITGReadyOnEv>:
void ITG3200::setLatchClearMode(bool _State) {
  readmem(INT_CFG, 1, &_buff[0]);
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_INT_ANYRD_2CLEAR) | _State << 4)); 
}

bool ITG3200::isITGReadyOn() {   
    6e6c:	0f 93       	push	r16
    6e6e:	1f 93       	push	r17
    6e70:	8c 01       	movw	r16, r24
  readmem(INT_CFG, 1, &_buff[0]);
    6e72:	9c 01       	movw	r18, r24
    6e74:	2d 5e       	subi	r18, 0xED	; 237
    6e76:	3f 4f       	sbci	r19, 0xFF	; 255
    6e78:	67 e1       	ldi	r22, 0x17	; 23
    6e7a:	41 e0       	ldi	r20, 0x01	; 1
    6e7c:	5f dd       	rcall	.-1346   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6e7e:	90 e0       	ldi	r25, 0x00	; 0
    6e80:	f8 01       	movw	r30, r16
    6e82:	83 89       	ldd	r24, Z+19	; 0x13
    6e84:	82 fd       	sbrc	r24, 2
    6e86:	91 e0       	ldi	r25, 0x01	; 1
  return ((_buff[0] & INTCFG_ITG_RDY_EN) >> 2);
}
    6e88:	89 2f       	mov	r24, r25
    6e8a:	1f 91       	pop	r17
    6e8c:	0f 91       	pop	r16
    6e8e:	08 95       	ret

00006e90 <_ZN7ITG320017setLatchClearModeEb>:
bool ITG3200::isAnyRegClrMode() {    
  readmem(INT_CFG, 1, &_buff[0]);
  return ((_buff[0] & INTCFG_INT_ANYRD_2CLEAR) >> 4);
}

void ITG3200::setLatchClearMode(bool _State) {
    6e90:	ff 92       	push	r15
    6e92:	0f 93       	push	r16
    6e94:	1f 93       	push	r17
    6e96:	8c 01       	movw	r16, r24
    6e98:	f6 2e       	mov	r15, r22
  readmem(INT_CFG, 1, &_buff[0]);
    6e9a:	9c 01       	movw	r18, r24
    6e9c:	2d 5e       	subi	r18, 0xED	; 237
    6e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    6ea0:	67 e1       	ldi	r22, 0x17	; 23
    6ea2:	41 e0       	ldi	r20, 0x01	; 1
    6ea4:	4b dd       	rcall	.-1386   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_INT_ANYRD_2CLEAR) | _State << 4)); 
    6ea6:	f2 94       	swap	r15
    6ea8:	30 ef       	ldi	r19, 0xF0	; 240
    6eaa:	f3 22       	and	r15, r19
    6eac:	f8 01       	movw	r30, r16
    6eae:	43 89       	ldd	r20, Z+19	; 0x13
    6eb0:	4f 7e       	andi	r20, 0xEF	; 239
    6eb2:	4f 29       	or	r20, r15
    6eb4:	c8 01       	movw	r24, r16
    6eb6:	67 e1       	ldi	r22, 0x17	; 23
    6eb8:	12 dd       	rcall	.-1500   	; 0x68de <_ZN7ITG32008writememEhh>
}
    6eba:	1f 91       	pop	r17
    6ebc:	0f 91       	pop	r16
    6ebe:	ff 90       	pop	r15
    6ec0:	08 95       	ret

00006ec2 <_ZN7ITG320015isAnyRegClrModeEv>:
void ITG3200::setLatchMode(bool _State) {
  readmem(INT_CFG, 1, &_buff[0]);
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_LATCH_INT_EN) | _State << 5)); 
}

bool ITG3200::isAnyRegClrMode() {    
    6ec2:	0f 93       	push	r16
    6ec4:	1f 93       	push	r17
    6ec6:	8c 01       	movw	r16, r24
  readmem(INT_CFG, 1, &_buff[0]);
    6ec8:	9c 01       	movw	r18, r24
    6eca:	2d 5e       	subi	r18, 0xED	; 237
    6ecc:	3f 4f       	sbci	r19, 0xFF	; 255
    6ece:	67 e1       	ldi	r22, 0x17	; 23
    6ed0:	41 e0       	ldi	r20, 0x01	; 1
    6ed2:	34 dd       	rcall	.-1432   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6ed4:	90 e0       	ldi	r25, 0x00	; 0
    6ed6:	f8 01       	movw	r30, r16
    6ed8:	83 89       	ldd	r24, Z+19	; 0x13
    6eda:	84 fd       	sbrc	r24, 4
    6edc:	91 e0       	ldi	r25, 0x01	; 1
  return ((_buff[0] & INTCFG_INT_ANYRD_2CLEAR) >> 4);
}
    6ede:	89 2f       	mov	r24, r25
    6ee0:	1f 91       	pop	r17
    6ee2:	0f 91       	pop	r16
    6ee4:	08 95       	ret

00006ee6 <_ZN7ITG320012setLatchModeEb>:
bool ITG3200::isLatchUntilCleared() {    
  readmem(INT_CFG, 1, &_buff[0]);
  return ((_buff[0] & INTCFG_LATCH_INT_EN) >> 5);
}

void ITG3200::setLatchMode(bool _State) {
    6ee6:	ff 92       	push	r15
    6ee8:	0f 93       	push	r16
    6eea:	1f 93       	push	r17
    6eec:	8c 01       	movw	r16, r24
    6eee:	f6 2e       	mov	r15, r22
  readmem(INT_CFG, 1, &_buff[0]);
    6ef0:	9c 01       	movw	r18, r24
    6ef2:	2d 5e       	subi	r18, 0xED	; 237
    6ef4:	3f 4f       	sbci	r19, 0xFF	; 255
    6ef6:	67 e1       	ldi	r22, 0x17	; 23
    6ef8:	41 e0       	ldi	r20, 0x01	; 1
    6efa:	20 dd       	rcall	.-1472   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_LATCH_INT_EN) | _State << 5)); 
    6efc:	f2 94       	swap	r15
    6efe:	ff 0c       	add	r15, r15
    6f00:	40 ee       	ldi	r20, 0xE0	; 224
    6f02:	f4 22       	and	r15, r20
    6f04:	f8 01       	movw	r30, r16
    6f06:	43 89       	ldd	r20, Z+19	; 0x13
    6f08:	4f 7d       	andi	r20, 0xDF	; 223
    6f0a:	4f 29       	or	r20, r15
    6f0c:	c8 01       	movw	r24, r16
    6f0e:	67 e1       	ldi	r22, 0x17	; 23
    6f10:	e6 dc       	rcall	.-1588   	; 0x68de <_ZN7ITG32008writememEhh>
}
    6f12:	1f 91       	pop	r17
    6f14:	0f 91       	pop	r16
    6f16:	ff 90       	pop	r15
    6f18:	08 95       	ret

00006f1a <_ZN7ITG320019isLatchUntilClearedEv>:
void ITG3200::setINTDriveType(bool _State) {
  readmem(INT_CFG, 1, &_buff[0]);
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_OPEN) | _State << 6)); 
}

bool ITG3200::isLatchUntilCleared() {    
    6f1a:	0f 93       	push	r16
    6f1c:	1f 93       	push	r17
    6f1e:	8c 01       	movw	r16, r24
  readmem(INT_CFG, 1, &_buff[0]);
    6f20:	9c 01       	movw	r18, r24
    6f22:	2d 5e       	subi	r18, 0xED	; 237
    6f24:	3f 4f       	sbci	r19, 0xFF	; 255
    6f26:	67 e1       	ldi	r22, 0x17	; 23
    6f28:	41 e0       	ldi	r20, 0x01	; 1
    6f2a:	08 dd       	rcall	.-1520   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6f2c:	90 e0       	ldi	r25, 0x00	; 0
    6f2e:	f8 01       	movw	r30, r16
    6f30:	83 89       	ldd	r24, Z+19	; 0x13
    6f32:	85 fd       	sbrc	r24, 5
    6f34:	91 e0       	ldi	r25, 0x01	; 1
  return ((_buff[0] & INTCFG_LATCH_INT_EN) >> 5);
}
    6f36:	89 2f       	mov	r24, r25
    6f38:	1f 91       	pop	r17
    6f3a:	0f 91       	pop	r16
    6f3c:	08 95       	ret

00006f3e <_ZN7ITG320015setINTDriveTypeEb>:
bool ITG3200::isINTOpenDrain() {  
  readmem(INT_CFG, 1, &_buff[0]);
  return ((_buff[0] & INTCFG_OPEN) >> 6);
}

void ITG3200::setINTDriveType(bool _State) {
    6f3e:	ff 92       	push	r15
    6f40:	0f 93       	push	r16
    6f42:	1f 93       	push	r17
    6f44:	8c 01       	movw	r16, r24
    6f46:	f6 2e       	mov	r15, r22
  readmem(INT_CFG, 1, &_buff[0]);
    6f48:	9c 01       	movw	r18, r24
    6f4a:	2d 5e       	subi	r18, 0xED	; 237
    6f4c:	3f 4f       	sbci	r19, 0xFF	; 255
    6f4e:	67 e1       	ldi	r22, 0x17	; 23
    6f50:	41 e0       	ldi	r20, 0x01	; 1
    6f52:	f4 dc       	rcall	.-1560   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_OPEN) | _State << 6)); 
    6f54:	f2 94       	swap	r15
    6f56:	ff 0c       	add	r15, r15
    6f58:	ff 0c       	add	r15, r15
    6f5a:	50 ec       	ldi	r21, 0xC0	; 192
    6f5c:	f5 22       	and	r15, r21
    6f5e:	f8 01       	movw	r30, r16
    6f60:	43 89       	ldd	r20, Z+19	; 0x13
    6f62:	4f 7b       	andi	r20, 0xBF	; 191
    6f64:	4f 29       	or	r20, r15
    6f66:	c8 01       	movw	r24, r16
    6f68:	67 e1       	ldi	r22, 0x17	; 23
    6f6a:	b9 dc       	rcall	.-1678   	; 0x68de <_ZN7ITG32008writememEhh>
}
    6f6c:	1f 91       	pop	r17
    6f6e:	0f 91       	pop	r16
    6f70:	ff 90       	pop	r15
    6f72:	08 95       	ret

00006f74 <_ZN7ITG320014isINTOpenDrainEv>:
void ITG3200::setINTLogiclvl(bool _State) {
  readmem(INT_CFG, 1, &_buff[0]);
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_ACTL) | (_State << 7))); 
}

bool ITG3200::isINTOpenDrain() {  
    6f74:	0f 93       	push	r16
    6f76:	1f 93       	push	r17
    6f78:	8c 01       	movw	r16, r24
  readmem(INT_CFG, 1, &_buff[0]);
    6f7a:	9c 01       	movw	r18, r24
    6f7c:	2d 5e       	subi	r18, 0xED	; 237
    6f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    6f80:	67 e1       	ldi	r22, 0x17	; 23
    6f82:	41 e0       	ldi	r20, 0x01	; 1
    6f84:	db dc       	rcall	.-1610   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6f86:	90 e0       	ldi	r25, 0x00	; 0
    6f88:	f8 01       	movw	r30, r16
    6f8a:	83 89       	ldd	r24, Z+19	; 0x13
    6f8c:	86 fd       	sbrc	r24, 6
    6f8e:	91 e0       	ldi	r25, 0x01	; 1
  return ((_buff[0] & INTCFG_OPEN) >> 6);
}
    6f90:	89 2f       	mov	r24, r25
    6f92:	1f 91       	pop	r17
    6f94:	0f 91       	pop	r16
    6f96:	08 95       	ret

00006f98 <_ZN7ITG320014setINTLogiclvlEb>:
bool ITG3200::isINTActiveOnLow() {  
  readmem(INT_CFG, 1, &_buff[0]);
  return ((_buff[0] & INTCFG_ACTL) >> 7);
}

void ITG3200::setINTLogiclvl(bool _State) {
    6f98:	ff 92       	push	r15
    6f9a:	0f 93       	push	r16
    6f9c:	1f 93       	push	r17
    6f9e:	8c 01       	movw	r16, r24
    6fa0:	f6 2e       	mov	r15, r22
  readmem(INT_CFG, 1, &_buff[0]);
    6fa2:	9c 01       	movw	r18, r24
    6fa4:	2d 5e       	subi	r18, 0xED	; 237
    6fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    6fa8:	67 e1       	ldi	r22, 0x17	; 23
    6faa:	41 e0       	ldi	r20, 0x01	; 1
    6fac:	c7 dc       	rcall	.-1650   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(INT_CFG, ((_buff[0] & ~INTCFG_ACTL) | (_State << 7))); 
    6fae:	f7 94       	ror	r15
    6fb0:	ff 24       	eor	r15, r15
    6fb2:	f7 94       	ror	r15
    6fb4:	f8 01       	movw	r30, r16
    6fb6:	43 89       	ldd	r20, Z+19	; 0x13
    6fb8:	4f 77       	andi	r20, 0x7F	; 127
    6fba:	4f 29       	or	r20, r15
    6fbc:	c8 01       	movw	r24, r16
    6fbe:	67 e1       	ldi	r22, 0x17	; 23
    6fc0:	8e dc       	rcall	.-1764   	; 0x68de <_ZN7ITG32008writememEhh>
}
    6fc2:	1f 91       	pop	r17
    6fc4:	0f 91       	pop	r16
    6fc6:	ff 90       	pop	r15
    6fc8:	08 95       	ret

00006fca <_ZN7ITG320016isINTActiveOnLowEv>:
void ITG3200::setFilterBW(byte _BW) {   
  readmem(DLPF_FS, 1, &_buff[0]);
  writemem(DLPF_FS, ((_buff[0] & ~DLPFFS_DLPF_CFG) | _BW)); 
}

bool ITG3200::isINTActiveOnLow() {  
    6fca:	0f 93       	push	r16
    6fcc:	1f 93       	push	r17
    6fce:	8c 01       	movw	r16, r24
  readmem(INT_CFG, 1, &_buff[0]);
    6fd0:	9c 01       	movw	r18, r24
    6fd2:	2d 5e       	subi	r18, 0xED	; 237
    6fd4:	3f 4f       	sbci	r19, 0xFF	; 255
    6fd6:	67 e1       	ldi	r22, 0x17	; 23
    6fd8:	41 e0       	ldi	r20, 0x01	; 1
    6fda:	b0 dc       	rcall	.-1696   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    6fdc:	90 e0       	ldi	r25, 0x00	; 0
    6fde:	f8 01       	movw	r30, r16
    6fe0:	83 89       	ldd	r24, Z+19	; 0x13
    6fe2:	87 fd       	sbrc	r24, 7
    6fe4:	91 e0       	ldi	r25, 0x01	; 1
  return ((_buff[0] & INTCFG_ACTL) >> 7);
}
    6fe6:	89 2f       	mov	r24, r25
    6fe8:	1f 91       	pop	r17
    6fea:	0f 91       	pop	r16
    6fec:	08 95       	ret

00006fee <_ZN7ITG320011setFilterBWEh>:
byte ITG3200::getFilterBW() {  
  readmem(DLPF_FS, 1, &_buff[0]);
  return (_buff[0] & DLPFFS_DLPF_CFG); 
}

void ITG3200::setFilterBW(byte _BW) {   
    6fee:	ff 92       	push	r15
    6ff0:	0f 93       	push	r16
    6ff2:	1f 93       	push	r17
    6ff4:	8c 01       	movw	r16, r24
    6ff6:	f6 2e       	mov	r15, r22
  readmem(DLPF_FS, 1, &_buff[0]);
    6ff8:	9c 01       	movw	r18, r24
    6ffa:	2d 5e       	subi	r18, 0xED	; 237
    6ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    6ffe:	66 e1       	ldi	r22, 0x16	; 22
    7000:	41 e0       	ldi	r20, 0x01	; 1
    7002:	9c dc       	rcall	.-1736   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(DLPF_FS, ((_buff[0] & ~DLPFFS_DLPF_CFG) | _BW)); 
    7004:	f8 01       	movw	r30, r16
    7006:	43 89       	ldd	r20, Z+19	; 0x13
    7008:	48 7f       	andi	r20, 0xF8	; 248
    700a:	4f 29       	or	r20, r15
    700c:	c8 01       	movw	r24, r16
    700e:	66 e1       	ldi	r22, 0x16	; 22
    7010:	66 dc       	rcall	.-1844   	; 0x68de <_ZN7ITG32008writememEhh>
}
    7012:	1f 91       	pop	r17
    7014:	0f 91       	pop	r16
    7016:	ff 90       	pop	r15
    7018:	08 95       	ret

0000701a <_ZN7ITG320011getFilterBWEv>:
void ITG3200::setFSRange(byte _Range) {
  readmem(DLPF_FS, 1, &_buff[0]);   
  writemem(DLPF_FS, ((_buff[0] & ~DLPFFS_FS_SEL) | (_Range << 3)) ); 
}

byte ITG3200::getFilterBW() {  
    701a:	0f 93       	push	r16
    701c:	1f 93       	push	r17
    701e:	8c 01       	movw	r16, r24
  readmem(DLPF_FS, 1, &_buff[0]);
    7020:	9c 01       	movw	r18, r24
    7022:	2d 5e       	subi	r18, 0xED	; 237
    7024:	3f 4f       	sbci	r19, 0xFF	; 255
    7026:	66 e1       	ldi	r22, 0x16	; 22
    7028:	41 e0       	ldi	r20, 0x01	; 1
    702a:	88 dc       	rcall	.-1776   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    702c:	f8 01       	movw	r30, r16
    702e:	83 89       	ldd	r24, Z+19	; 0x13
  return (_buff[0] & DLPFFS_DLPF_CFG); 
}
    7030:	87 70       	andi	r24, 0x07	; 7
    7032:	1f 91       	pop	r17
    7034:	0f 91       	pop	r16
    7036:	08 95       	ret

00007038 <_ZN7ITG320010setFSRangeEh>:
byte ITG3200::getFSRange() {
  readmem(DLPF_FS, 1, &_buff[0]);
  return ((_buff[0] & DLPFFS_FS_SEL) >> 3);
}

void ITG3200::setFSRange(byte _Range) {
    7038:	ff 92       	push	r15
    703a:	0f 93       	push	r16
    703c:	1f 93       	push	r17
    703e:	8c 01       	movw	r16, r24
    7040:	f6 2e       	mov	r15, r22
  readmem(DLPF_FS, 1, &_buff[0]);   
    7042:	9c 01       	movw	r18, r24
    7044:	2d 5e       	subi	r18, 0xED	; 237
    7046:	3f 4f       	sbci	r19, 0xFF	; 255
    7048:	66 e1       	ldi	r22, 0x16	; 22
    704a:	41 e0       	ldi	r20, 0x01	; 1
    704c:	77 dc       	rcall	.-1810   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  writemem(DLPF_FS, ((_buff[0] & ~DLPFFS_FS_SEL) | (_Range << 3)) ); 
    704e:	ff 0c       	add	r15, r15
    7050:	ff 0c       	add	r15, r15
    7052:	ff 0c       	add	r15, r15
    7054:	f8 01       	movw	r30, r16
    7056:	43 89       	ldd	r20, Z+19	; 0x13
    7058:	47 7e       	andi	r20, 0xE7	; 231
    705a:	4f 29       	or	r20, r15
    705c:	c8 01       	movw	r24, r16
    705e:	66 e1       	ldi	r22, 0x16	; 22
    7060:	3e dc       	rcall	.-1924   	; 0x68de <_ZN7ITG32008writememEhh>
}
    7062:	1f 91       	pop	r17
    7064:	0f 91       	pop	r16
    7066:	ff 90       	pop	r15
    7068:	08 95       	ret

0000706a <_ZN7ITG320010getFSRangeEv>:

void ITG3200::setSampleRateDiv(byte _SampleRate) {
  writemem(SMPLRT_DIV, _SampleRate);
}

byte ITG3200::getFSRange() {
    706a:	0f 93       	push	r16
    706c:	1f 93       	push	r17
    706e:	8c 01       	movw	r16, r24
  readmem(DLPF_FS, 1, &_buff[0]);
    7070:	9c 01       	movw	r18, r24
    7072:	2d 5e       	subi	r18, 0xED	; 237
    7074:	3f 4f       	sbci	r19, 0xFF	; 255
    7076:	66 e1       	ldi	r22, 0x16	; 22
    7078:	41 e0       	ldi	r20, 0x01	; 1
    707a:	60 dc       	rcall	.-1856   	; 0x693c <_ZN7ITG32007readmemEhhPh>
    707c:	f8 01       	movw	r30, r16
    707e:	83 89       	ldd	r24, Z+19	; 0x13
    7080:	90 e0       	ldi	r25, 0x00	; 0
    7082:	88 71       	andi	r24, 0x18	; 24
    7084:	90 70       	andi	r25, 0x00	; 0
    7086:	63 e0       	ldi	r22, 0x03	; 3
    7088:	95 95       	asr	r25
    708a:	87 95       	ror	r24
    708c:	6a 95       	dec	r22
    708e:	e1 f7       	brne	.-8      	; 0x7088 <_ZN7ITG320010getFSRangeEv+0x1e>
  return ((_buff[0] & DLPFFS_FS_SEL) >> 3);
}
    7090:	1f 91       	pop	r17
    7092:	0f 91       	pop	r16
    7094:	08 95       	ret

00007096 <_ZN7ITG320016getSampleRateDivEv>:
void ITG3200::setDevAddr(unsigned int  _addr) {
  writemem(WHO_AM_I, _addr); 
  _dev_address = _addr;
}

byte ITG3200::getSampleRateDiv() {
    7096:	0f 93       	push	r16
    7098:	1f 93       	push	r17
    709a:	8c 01       	movw	r16, r24
  readmem(SMPLRT_DIV, 1, &_buff[0]);
    709c:	9c 01       	movw	r18, r24
    709e:	2d 5e       	subi	r18, 0xED	; 237
    70a0:	3f 4f       	sbci	r19, 0xFF	; 255
    70a2:	65 e1       	ldi	r22, 0x15	; 21
    70a4:	41 e0       	ldi	r20, 0x01	; 1
    70a6:	4a dc       	rcall	.-1900   	; 0x693c <_ZN7ITG32007readmemEhhPh>
  return _buff[0];
}
    70a8:	f8 01       	movw	r30, r16
    70aa:	83 89       	ldd	r24, Z+19	; 0x13
    70ac:	1f 91       	pop	r17
    70ae:	0f 91       	pop	r16
    70b0:	08 95       	ret

000070b2 <_ZN7ITG32005resetEv>:
void ITG3200::readGyro(float *_GyroXYZ){
  readGyro(_GyroXYZ, _GyroXYZ+1, _GyroXYZ+2);
}

void ITG3200::reset() {     
  writemem(PWR_MGM, PWRMGM_HRESET); 
    70b2:	6e e3       	ldi	r22, 0x3E	; 62
    70b4:	40 e8       	ldi	r20, 0x80	; 128
    70b6:	13 dc       	rcall	.-2010   	; 0x68de <_ZN7ITG32008writememEhh>
  delay(GYROSTART_UP_DELAY); //gyro startup 
    70b8:	66 e4       	ldi	r22, 0x46	; 70
    70ba:	70 e0       	ldi	r23, 0x00	; 0
    70bc:	80 e0       	ldi	r24, 0x00	; 0
    70be:	90 e0       	ldi	r25, 0x00	; 0
}
    70c0:	89 c1       	rjmp	.+786    	; 0x73d4 <delay>

000070c2 <_ZN7ITG320013zeroCalibrateEjj>:
  offsets[0] = _Xoffset;
  offsets[1] = _Yoffset;
  offsets[2] = _Zoffset;
}

void ITG3200::zeroCalibrate(unsigned int totSamples, unsigned int sampleDelayMS) {
    70c2:	2f 92       	push	r2
    70c4:	3f 92       	push	r3
    70c6:	4f 92       	push	r4
    70c8:	5f 92       	push	r5
    70ca:	6f 92       	push	r6
    70cc:	7f 92       	push	r7
    70ce:	8f 92       	push	r8
    70d0:	9f 92       	push	r9
    70d2:	af 92       	push	r10
    70d4:	bf 92       	push	r11
    70d6:	cf 92       	push	r12
    70d8:	df 92       	push	r13
    70da:	ef 92       	push	r14
    70dc:	ff 92       	push	r15
    70de:	0f 93       	push	r16
    70e0:	1f 93       	push	r17
    70e2:	df 93       	push	r29
    70e4:	cf 93       	push	r28
    70e6:	cd b7       	in	r28, 0x3d	; 61
    70e8:	de b7       	in	r29, 0x3e	; 62
    70ea:	2c 97       	sbiw	r28, 0x0c	; 12
    70ec:	0f b6       	in	r0, 0x3f	; 63
    70ee:	f8 94       	cli
    70f0:	de bf       	out	0x3e, r29	; 62
    70f2:	0f be       	out	0x3f, r0	; 63
    70f4:	cd bf       	out	0x3d, r28	; 61
    70f6:	98 87       	std	Y+8, r25	; 0x08
    70f8:	8f 83       	std	Y+7, r24	; 0x07
    70fa:	7b 01       	movw	r14, r22
    70fc:	00 e0       	ldi	r16, 0x00	; 0
    70fe:	10 e0       	ldi	r17, 0x00	; 0
    7100:	0f 2e       	mov	r0, r31
    7102:	f0 e0       	ldi	r31, 0x00	; 0
    7104:	2f 2e       	mov	r2, r31
    7106:	f0 e0       	ldi	r31, 0x00	; 0
    7108:	3f 2e       	mov	r3, r31
    710a:	f0 e0       	ldi	r31, 0x00	; 0
    710c:	4f 2e       	mov	r4, r31
    710e:	f0 e0       	ldi	r31, 0x00	; 0
    7110:	5f 2e       	mov	r5, r31
    7112:	f0 2d       	mov	r31, r0
    7114:	42 01       	movw	r8, r4
    7116:	31 01       	movw	r6, r2
    7118:	62 01       	movw	r12, r4
    711a:	51 01       	movw	r10, r2
  float tmpOffsets[] = {0,0,0};
  int xyz[3];

  for (unsigned int i = 0;i < totSamples;i++){
    delay(sampleDelayMS);
    711c:	ca 01       	movw	r24, r20
    711e:	a0 e0       	ldi	r26, 0x00	; 0
    7120:	b0 e0       	ldi	r27, 0x00	; 0
    7122:	89 87       	std	Y+9, r24	; 0x09
    7124:	9a 87       	std	Y+10, r25	; 0x0a
    7126:	ab 87       	std	Y+11, r26	; 0x0b
    7128:	bc 87       	std	Y+12, r27	; 0x0c
    712a:	39 c0       	rjmp	.+114    	; 0x719e <_ZN7ITG320013zeroCalibrateEjj+0xdc>
    712c:	69 85       	ldd	r22, Y+9	; 0x09
    712e:	7a 85       	ldd	r23, Y+10	; 0x0a
    7130:	8b 85       	ldd	r24, Y+11	; 0x0b
    7132:	9c 85       	ldd	r25, Y+12	; 0x0c
    7134:	4f d1       	rcall	.+670    	; 0x73d4 <delay>
    readGyroRaw(xyz);
    7136:	8f 81       	ldd	r24, Y+7	; 0x07
    7138:	98 85       	ldd	r25, Y+8	; 0x08
    713a:	be 01       	movw	r22, r28
    713c:	6f 5f       	subi	r22, 0xFF	; 255
    713e:	7f 4f       	sbci	r23, 0xFF	; 255
    7140:	ff dd       	rcall	.-1026   	; 0x6d40 <_ZN7ITG320011readGyroRawEPi>
    tmpOffsets[0] += xyz[0];
    7142:	69 81       	ldd	r22, Y+1	; 0x01
    7144:	7a 81       	ldd	r23, Y+2	; 0x02
    7146:	88 27       	eor	r24, r24
    7148:	77 fd       	sbrc	r23, 7
    714a:	80 95       	com	r24
    714c:	98 2f       	mov	r25, r24
    714e:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    7152:	9b 01       	movw	r18, r22
    7154:	ac 01       	movw	r20, r24
    7156:	c6 01       	movw	r24, r12
    7158:	b5 01       	movw	r22, r10
    715a:	e6 d6       	rcall	.+3532   	; 0x7f28 <__addsf3>
    715c:	5b 01       	movw	r10, r22
    715e:	6c 01       	movw	r12, r24
    tmpOffsets[1] += xyz[1];
    7160:	6b 81       	ldd	r22, Y+3	; 0x03
    7162:	7c 81       	ldd	r23, Y+4	; 0x04
    7164:	88 27       	eor	r24, r24
    7166:	77 fd       	sbrc	r23, 7
    7168:	80 95       	com	r24
    716a:	98 2f       	mov	r25, r24
    716c:	0e 94 bb 40 	call	0x8176	; 0x8176 <__floatsisf>
    7170:	9b 01       	movw	r18, r22
    7172:	ac 01       	movw	r20, r24
    7174:	c4 01       	movw	r24, r8
    7176:	b3 01       	movw	r22, r6
    7178:	d7 d6       	rcall	.+3502   	; 0x7f28 <__addsf3>
    717a:	3b 01       	movw	r6, r22
    717c:	4c 01       	movw	r8, r24
    tmpOffsets[2] += xyz[2];
    717e:	6d 81       	ldd	r22, Y+5	; 0x05
    7180:	7e 81       	ldd	r23, Y+6	; 0x06
    7182:	88 27       	eor	r24, r24
    7184:	77 fd       	sbrc	r23, 7
    7186:	80 95       	com	r24
    7188:	98 2f       	mov	r25, r24
    718a:	f5 d7       	rcall	.+4074   	; 0x8176 <__floatsisf>
    718c:	9b 01       	movw	r18, r22
    718e:	ac 01       	movw	r20, r24
    7190:	c2 01       	movw	r24, r4
    7192:	b1 01       	movw	r22, r2
    7194:	c9 d6       	rcall	.+3474   	; 0x7f28 <__addsf3>
    7196:	1b 01       	movw	r2, r22
    7198:	2c 01       	movw	r4, r24

void ITG3200::zeroCalibrate(unsigned int totSamples, unsigned int sampleDelayMS) {
  float tmpOffsets[] = {0,0,0};
  int xyz[3];

  for (unsigned int i = 0;i < totSamples;i++){
    719a:	0f 5f       	subi	r16, 0xFF	; 255
    719c:	1f 4f       	sbci	r17, 0xFF	; 255
    719e:	0e 15       	cp	r16, r14
    71a0:	1f 05       	cpc	r17, r15
    71a2:	08 f4       	brcc	.+2      	; 0x71a6 <_ZN7ITG320013zeroCalibrateEjj+0xe4>
    71a4:	c3 cf       	rjmp	.-122    	; 0x712c <_ZN7ITG320013zeroCalibrateEjj+0x6a>
    readGyroRaw(xyz);
    tmpOffsets[0] += xyz[0];
    tmpOffsets[1] += xyz[1];
    tmpOffsets[2] += xyz[2];
  }
  setOffsets(-tmpOffsets[0] / totSamples + 0.5, -tmpOffsets[1] / totSamples + 0.5, -tmpOffsets[2] / totSamples + 0.5);
    71a6:	b7 01       	movw	r22, r14
    71a8:	80 e0       	ldi	r24, 0x00	; 0
    71aa:	90 e0       	ldi	r25, 0x00	; 0
    71ac:	e2 d7       	rcall	.+4036   	; 0x8172 <__floatunsisf>
    71ae:	7b 01       	movw	r14, r22
    71b0:	8c 01       	movw	r16, r24
    scalefactor[2] /= 0.0174532925;
  }
}

void ITG3200::setOffsets(int _Xoffset, int _Yoffset, int _Zoffset) {
  offsets[0] = _Xoffset;
    71b2:	c6 01       	movw	r24, r12
    71b4:	b5 01       	movw	r22, r10
    71b6:	90 58       	subi	r25, 0x80	; 128
    71b8:	a8 01       	movw	r20, r16
    71ba:	97 01       	movw	r18, r14
    71bc:	41 d7       	rcall	.+3714   	; 0x8040 <__divsf3>
    71be:	20 e0       	ldi	r18, 0x00	; 0
    71c0:	30 e0       	ldi	r19, 0x00	; 0
    71c2:	40 e0       	ldi	r20, 0x00	; 0
    71c4:	5f e3       	ldi	r21, 0x3F	; 63
    71c6:	b0 d6       	rcall	.+3424   	; 0x7f28 <__addsf3>
    71c8:	a3 d7       	rcall	.+3910   	; 0x8110 <__fixsfsi>
    71ca:	af 81       	ldd	r26, Y+7	; 0x07
    71cc:	b8 85       	ldd	r27, Y+8	; 0x08
    71ce:	1d 96       	adiw	r26, 0x0d	; 13
    71d0:	7c 93       	st	X, r23
    71d2:	6e 93       	st	-X, r22
    71d4:	1c 97       	sbiw	r26, 0x0c	; 12
  offsets[1] = _Yoffset;
    71d6:	c4 01       	movw	r24, r8
    71d8:	b3 01       	movw	r22, r6
    71da:	90 58       	subi	r25, 0x80	; 128
    71dc:	a8 01       	movw	r20, r16
    71de:	97 01       	movw	r18, r14
    71e0:	2f d7       	rcall	.+3678   	; 0x8040 <__divsf3>
    71e2:	20 e0       	ldi	r18, 0x00	; 0
    71e4:	30 e0       	ldi	r19, 0x00	; 0
    71e6:	40 e0       	ldi	r20, 0x00	; 0
    71e8:	5f e3       	ldi	r21, 0x3F	; 63
    71ea:	9e d6       	rcall	.+3388   	; 0x7f28 <__addsf3>
    71ec:	91 d7       	rcall	.+3874   	; 0x8110 <__fixsfsi>
    71ee:	ef 81       	ldd	r30, Y+7	; 0x07
    71f0:	f8 85       	ldd	r31, Y+8	; 0x08
    71f2:	77 87       	std	Z+15, r23	; 0x0f
    71f4:	66 87       	std	Z+14, r22	; 0x0e
  offsets[2] = _Zoffset;
    71f6:	c2 01       	movw	r24, r4
    71f8:	b1 01       	movw	r22, r2
    71fa:	90 58       	subi	r25, 0x80	; 128
    71fc:	a8 01       	movw	r20, r16
    71fe:	97 01       	movw	r18, r14
    7200:	1f d7       	rcall	.+3646   	; 0x8040 <__divsf3>
    7202:	20 e0       	ldi	r18, 0x00	; 0
    7204:	30 e0       	ldi	r19, 0x00	; 0
    7206:	40 e0       	ldi	r20, 0x00	; 0
    7208:	5f e3       	ldi	r21, 0x3F	; 63
    720a:	8e d6       	rcall	.+3356   	; 0x7f28 <__addsf3>
    720c:	81 d7       	rcall	.+3842   	; 0x8110 <__fixsfsi>
    720e:	af 81       	ldd	r26, Y+7	; 0x07
    7210:	b8 85       	ldd	r27, Y+8	; 0x08
    7212:	51 96       	adiw	r26, 0x11	; 17
    7214:	7c 93       	st	X, r23
    7216:	6e 93       	st	-X, r22
    7218:	50 97       	sbiw	r26, 0x10	; 16
    tmpOffsets[0] += xyz[0];
    tmpOffsets[1] += xyz[1];
    tmpOffsets[2] += xyz[2];
  }
  setOffsets(-tmpOffsets[0] / totSamples + 0.5, -tmpOffsets[1] / totSamples + 0.5, -tmpOffsets[2] / totSamples + 0.5);
}
    721a:	2c 96       	adiw	r28, 0x0c	; 12
    721c:	0f b6       	in	r0, 0x3f	; 63
    721e:	f8 94       	cli
    7220:	de bf       	out	0x3e, r29	; 62
    7222:	0f be       	out	0x3f, r0	; 63
    7224:	cd bf       	out	0x3d, r28	; 61
    7226:	cf 91       	pop	r28
    7228:	df 91       	pop	r29
    722a:	1f 91       	pop	r17
    722c:	0f 91       	pop	r16
    722e:	ff 90       	pop	r15
    7230:	ef 90       	pop	r14
    7232:	df 90       	pop	r13
    7234:	cf 90       	pop	r12
    7236:	bf 90       	pop	r11
    7238:	af 90       	pop	r10
    723a:	9f 90       	pop	r9
    723c:	8f 90       	pop	r8
    723e:	7f 90       	pop	r7
    7240:	6f 90       	pop	r6
    7242:	5f 90       	pop	r5
    7244:	4f 90       	pop	r4
    7246:	3f 90       	pop	r3
    7248:	2f 90       	pop	r2
    724a:	08 95       	ret

0000724c <_ZN7ITG32004initEjhhhhbb>:
  
  // slow sample rate 32Khz external clock - divisor = 0  filter = 1,2,3,4,5, or 6  clocksrc = 4  (raw values)
  //init(NOSRDIVIDER, RANGE2000, BW010_SR1, PLL_EXTERNAL32, true, true);
}

void ITG3200::init(unsigned int address, byte _SRateDiv, byte _Range, byte _filterBW, byte _ClockSrc, bool _ITGReady, bool _INTRawDataReady) {
    724c:	8f 92       	push	r8
    724e:	9f 92       	push	r9
    7250:	af 92       	push	r10
    7252:	cf 92       	push	r12
    7254:	ef 92       	push	r14
    7256:	0f 93       	push	r16
    7258:	1f 93       	push	r17
    725a:	4c 01       	movw	r8, r24
    725c:	12 2f       	mov	r17, r18
  _dev_address = address;
    725e:	fc 01       	movw	r30, r24
    7260:	62 8b       	std	Z+18, r22	; 0x12
  setSampleRateDiv(_SRateDiv);
    7262:	64 2f       	mov	r22, r20
    7264:	5a db       	rcall	.-2380   	; 0x691a <_ZN7ITG320016setSampleRateDivEh>
  setFSRange(_Range);
    7266:	c4 01       	movw	r24, r8
    7268:	61 2f       	mov	r22, r17
    726a:	e6 de       	rcall	.-564    	; 0x7038 <_ZN7ITG320010setFSRangeEh>
  setFilterBW(_filterBW);
    726c:	c4 01       	movw	r24, r8
    726e:	60 2f       	mov	r22, r16
    7270:	be de       	rcall	.-644    	; 0x6fee <_ZN7ITG320011setFilterBWEh>
  setClockSource(_ClockSrc);
    7272:	c4 01       	movw	r24, r8
    7274:	6e 2d       	mov	r22, r14
    7276:	a8 db       	rcall	.-2224   	; 0x69c8 <_ZN7ITG320014setClockSourceEh>
  setITGReady(_ITGReady);
    7278:	c4 01       	movw	r24, r8
    727a:	6c 2d       	mov	r22, r12
    727c:	df dd       	rcall	.-1090   	; 0x6e3c <_ZN7ITG320011setITGReadyEb>
  setRawDataReady(_INTRawDataReady);  
    727e:	c4 01       	movw	r24, r8
    7280:	6a 2d       	mov	r22, r10
    7282:	b7 dd       	rcall	.-1170   	; 0x6df2 <_ZN7ITG320015setRawDataReadyEb>
  delay(GYROSTART_UP_DELAY);  // startup 
    7284:	66 e4       	ldi	r22, 0x46	; 70
    7286:	70 e0       	ldi	r23, 0x00	; 0
    7288:	80 e0       	ldi	r24, 0x00	; 0
    728a:	90 e0       	ldi	r25, 0x00	; 0
    728c:	a3 d0       	rcall	.+326    	; 0x73d4 <delay>
}
    728e:	1f 91       	pop	r17
    7290:	0f 91       	pop	r16
    7292:	ef 90       	pop	r14
    7294:	cf 90       	pop	r12
    7296:	af 90       	pop	r10
    7298:	9f 90       	pop	r9
    729a:	8f 90       	pop	r8
    729c:	08 95       	ret

0000729e <_ZN7ITG32004initEj>:
                        //but some people reported that joining I2C bus earlier
                        //apparently solved problems with master/slave conditions.
                        //Uncomment if needed.
}

void ITG3200::init(unsigned int  address) {
    729e:	af 92       	push	r10
    72a0:	cf 92       	push	r12
    72a2:	ef 92       	push	r14
    72a4:	0f 93       	push	r16
  // Uncomment or change your default ITG3200 initialization
  
  // fast sample rate - divisor = 0 filter = 0 clocksrc = 0, 1, 2, or 3  (raw values)
  init(address, NOSRDIVIDER, RANGE2000, BW256_SR8, PLL_XGYRO_REF, true, true);
    72a6:	40 e0       	ldi	r20, 0x00	; 0
    72a8:	23 e0       	ldi	r18, 0x03	; 3
    72aa:	00 e0       	ldi	r16, 0x00	; 0
    72ac:	ee 24       	eor	r14, r14
    72ae:	e3 94       	inc	r14
    72b0:	cc 24       	eor	r12, r12
    72b2:	c3 94       	inc	r12
    72b4:	aa 24       	eor	r10, r10
    72b6:	a3 94       	inc	r10
    72b8:	c9 df       	rcall	.-110    	; 0x724c <_ZN7ITG32004initEjhhhhbb>
  // fast sample rate 32Khz external clock - divisor = 0  filter = 0  clocksrc = 4  (raw values)
  //init(NOSRDIVIDER, RANGE2000, BW256_SR8, PLL_EXTERNAL32, true, true);
  
  // slow sample rate 32Khz external clock - divisor = 0  filter = 1,2,3,4,5, or 6  clocksrc = 4  (raw values)
  //init(NOSRDIVIDER, RANGE2000, BW010_SR1, PLL_EXTERNAL32, true, true);
}
    72ba:	0f 91       	pop	r16
    72bc:	ef 90       	pop	r14
    72be:	cf 90       	pop	r12
    72c0:	af 90       	pop	r10
    72c2:	08 95       	ret

000072c4 <__vector_23>:
volatile unsigned long timer0_overflow_count = 0;
volatile unsigned long timer0_millis = 0;
static unsigned char timer0_fract = 0;

SIGNAL(TIMER0_OVF_vect)
{
    72c4:	1f 92       	push	r1
    72c6:	0f 92       	push	r0
    72c8:	0f b6       	in	r0, 0x3f	; 63
    72ca:	0f 92       	push	r0
    72cc:	11 24       	eor	r1, r1
    72ce:	2f 93       	push	r18
    72d0:	3f 93       	push	r19
    72d2:	4f 93       	push	r20
    72d4:	5f 93       	push	r21
    72d6:	6f 93       	push	r22
    72d8:	7f 93       	push	r23
    72da:	8f 93       	push	r24
    72dc:	9f 93       	push	r25
    72de:	af 93       	push	r26
    72e0:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    72e2:	20 91 70 04 	lds	r18, 0x0470
    72e6:	30 91 71 04 	lds	r19, 0x0471
    72ea:	40 91 72 04 	lds	r20, 0x0472
    72ee:	50 91 73 04 	lds	r21, 0x0473
	unsigned char f = timer0_fract;
    72f2:	70 91 74 04 	lds	r23, 0x0474

	m += MILLIS_INC;
    72f6:	da 01       	movw	r26, r20
    72f8:	c9 01       	movw	r24, r18
    72fa:	02 96       	adiw	r24, 0x02	; 2
    72fc:	a1 1d       	adc	r26, r1
    72fe:	b1 1d       	adc	r27, r1
	f += FRACT_INC;
    7300:	67 2f       	mov	r22, r23
    7302:	6a 5f       	subi	r22, 0xFA	; 250
	if (f >= FRACT_MAX) {
    7304:	6d 37       	cpi	r22, 0x7D	; 125
    7306:	30 f0       	brcs	.+12     	; 0x7314 <__vector_23+0x50>
		f -= FRACT_MAX;
    7308:	6d 57       	subi	r22, 0x7D	; 125
		m += 1;
    730a:	da 01       	movw	r26, r20
    730c:	c9 01       	movw	r24, r18
    730e:	03 96       	adiw	r24, 0x03	; 3
    7310:	a1 1d       	adc	r26, r1
    7312:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
    7314:	60 93 74 04 	sts	0x0474, r22
	timer0_millis = m;
    7318:	80 93 70 04 	sts	0x0470, r24
    731c:	90 93 71 04 	sts	0x0471, r25
    7320:	a0 93 72 04 	sts	0x0472, r26
    7324:	b0 93 73 04 	sts	0x0473, r27
	timer0_overflow_count++;
    7328:	80 91 6c 04 	lds	r24, 0x046C
    732c:	90 91 6d 04 	lds	r25, 0x046D
    7330:	a0 91 6e 04 	lds	r26, 0x046E
    7334:	b0 91 6f 04 	lds	r27, 0x046F
    7338:	01 96       	adiw	r24, 0x01	; 1
    733a:	a1 1d       	adc	r26, r1
    733c:	b1 1d       	adc	r27, r1
    733e:	80 93 6c 04 	sts	0x046C, r24
    7342:	90 93 6d 04 	sts	0x046D, r25
    7346:	a0 93 6e 04 	sts	0x046E, r26
    734a:	b0 93 6f 04 	sts	0x046F, r27
}
    734e:	bf 91       	pop	r27
    7350:	af 91       	pop	r26
    7352:	9f 91       	pop	r25
    7354:	8f 91       	pop	r24
    7356:	7f 91       	pop	r23
    7358:	6f 91       	pop	r22
    735a:	5f 91       	pop	r21
    735c:	4f 91       	pop	r20
    735e:	3f 91       	pop	r19
    7360:	2f 91       	pop	r18
    7362:	0f 90       	pop	r0
    7364:	0f be       	out	0x3f, r0	; 63
    7366:	0f 90       	pop	r0
    7368:	1f 90       	pop	r1
    736a:	18 95       	reti

0000736c <millis>:

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
    736c:	8f b7       	in	r24, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
    736e:	f8 94       	cli
	m = timer0_millis;
    7370:	20 91 70 04 	lds	r18, 0x0470
    7374:	30 91 71 04 	lds	r19, 0x0471
    7378:	40 91 72 04 	lds	r20, 0x0472
    737c:	50 91 73 04 	lds	r21, 0x0473
	SREG = oldSREG;
    7380:	8f bf       	out	0x3f, r24	; 63

	return m;
}
    7382:	b9 01       	movw	r22, r18
    7384:	ca 01       	movw	r24, r20
    7386:	08 95       	ret

00007388 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    7388:	9f b7       	in	r25, 0x3f	; 63
	
	cli();
    738a:	f8 94       	cli
	m = timer0_overflow_count;
    738c:	20 91 6c 04 	lds	r18, 0x046C
    7390:	30 91 6d 04 	lds	r19, 0x046D
    7394:	40 91 6e 04 	lds	r20, 0x046E
    7398:	50 91 6f 04 	lds	r21, 0x046F
#if defined(TCNT0)
	t = TCNT0;
    739c:	86 b5       	in	r24, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    739e:	a8 9b       	sbis	0x15, 0	; 21
    73a0:	06 c0       	rjmp	.+12     	; 0x73ae <micros+0x26>
    73a2:	8f 3f       	cpi	r24, 0xFF	; 255
    73a4:	21 f0       	breq	.+8      	; 0x73ae <micros+0x26>
		m++;
    73a6:	2f 5f       	subi	r18, 0xFF	; 255
    73a8:	3f 4f       	sbci	r19, 0xFF	; 255
    73aa:	4f 4f       	sbci	r20, 0xFF	; 255
    73ac:	5f 4f       	sbci	r21, 0xFF	; 255
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    73ae:	9f bf       	out	0x3f, r25	; 63
    73b0:	54 2f       	mov	r21, r20
    73b2:	43 2f       	mov	r20, r19
    73b4:	32 2f       	mov	r19, r18
    73b6:	22 27       	eor	r18, r18
    73b8:	28 0f       	add	r18, r24
    73ba:	31 1d       	adc	r19, r1
    73bc:	41 1d       	adc	r20, r1
    73be:	51 1d       	adc	r21, r1
    73c0:	83 e0       	ldi	r24, 0x03	; 3
    73c2:	22 0f       	add	r18, r18
    73c4:	33 1f       	adc	r19, r19
    73c6:	44 1f       	adc	r20, r20
    73c8:	55 1f       	adc	r21, r21
    73ca:	8a 95       	dec	r24
    73cc:	d1 f7       	brne	.-12     	; 0x73c2 <micros+0x3a>
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}
    73ce:	b9 01       	movw	r22, r18
    73d0:	ca 01       	movw	r24, r20
    73d2:	08 95       	ret

000073d4 <delay>:

void delay(unsigned long ms)
{
    73d4:	ef 92       	push	r14
    73d6:	ff 92       	push	r15
    73d8:	0f 93       	push	r16
    73da:	1f 93       	push	r17
    73dc:	cf 93       	push	r28
    73de:	df 93       	push	r29
    73e0:	7b 01       	movw	r14, r22
    73e2:	8c 01       	movw	r16, r24
	uint16_t start = (uint16_t)micros();
    73e4:	d1 df       	rcall	.-94     	; 0x7388 <micros>
    73e6:	eb 01       	movw	r28, r22
    73e8:	0d c0       	rjmp	.+26     	; 0x7404 <delay+0x30>

	while (ms > 0) {
		if (((uint16_t)micros() - start) >= 1000) {
    73ea:	ce df       	rcall	.-100    	; 0x7388 <micros>
    73ec:	6c 1b       	sub	r22, r28
    73ee:	7d 0b       	sbc	r23, r29
    73f0:	68 5e       	subi	r22, 0xE8	; 232
    73f2:	73 40       	sbci	r23, 0x03	; 3
    73f4:	d0 f3       	brcs	.-12     	; 0x73ea <delay+0x16>
			ms--;
    73f6:	08 94       	sec
    73f8:	e1 08       	sbc	r14, r1
    73fa:	f1 08       	sbc	r15, r1
    73fc:	01 09       	sbc	r16, r1
    73fe:	11 09       	sbc	r17, r1
			start += 1000;
    7400:	c8 51       	subi	r28, 0x18	; 24
    7402:	dc 4f       	sbci	r29, 0xFC	; 252

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
    7404:	e1 14       	cp	r14, r1
    7406:	f1 04       	cpc	r15, r1
    7408:	01 05       	cpc	r16, r1
    740a:	11 05       	cpc	r17, r1
    740c:	71 f7       	brne	.-36     	; 0x73ea <delay+0x16>
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    740e:	df 91       	pop	r29
    7410:	cf 91       	pop	r28
    7412:	1f 91       	pop	r17
    7414:	0f 91       	pop	r16
    7416:	ff 90       	pop	r15
    7418:	ef 90       	pop	r14
    741a:	08 95       	ret

0000741c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    741c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    741e:	84 b5       	in	r24, 0x24	; 36
    7420:	82 60       	ori	r24, 0x02	; 2
    7422:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    7424:	84 b5       	in	r24, 0x24	; 36
    7426:	81 60       	ori	r24, 0x01	; 1
    7428:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    742a:	85 b5       	in	r24, 0x25	; 37
    742c:	82 60       	ori	r24, 0x02	; 2
    742e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    7430:	85 b5       	in	r24, 0x25	; 37
    7432:	81 60       	ori	r24, 0x01	; 1
    7434:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    7436:	ee e6       	ldi	r30, 0x6E	; 110
    7438:	f0 e0       	ldi	r31, 0x00	; 0
    743a:	80 81       	ld	r24, Z
    743c:	81 60       	ori	r24, 0x01	; 1
    743e:	80 83       	st	Z, r24
	// timers 1 and 2 are used for phase-correct hardware pwm
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

	TCCR1B = 0;
    7440:	e1 e8       	ldi	r30, 0x81	; 129
    7442:	f0 e0       	ldi	r31, 0x00	; 0
    7444:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	sbi(TCCR1B, CS11);
    7446:	80 81       	ld	r24, Z
    7448:	82 60       	ori	r24, 0x02	; 2
    744a:	80 83       	st	Z, r24
	sbi(TCCR1B, CS10);
    744c:	80 81       	ld	r24, Z
    744e:	81 60       	ori	r24, 0x01	; 1
    7450:	80 83       	st	Z, r24
	sbi(TCCR1, CS11);
	sbi(TCCR1, CS10);
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    7452:	e0 e8       	ldi	r30, 0x80	; 128
    7454:	f0 e0       	ldi	r31, 0x00	; 0
    7456:	80 81       	ld	r24, Z
    7458:	81 60       	ori	r24, 0x01	; 1
    745a:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    745c:	e1 eb       	ldi	r30, 0xB1	; 177
    745e:	f0 e0       	ldi	r31, 0x00	; 0
    7460:	80 81       	ld	r24, Z
    7462:	84 60       	ori	r24, 0x04	; 4
    7464:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    7466:	e0 eb       	ldi	r30, 0xB0	; 176
    7468:	f0 e0       	ldi	r31, 0x00	; 0
    746a:	80 81       	ld	r24, Z
    746c:	81 60       	ori	r24, 0x01	; 1
    746e:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    7470:	e1 e9       	ldi	r30, 0x91	; 145
    7472:	f0 e0       	ldi	r31, 0x00	; 0
    7474:	80 81       	ld	r24, Z
    7476:	82 60       	ori	r24, 0x02	; 2
    7478:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    747a:	80 81       	ld	r24, Z
    747c:	81 60       	ori	r24, 0x01	; 1
    747e:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    7480:	e0 e9       	ldi	r30, 0x90	; 144
    7482:	f0 e0       	ldi	r31, 0x00	; 0
    7484:	80 81       	ld	r24, Z
    7486:	81 60       	ori	r24, 0x01	; 1
    7488:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    748a:	ea e7       	ldi	r30, 0x7A	; 122
    748c:	f0 e0       	ldi	r31, 0x00	; 0
    748e:	80 81       	ld	r24, Z
    7490:	84 60       	ori	r24, 0x04	; 4
    7492:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
    7494:	80 81       	ld	r24, Z
    7496:	82 60       	ori	r24, 0x02	; 2
    7498:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
    749a:	80 81       	ld	r24, Z
    749c:	81 60       	ori	r24, 0x01	; 1
    749e:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    74a0:	80 81       	ld	r24, Z
    74a2:	80 68       	ori	r24, 0x80	; 128
    74a4:	80 83       	st	Z, r24
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
#endif
    74a6:	08 95       	ret

000074a8 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
    74a8:	da 01       	movw	r26, r20
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType)
    74aa:	93 30       	cpi	r25, 0x03	; 3
    74ac:	c9 f0       	breq	.+50     	; 0x74e0 <CALLBACK_USB_GetDescriptor+0x38>
    74ae:	94 30       	cpi	r25, 0x04	; 4
    74b0:	30 f4       	brcc	.+12     	; 0x74be <CALLBACK_USB_GetDescriptor+0x16>
    74b2:	91 30       	cpi	r25, 0x01	; 1
    74b4:	59 f0       	breq	.+22     	; 0x74cc <CALLBACK_USB_GetDescriptor+0x24>
    74b6:	92 30       	cpi	r25, 0x02	; 2
    74b8:	09 f0       	breq	.+2      	; 0x74bc <CALLBACK_USB_GetDescriptor+0x14>
    74ba:	40 c0       	rjmp	.+128    	; 0x753c <CALLBACK_USB_GetDescriptor+0x94>
    74bc:	0c c0       	rjmp	.+24     	; 0x74d6 <CALLBACK_USB_GetDescriptor+0x2e>
    74be:	91 32       	cpi	r25, 0x21	; 33
    74c0:	09 f4       	brne	.+2      	; 0x74c4 <CALLBACK_USB_GetDescriptor+0x1c>
    74c2:	32 c0       	rjmp	.+100    	; 0x7528 <CALLBACK_USB_GetDescriptor+0x80>
    74c4:	92 32       	cpi	r25, 0x22	; 34
    74c6:	09 f0       	breq	.+2      	; 0x74ca <CALLBACK_USB_GetDescriptor+0x22>
    74c8:	39 c0       	rjmp	.+114    	; 0x753c <CALLBACK_USB_GetDescriptor+0x94>
    74ca:	33 c0       	rjmp	.+102    	; 0x7532 <CALLBACK_USB_GetDescriptor+0x8a>
    74cc:	e2 e5       	ldi	r30, 0x52	; 82
    74ce:	f2 e0       	ldi	r31, 0x02	; 2
    74d0:	22 e1       	ldi	r18, 0x12	; 18
    74d2:	30 e0       	ldi	r19, 0x00	; 0
    74d4:	37 c0       	rjmp	.+110    	; 0x7544 <CALLBACK_USB_GetDescriptor+0x9c>
    74d6:	e4 e6       	ldi	r30, 0x64	; 100
    74d8:	f2 e0       	ldi	r31, 0x02	; 2
    74da:	26 e6       	ldi	r18, 0x66	; 102
    74dc:	30 e0       	ldi	r19, 0x00	; 0
    74de:	32 c0       	rjmp	.+100    	; 0x7544 <CALLBACK_USB_GetDescriptor+0x9c>
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
            Size    = sizeof(USB_Descriptor_Configuration_t);
            break;
        case DTYPE_String:
            switch (DescriptorNumber)
    74e0:	82 30       	cpi	r24, 0x02	; 2
    74e2:	b1 f0       	breq	.+44     	; 0x7510 <CALLBACK_USB_GetDescriptor+0x68>
    74e4:	83 30       	cpi	r24, 0x03	; 3
    74e6:	28 f4       	brcc	.+10     	; 0x74f2 <CALLBACK_USB_GetDescriptor+0x4a>
    74e8:	88 23       	and	r24, r24
    74ea:	41 f0       	breq	.+16     	; 0x74fc <CALLBACK_USB_GetDescriptor+0x54>
    74ec:	81 30       	cpi	r24, 0x01	; 1
    74ee:	31 f5       	brne	.+76     	; 0x753c <CALLBACK_USB_GetDescriptor+0x94>
    74f0:	09 c0       	rjmp	.+18     	; 0x7504 <CALLBACK_USB_GetDescriptor+0x5c>
    74f2:	83 30       	cpi	r24, 0x03	; 3
    74f4:	89 f0       	breq	.+34     	; 0x7518 <CALLBACK_USB_GetDescriptor+0x70>
    74f6:	84 30       	cpi	r24, 0x04	; 4
    74f8:	09 f5       	brne	.+66     	; 0x753c <CALLBACK_USB_GetDescriptor+0x94>
    74fa:	12 c0       	rjmp	.+36     	; 0x7520 <CALLBACK_USB_GetDescriptor+0x78>
            {
                case 0x00:
                    Address = &LanguageString;
                    Size    = pgm_read_byte(&LanguageString.Header.Size);
    74fc:	ea ec       	ldi	r30, 0xCA	; 202
    74fe:	f2 e0       	ldi	r31, 0x02	; 2
    7500:	84 91       	lpm	r24, Z+
    7502:	03 c0       	rjmp	.+6      	; 0x750a <CALLBACK_USB_GetDescriptor+0x62>
                    break;
                case 0x01:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    7504:	ee ec       	ldi	r30, 0xCE	; 206
    7506:	f2 e0       	ldi	r31, 0x02	; 2
    7508:	84 91       	lpm	r24, Z+
    750a:	28 2f       	mov	r18, r24
    750c:	30 e0       	ldi	r19, 0x00	; 0
    750e:	1a c0       	rjmp	.+52     	; 0x7544 <CALLBACK_USB_GetDescriptor+0x9c>
                    break;
                case 0x02:
                    Address = &ProductString;
                    Size    = pgm_read_byte(&ProductString.Header.Size);
    7510:	ea ee       	ldi	r30, 0xEA	; 234
    7512:	f2 e0       	ldi	r31, 0x02	; 2
    7514:	84 91       	lpm	r24, Z+
    7516:	f9 cf       	rjmp	.-14     	; 0x750a <CALLBACK_USB_GetDescriptor+0x62>
                    break;
                case 0x03:
                    Address = &ProductStringSerial;
                    Size    = pgm_read_byte(&ProductStringSerial.Header.Size);
    7518:	e8 e1       	ldi	r30, 0x18	; 24
    751a:	f3 e0       	ldi	r31, 0x03	; 3
    751c:	84 91       	lpm	r24, Z+
    751e:	f5 cf       	rjmp	.-22     	; 0x750a <CALLBACK_USB_GetDescriptor+0x62>
                    break;
                case 0x04:
                    Address = &ProductStringHID;
                    Size    = pgm_read_byte(&ProductStringHID.Header.Size);
    7520:	e4 e4       	ldi	r30, 0x44	; 68
    7522:	f3 e0       	ldi	r31, 0x03	; 3
    7524:	84 91       	lpm	r24, Z+
    7526:	f1 cf       	rjmp	.-30     	; 0x750a <CALLBACK_USB_GetDescriptor+0x62>
    7528:	e3 eb       	ldi	r30, 0xB3	; 179
    752a:	f2 e0       	ldi	r31, 0x02	; 2
    752c:	29 e0       	ldi	r18, 0x09	; 9
    752e:	30 e0       	ldi	r19, 0x00	; 0
    7530:	09 c0       	rjmp	.+18     	; 0x7544 <CALLBACK_USB_GetDescriptor+0x9c>

            break;
        case HID_DTYPE_HID:
            Address = &ConfigurationDescriptor.HID_GenericHID;
            Size    = sizeof(USB_HID_Descriptor_HID_t);
            break;
    7532:	e1 ea       	ldi	r30, 0xA1	; 161
    7534:	f1 e0       	ldi	r31, 0x01	; 1
    7536:	21 eb       	ldi	r18, 0xB1	; 177
    7538:	30 e0       	ldi	r19, 0x00	; 0
    753a:	04 c0       	rjmp	.+8      	; 0x7544 <CALLBACK_USB_GetDescriptor+0x9c>
    753c:	e0 e0       	ldi	r30, 0x00	; 0
    753e:	f0 e0       	ldi	r31, 0x00	; 0
    7540:	20 e0       	ldi	r18, 0x00	; 0
    7542:	30 e0       	ldi	r19, 0x00	; 0
            Address = &HIDReport;
            Size    = sizeof(HIDReport);
            break;
    }

    *DescriptorAddress = Address;
    7544:	ed 93       	st	X+, r30
    7546:	fc 93       	st	X, r31
    return Size;
}
    7548:	c9 01       	movw	r24, r18
    754a:	08 95       	ret

0000754c <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    754c:	38 2f       	mov	r19, r24
    754e:	28 2f       	mov	r18, r24
    7550:	2c c0       	rjmp	.+88     	; 0x75aa <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7552:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
    7556:	23 17       	cp	r18, r19
    7558:	21 f4       	brne	.+8      	; 0x7562 <Endpoint_ConfigureEndpoint_Prv+0x16>
    755a:	76 2f       	mov	r23, r22
    755c:	94 2f       	mov	r25, r20
    755e:	50 e0       	ldi	r21, 0x00	; 0
    7560:	06 c0       	rjmp	.+12     	; 0x756e <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    7562:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    7566:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    756a:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    756e:	91 ff       	sbrs	r25, 1
    7570:	1b c0       	rjmp	.+54     	; 0x75a8 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    7572:	80 91 eb 00 	lds	r24, 0x00EB
    7576:	8e 7f       	andi	r24, 0xFE	; 254
    7578:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= (1 << ALLOC);
    757c:	80 91 ed 00 	lds	r24, 0x00ED
    7580:	82 70       	andi	r24, 0x02	; 2
    7582:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    7586:	80 91 eb 00 	lds	r24, 0x00EB
    758a:	81 60       	ori	r24, 0x01	; 1
    758c:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    7590:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    7594:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    7598:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    759c:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
    75a0:	87 fd       	sbrc	r24, 7
    75a2:	02 c0       	rjmp	.+4      	; 0x75a8 <Endpoint_ConfigureEndpoint_Prv+0x5c>
    75a4:	80 e0       	ldi	r24, 0x00	; 0
    75a6:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    75a8:	2f 5f       	subi	r18, 0xFF	; 255
    75aa:	27 30       	cpi	r18, 0x07	; 7
    75ac:	90 f2       	brcs	.-92     	; 0x7552 <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    75ae:	30 93 e9 00 	sts	0x00E9, r19
    75b2:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    75b4:	08 95       	ret

000075b6 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    75b6:	80 91 26 09 	lds	r24, 0x0926
    75ba:	88 23       	and	r24, r24
    75bc:	9c f4       	brge	.+38     	; 0x75e4 <Endpoint_ClearStatusStage+0x2e>
    75be:	04 c0       	rjmp	.+8      	; 0x75c8 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    75c0:	80 91 25 09 	lds	r24, 0x0925
    75c4:	88 23       	and	r24, r24
    75c6:	b9 f0       	breq	.+46     	; 0x75f6 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    75c8:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    75cc:	82 ff       	sbrs	r24, 2
    75ce:	f8 cf       	rjmp	.-16     	; 0x75c0 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    75d0:	80 91 e8 00 	lds	r24, 0x00E8
    75d4:	8b 77       	andi	r24, 0x7B	; 123
    75d6:	80 93 e8 00 	sts	0x00E8, r24
    75da:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    75dc:	80 91 25 09 	lds	r24, 0x0925
    75e0:	88 23       	and	r24, r24
    75e2:	49 f0       	breq	.+18     	; 0x75f6 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    75e4:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    75e8:	80 ff       	sbrs	r24, 0
    75ea:	f8 cf       	rjmp	.-16     	; 0x75dc <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    75ec:	80 91 e8 00 	lds	r24, 0x00E8
    75f0:	8e 77       	andi	r24, 0x7E	; 126
    75f2:	80 93 e8 00 	sts	0x00E8, r24
    75f6:	08 95       	ret

000075f8 <Endpoint_WaitUntilReady>:
			 *  the frame number is incremented by one.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    75f8:	40 91 e4 00 	lds	r20, 0x00E4
    75fc:	50 91 e5 00 	lds	r21, 0x00E5
    7600:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & ENDPOINT_DIR_IN);
    7602:	80 91 ec 00 	lds	r24, 0x00EC

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    7606:	80 ff       	sbrs	r24, 0
    7608:	05 c0       	rjmp	.+10     	; 0x7614 <Endpoint_WaitUntilReady+0x1c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    760a:	80 91 e8 00 	lds	r24, 0x00E8
		{
			if (Endpoint_IsINReady())
    760e:	80 ff       	sbrs	r24, 0
    7610:	05 c0       	rjmp	.+10     	; 0x761c <Endpoint_WaitUntilReady+0x24>
    7612:	22 c0       	rjmp	.+68     	; 0x7658 <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7614:	80 91 e8 00 	lds	r24, 0x00E8
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    7618:	82 fd       	sbrc	r24, 2
    761a:	1e c0       	rjmp	.+60     	; 0x7658 <Endpoint_WaitUntilReady+0x60>
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    761c:	80 91 25 09 	lds	r24, 0x0925

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7620:	88 23       	and	r24, r24
    7622:	11 f4       	brne	.+4      	; 0x7628 <Endpoint_WaitUntilReady+0x30>
    7624:	82 e0       	ldi	r24, 0x02	; 2
    7626:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7628:	85 30       	cpi	r24, 0x05	; 5
    762a:	11 f4       	brne	.+4      	; 0x7630 <Endpoint_WaitUntilReady+0x38>
    762c:	83 e0       	ldi	r24, 0x03	; 3
    762e:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    7630:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    7634:	85 ff       	sbrs	r24, 5
    7636:	02 c0       	rjmp	.+4      	; 0x763c <Endpoint_WaitUntilReady+0x44>
    7638:	81 e0       	ldi	r24, 0x01	; 1
    763a:	08 95       	ret
    763c:	80 91 e4 00 	lds	r24, 0x00E4
    7640:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    7644:	84 17       	cp	r24, r20
    7646:	95 07       	cpc	r25, r21
    7648:	e1 f2       	breq	.-72     	; 0x7602 <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    764a:	22 23       	and	r18, r18
    764c:	11 f4       	brne	.+4      	; 0x7652 <Endpoint_WaitUntilReady+0x5a>
    764e:	84 e0       	ldi	r24, 0x04	; 4
    7650:	08 95       	ret
    7652:	21 50       	subi	r18, 0x01	; 1
    7654:	ac 01       	movw	r20, r24
    7656:	d5 cf       	rjmp	.-86     	; 0x7602 <Endpoint_WaitUntilReady+0xa>
    7658:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    765a:	08 95       	ret

0000765c <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    765c:	ef 92       	push	r14
    765e:	ff 92       	push	r15
    7660:	0f 93       	push	r16
    7662:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    7664:	4d d0       	rcall	.+154    	; 0x7700 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    7666:	54 d0       	rcall	.+168    	; 0x7710 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    7668:	08 ed       	ldi	r16, 0xD8	; 216
    766a:	10 e0       	ldi	r17, 0x00	; 0
    766c:	f8 01       	movw	r30, r16
    766e:	80 81       	ld	r24, Z
    7670:	8f 77       	andi	r24, 0x7F	; 127
    7672:	80 83       	st	Z, r24
				USBCON |=  (1 << USBE);
    7674:	80 81       	ld	r24, Z
    7676:	80 68       	ori	r24, 0x80	; 128
    7678:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    767a:	80 81       	ld	r24, Z
    767c:	8f 7d       	andi	r24, 0xDF	; 223
    767e:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    7680:	e7 ed       	ldi	r30, 0xD7	; 215
    7682:	f0 e0       	ldi	r31, 0x00	; 0
    7684:	80 81       	ld	r24, Z
    7686:	80 68       	ori	r24, 0x80	; 128
    7688:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    768a:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState          = DEVICE_STATE_Unattached;
    768c:	10 92 25 09 	sts	0x0925, r1
	USB_ConfigurationNumber  = 0;
    7690:	10 92 23 09 	sts	0x0923, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
    7694:	10 92 22 09 	sts	0x0922, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
    7698:	10 92 21 09 	sts	0x0921, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    769c:	80 ee       	ldi	r24, 0xE0	; 224
    769e:	e8 2e       	mov	r14, r24
    76a0:	f1 2c       	mov	r15, r1
    76a2:	f7 01       	movw	r30, r14
    76a4:	80 81       	ld	r24, Z
    76a6:	8b 7f       	andi	r24, 0xFB	; 251
    76a8:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    76aa:	f8 01       	movw	r30, r16
    76ac:	80 81       	ld	r24, Z
    76ae:	81 60       	ori	r24, 0x01	; 1
    76b0:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
    76b2:	80 e0       	ldi	r24, 0x00	; 0
    76b4:	60 e0       	ldi	r22, 0x00	; 0
    76b6:	42 e0       	ldi	r20, 0x02	; 2
    76b8:	49 df       	rcall	.-366    	; 0x754c <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    76ba:	e1 ee       	ldi	r30, 0xE1	; 225
    76bc:	f0 e0       	ldi	r31, 0x00	; 0
    76be:	80 81       	ld	r24, Z
    76c0:	8e 7f       	andi	r24, 0xFE	; 254
    76c2:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    76c4:	e2 ee       	ldi	r30, 0xE2	; 226
    76c6:	f0 e0       	ldi	r31, 0x00	; 0
    76c8:	80 81       	ld	r24, Z
    76ca:	81 60       	ori	r24, 0x01	; 1
    76cc:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    76ce:	80 81       	ld	r24, Z
    76d0:	88 60       	ori	r24, 0x08	; 8
    76d2:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    76d4:	f7 01       	movw	r30, r14
    76d6:	80 81       	ld	r24, Z
    76d8:	8e 7f       	andi	r24, 0xFE	; 254
    76da:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    76dc:	f8 01       	movw	r30, r16
    76de:	80 81       	ld	r24, Z
    76e0:	80 61       	ori	r24, 0x10	; 16
    76e2:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    76e4:	1f 91       	pop	r17
    76e6:	0f 91       	pop	r16
    76e8:	ff 90       	pop	r15
    76ea:	ef 90       	pop	r14
    76ec:	08 95       	ret

000076ee <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    76ee:	e7 ed       	ldi	r30, 0xD7	; 215
    76f0:	f0 e0       	ldi	r31, 0x00	; 0
    76f2:	80 81       	ld	r24, Z
    76f4:	81 60       	ori	r24, 0x01	; 1
    76f6:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    76f8:	81 e0       	ldi	r24, 0x01	; 1
    76fa:	80 93 24 09 	sts	0x0924, r24

	USB_ResetInterface();
}
    76fe:	ae cf       	rjmp	.-164    	; 0x765c <USB_ResetInterface>

00007700 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    7700:	e8 ed       	ldi	r30, 0xD8	; 216
    7702:	f0 e0       	ldi	r31, 0x00	; 0
    7704:	80 81       	ld	r24, Z
    7706:	8c 7f       	andi	r24, 0xFC	; 252
    7708:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    770a:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    770e:	08 95       	ret

00007710 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    7710:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    7714:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    7718:	08 95       	ret

0000771a <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    771a:	1f 92       	push	r1
    771c:	0f 92       	push	r0
    771e:	0f b6       	in	r0, 0x3f	; 63
    7720:	0f 92       	push	r0
    7722:	0b b6       	in	r0, 0x3b	; 59
    7724:	0f 92       	push	r0
    7726:	11 24       	eor	r1, r1
    7728:	2f 93       	push	r18
    772a:	3f 93       	push	r19
    772c:	4f 93       	push	r20
    772e:	5f 93       	push	r21
    7730:	6f 93       	push	r22
    7732:	7f 93       	push	r23
    7734:	8f 93       	push	r24
    7736:	9f 93       	push	r25
    7738:	af 93       	push	r26
    773a:	bf 93       	push	r27
    773c:	ef 93       	push	r30
    773e:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    7740:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    7744:	82 ff       	sbrs	r24, 2
    7746:	0a c0       	rjmp	.+20     	; 0x775c <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    7748:	80 91 e2 00 	lds	r24, 0x00E2
    774c:	82 ff       	sbrs	r24, 2
    774e:	06 c0       	rjmp	.+12     	; 0x775c <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    7750:	80 91 e1 00 	lds	r24, 0x00E1
    7754:	8b 7f       	andi	r24, 0xFB	; 251
    7756:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    775a:	d1 d3       	rcall	.+1954   	; 0x7efe <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    775c:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    7760:	80 ff       	sbrs	r24, 0
    7762:	1f c0       	rjmp	.+62     	; 0x77a2 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    7764:	80 91 d8 00 	lds	r24, 0x00D8
    7768:	80 ff       	sbrs	r24, 0
    776a:	1b c0       	rjmp	.+54     	; 0x77a2 <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    776c:	80 91 da 00 	lds	r24, 0x00DA
    7770:	8e 7f       	andi	r24, 0xFE	; 254
    7772:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    7776:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    777a:	80 ff       	sbrs	r24, 0
    777c:	0d c0       	rjmp	.+26     	; 0x7798 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    777e:	84 e1       	ldi	r24, 0x14	; 20
    7780:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    7782:	86 e1       	ldi	r24, 0x16	; 22
    7784:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    7786:	09 b4       	in	r0, 0x29	; 41
    7788:	00 fe       	sbrs	r0, 0
    778a:	fd cf       	rjmp	.-6      	; 0x7786 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    778c:	81 e0       	ldi	r24, 0x01	; 1
    778e:	80 93 25 09 	sts	0x0925, r24
			EVENT_USB_Device_Connect();
    7792:	0e 94 ff 01 	call	0x3fe	; 0x3fe <EVENT_USB_Device_Connect>
    7796:	05 c0       	rjmp	.+10     	; 0x77a2 <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    7798:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    779a:	10 92 25 09 	sts	0x0925, r1
			EVENT_USB_Device_Disconnect();
    779e:	0e 94 04 02 	call	0x408	; 0x408 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    77a2:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    77a6:	80 ff       	sbrs	r24, 0
    77a8:	18 c0       	rjmp	.+48     	; 0x77da <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    77aa:	80 91 e2 00 	lds	r24, 0x00E2
    77ae:	80 ff       	sbrs	r24, 0
    77b0:	14 c0       	rjmp	.+40     	; 0x77da <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    77b2:	80 91 e2 00 	lds	r24, 0x00E2
    77b6:	8e 7f       	andi	r24, 0xFE	; 254
    77b8:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    77bc:	80 91 e2 00 	lds	r24, 0x00E2
    77c0:	80 61       	ori	r24, 0x10	; 16
    77c2:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    77c6:	80 91 d8 00 	lds	r24, 0x00D8
    77ca:	80 62       	ori	r24, 0x20	; 32
    77cc:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    77d0:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    77d2:	85 e0       	ldi	r24, 0x05	; 5
    77d4:	80 93 25 09 	sts	0x0925, r24
		EVENT_USB_Device_Suspend();
    77d8:	92 d3       	rcall	.+1828   	; 0x7efe <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    77da:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    77de:	84 ff       	sbrs	r24, 4
    77e0:	2d c0       	rjmp	.+90     	; 0x783c <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    77e2:	80 91 e2 00 	lds	r24, 0x00E2
    77e6:	84 ff       	sbrs	r24, 4
    77e8:	29 c0       	rjmp	.+82     	; 0x783c <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    77ea:	84 e1       	ldi	r24, 0x14	; 20
    77ec:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    77ee:	86 e1       	ldi	r24, 0x16	; 22
    77f0:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    77f2:	09 b4       	in	r0, 0x29	; 41
    77f4:	00 fe       	sbrs	r0, 0
    77f6:	fd cf       	rjmp	.-6      	; 0x77f2 <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    77f8:	80 91 d8 00 	lds	r24, 0x00D8
    77fc:	8f 7d       	andi	r24, 0xDF	; 223
    77fe:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    7802:	80 91 e1 00 	lds	r24, 0x00E1
    7806:	8f 7e       	andi	r24, 0xEF	; 239
    7808:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    780c:	80 91 e2 00 	lds	r24, 0x00E2
    7810:	8f 7e       	andi	r24, 0xEF	; 239
    7812:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    7816:	80 91 e2 00 	lds	r24, 0x00E2
    781a:	81 60       	ori	r24, 0x01	; 1
    781c:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_ConfigurationNumber)
    7820:	80 91 23 09 	lds	r24, 0x0923
    7824:	88 23       	and	r24, r24
    7826:	31 f4       	brne	.+12     	; 0x7834 <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    7828:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    782c:	87 fd       	sbrc	r24, 7
    782e:	02 c0       	rjmp	.+4      	; 0x7834 <__vector_10+0x11a>
    7830:	81 e0       	ldi	r24, 0x01	; 1
    7832:	01 c0       	rjmp	.+2      	; 0x7836 <__vector_10+0x11c>
    7834:	84 e0       	ldi	r24, 0x04	; 4
    7836:	80 93 25 09 	sts	0x0925, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    783a:	61 d3       	rcall	.+1730   	; 0x7efe <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    783c:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    7840:	83 ff       	sbrs	r24, 3
    7842:	22 c0       	rjmp	.+68     	; 0x7888 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    7844:	80 91 e2 00 	lds	r24, 0x00E2
    7848:	83 ff       	sbrs	r24, 3
    784a:	1e c0       	rjmp	.+60     	; 0x7888 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    784c:	80 91 e1 00 	lds	r24, 0x00E1
    7850:	87 7f       	andi	r24, 0xF7	; 247
    7852:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState         = DEVICE_STATE_Default;
    7856:	82 e0       	ldi	r24, 0x02	; 2
    7858:	80 93 25 09 	sts	0x0925, r24
		USB_ConfigurationNumber = 0;
    785c:	10 92 23 09 	sts	0x0923, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    7860:	80 91 e1 00 	lds	r24, 0x00E1
    7864:	8e 7f       	andi	r24, 0xFE	; 254
    7866:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    786a:	80 91 e2 00 	lds	r24, 0x00E2
    786e:	8e 7f       	andi	r24, 0xFE	; 254
    7870:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    7874:	80 91 e2 00 	lds	r24, 0x00E2
    7878:	80 61       	ori	r24, 0x10	; 16
    787a:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | Direction),
    787e:	80 e0       	ldi	r24, 0x00	; 0
    7880:	60 e0       	ldi	r22, 0x00	; 0
    7882:	42 e0       	ldi	r20, 0x02	; 2
    7884:	63 de       	rcall	.-826    	; 0x754c <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    7886:	3b d3       	rcall	.+1654   	; 0x7efe <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    7888:	ff 91       	pop	r31
    788a:	ef 91       	pop	r30
    788c:	bf 91       	pop	r27
    788e:	af 91       	pop	r26
    7890:	9f 91       	pop	r25
    7892:	8f 91       	pop	r24
    7894:	7f 91       	pop	r23
    7896:	6f 91       	pop	r22
    7898:	5f 91       	pop	r21
    789a:	4f 91       	pop	r20
    789c:	3f 91       	pop	r19
    789e:	2f 91       	pop	r18
    78a0:	0f 90       	pop	r0
    78a2:	0b be       	out	0x3b, r0	; 59
    78a4:	0f 90       	pop	r0
    78a6:	0f be       	out	0x3f, r0	; 63
    78a8:	0f 90       	pop	r0
    78aa:	1f 90       	pop	r1
    78ac:	18 95       	reti

000078ae <Endpoint_Write_Control_Stream_LE>:
    78ae:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    78b0:	40 91 2c 09 	lds	r20, 0x092C
    78b4:	50 91 2d 09 	lds	r21, 0x092D
    78b8:	46 17       	cp	r20, r22
    78ba:	57 07       	cpc	r21, r23
    78bc:	18 f4       	brcc	.+6      	; 0x78c4 <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    78be:	f9 01       	movw	r30, r18
    78c0:	90 e0       	ldi	r25, 0x00	; 0
    78c2:	3d c0       	rjmp	.+122    	; 0x793e <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    78c4:	61 15       	cp	r22, r1
    78c6:	71 05       	cpc	r23, r1
    78c8:	11 f0       	breq	.+4      	; 0x78ce <Endpoint_Write_Control_Stream_LE+0x20>
    78ca:	ab 01       	movw	r20, r22
    78cc:	f8 cf       	rjmp	.-16     	; 0x78be <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    78ce:	80 91 e8 00 	lds	r24, 0x00E8
    78d2:	8e 77       	andi	r24, 0x7E	; 126
    78d4:	80 93 e8 00 	sts	0x00E8, r24
    78d8:	40 e0       	ldi	r20, 0x00	; 0
    78da:	50 e0       	ldi	r21, 0x00	; 0
    78dc:	f0 cf       	rjmp	.-32     	; 0x78be <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    78de:	80 91 25 09 	lds	r24, 0x0925

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    78e2:	88 23       	and	r24, r24
    78e4:	f1 f1       	breq	.+124    	; 0x7962 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    78e6:	85 30       	cpi	r24, 0x05	; 5
    78e8:	f1 f1       	breq	.+124    	; 0x7966 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    78ea:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    78ee:	83 ff       	sbrs	r24, 3
    78f0:	02 c0       	rjmp	.+4      	; 0x78f6 <Endpoint_Write_Control_Stream_LE+0x48>
    78f2:	81 e0       	ldi	r24, 0x01	; 1
    78f4:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    78f6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    78fa:	82 fd       	sbrc	r24, 2
    78fc:	2c c0       	rjmp	.+88     	; 0x7956 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    78fe:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    7902:	80 ff       	sbrs	r24, 0
    7904:	1c c0       	rjmp	.+56     	; 0x793e <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    7906:	20 91 f2 00 	lds	r18, 0x00F2
    790a:	30 91 f3 00 	lds	r19, 0x00F3
    790e:	07 c0       	rjmp	.+14     	; 0x791e <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    7910:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7912:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    7916:	41 50       	subi	r20, 0x01	; 1
    7918:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    791a:	2f 5f       	subi	r18, 0xFF	; 255
    791c:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    791e:	41 15       	cp	r20, r1
    7920:	51 05       	cpc	r21, r1
    7922:	19 f0       	breq	.+6      	; 0x792a <Endpoint_Write_Control_Stream_LE+0x7c>
    7924:	28 30       	cpi	r18, 0x08	; 8
    7926:	31 05       	cpc	r19, r1
    7928:	98 f3       	brcs	.-26     	; 0x7910 <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    792a:	90 e0       	ldi	r25, 0x00	; 0
    792c:	28 30       	cpi	r18, 0x08	; 8
    792e:	31 05       	cpc	r19, r1
    7930:	09 f4       	brne	.+2      	; 0x7934 <Endpoint_Write_Control_Stream_LE+0x86>
    7932:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7934:	80 91 e8 00 	lds	r24, 0x00E8
    7938:	8e 77       	andi	r24, 0x7E	; 126
    793a:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    793e:	41 15       	cp	r20, r1
    7940:	51 05       	cpc	r21, r1
    7942:	69 f6       	brne	.-102    	; 0x78de <Endpoint_Write_Control_Stream_LE+0x30>
    7944:	99 23       	and	r25, r25
    7946:	59 f6       	brne	.-106    	; 0x78de <Endpoint_Write_Control_Stream_LE+0x30>
    7948:	06 c0       	rjmp	.+12     	; 0x7956 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    794a:	80 91 25 09 	lds	r24, 0x0925

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    794e:	88 23       	and	r24, r24
    7950:	41 f0       	breq	.+16     	; 0x7962 <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7952:	85 30       	cpi	r24, 0x05	; 5
    7954:	41 f0       	breq	.+16     	; 0x7966 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7956:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    795a:	82 ff       	sbrs	r24, 2
    795c:	f6 cf       	rjmp	.-20     	; 0x794a <Endpoint_Write_Control_Stream_LE+0x9c>
    795e:	80 e0       	ldi	r24, 0x00	; 0
    7960:	08 95       	ret
    7962:	82 e0       	ldi	r24, 0x02	; 2
    7964:	08 95       	ret
    7966:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    7968:	08 95       	ret

0000796a <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    796a:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    796c:	61 15       	cp	r22, r1
    796e:	71 05       	cpc	r23, r1
    7970:	29 f4       	brne	.+10     	; 0x797c <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7972:	80 91 e8 00 	lds	r24, 0x00E8
    7976:	8b 77       	andi	r24, 0x7B	; 123
    7978:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    797c:	f9 01       	movw	r30, r18
    797e:	22 c0       	rjmp	.+68     	; 0x79c4 <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7980:	80 91 25 09 	lds	r24, 0x0925

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7984:	88 23       	and	r24, r24
    7986:	71 f1       	breq	.+92     	; 0x79e4 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7988:	85 30       	cpi	r24, 0x05	; 5
    798a:	71 f1       	breq	.+92     	; 0x79e8 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    798c:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    7990:	83 ff       	sbrs	r24, 3
    7992:	02 c0       	rjmp	.+4      	; 0x7998 <Endpoint_Read_Control_Stream_LE+0x2e>
    7994:	81 e0       	ldi	r24, 0x01	; 1
    7996:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7998:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    799c:	82 ff       	sbrs	r24, 2
    799e:	f0 cf       	rjmp	.-32     	; 0x7980 <Endpoint_Read_Control_Stream_LE+0x16>
    79a0:	06 c0       	rjmp	.+12     	; 0x79ae <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    79a2:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    79a6:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    79a8:	61 50       	subi	r22, 0x01	; 1
    79aa:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    79ac:	31 f0       	breq	.+12     	; 0x79ba <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    79ae:	80 91 f2 00 	lds	r24, 0x00F2
    79b2:	90 91 f3 00 	lds	r25, 0x00F3
    79b6:	89 2b       	or	r24, r25
    79b8:	a1 f7       	brne	.-24     	; 0x79a2 <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    79ba:	80 91 e8 00 	lds	r24, 0x00E8
    79be:	8b 77       	andi	r24, 0x7B	; 123
    79c0:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    79c4:	61 15       	cp	r22, r1
    79c6:	71 05       	cpc	r23, r1
    79c8:	d9 f6       	brne	.-74     	; 0x7980 <Endpoint_Read_Control_Stream_LE+0x16>
    79ca:	06 c0       	rjmp	.+12     	; 0x79d8 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    79cc:	80 91 25 09 	lds	r24, 0x0925

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    79d0:	88 23       	and	r24, r24
    79d2:	41 f0       	breq	.+16     	; 0x79e4 <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    79d4:	85 30       	cpi	r24, 0x05	; 5
    79d6:	41 f0       	breq	.+16     	; 0x79e8 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    79d8:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    79dc:	80 ff       	sbrs	r24, 0
    79de:	f6 cf       	rjmp	.-20     	; 0x79cc <Endpoint_Read_Control_Stream_LE+0x62>
    79e0:	80 e0       	ldi	r24, 0x00	; 0
    79e2:	08 95       	ret
    79e4:	82 e0       	ldi	r24, 0x02	; 2
    79e6:	08 95       	ret
    79e8:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    79ea:	08 95       	ret

000079ec <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    79ec:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    79ee:	40 91 2c 09 	lds	r20, 0x092C
    79f2:	50 91 2d 09 	lds	r21, 0x092D
    79f6:	46 17       	cp	r20, r22
    79f8:	57 07       	cpc	r21, r23
    79fa:	18 f4       	brcc	.+6      	; 0x7a02 <Endpoint_Write_Control_PStream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    79fc:	f9 01       	movw	r30, r18
    79fe:	90 e0       	ldi	r25, 0x00	; 0
    7a00:	40 c0       	rjmp	.+128    	; 0x7a82 <Endpoint_Write_Control_PStream_LE+0x96>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    7a02:	61 15       	cp	r22, r1
    7a04:	71 05       	cpc	r23, r1
    7a06:	11 f0       	breq	.+4      	; 0x7a0c <Endpoint_Write_Control_PStream_LE+0x20>
    7a08:	ab 01       	movw	r20, r22
    7a0a:	f8 cf       	rjmp	.-16     	; 0x79fc <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7a0c:	80 91 e8 00 	lds	r24, 0x00E8
    7a10:	8e 77       	andi	r24, 0x7E	; 126
    7a12:	80 93 e8 00 	sts	0x00E8, r24
    7a16:	40 e0       	ldi	r20, 0x00	; 0
    7a18:	50 e0       	ldi	r21, 0x00	; 0
    7a1a:	f0 cf       	rjmp	.-32     	; 0x79fc <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7a1c:	80 91 25 09 	lds	r24, 0x0925

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7a20:	88 23       	and	r24, r24
    7a22:	09 f4       	brne	.+2      	; 0x7a26 <Endpoint_Write_Control_PStream_LE+0x3a>
    7a24:	40 c0       	rjmp	.+128    	; 0x7aa6 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7a26:	85 30       	cpi	r24, 0x05	; 5
    7a28:	09 f4       	brne	.+2      	; 0x7a2c <Endpoint_Write_Control_PStream_LE+0x40>
    7a2a:	3f c0       	rjmp	.+126    	; 0x7aaa <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7a2c:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    7a30:	83 ff       	sbrs	r24, 3
    7a32:	02 c0       	rjmp	.+4      	; 0x7a38 <Endpoint_Write_Control_PStream_LE+0x4c>
    7a34:	81 e0       	ldi	r24, 0x01	; 1
    7a36:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7a38:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    7a3c:	82 fd       	sbrc	r24, 2
    7a3e:	2d c0       	rjmp	.+90     	; 0x7a9a <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7a40:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    7a44:	80 ff       	sbrs	r24, 0
    7a46:	1d c0       	rjmp	.+58     	; 0x7a82 <Endpoint_Write_Control_PStream_LE+0x96>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    7a48:	20 91 f2 00 	lds	r18, 0x00F2
    7a4c:	30 91 f3 00 	lds	r19, 0x00F3
    7a50:	08 c0       	rjmp	.+16     	; 0x7a62 <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    7a52:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7a54:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    7a58:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    7a5a:	41 50       	subi	r20, 0x01	; 1
    7a5c:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    7a5e:	2f 5f       	subi	r18, 0xFF	; 255
    7a60:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    7a62:	41 15       	cp	r20, r1
    7a64:	51 05       	cpc	r21, r1
    7a66:	19 f0       	breq	.+6      	; 0x7a6e <Endpoint_Write_Control_PStream_LE+0x82>
    7a68:	28 30       	cpi	r18, 0x08	; 8
    7a6a:	31 05       	cpc	r19, r1
    7a6c:	90 f3       	brcs	.-28     	; 0x7a52 <Endpoint_Write_Control_PStream_LE+0x66>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    7a6e:	90 e0       	ldi	r25, 0x00	; 0
    7a70:	28 30       	cpi	r18, 0x08	; 8
    7a72:	31 05       	cpc	r19, r1
    7a74:	09 f4       	brne	.+2      	; 0x7a78 <Endpoint_Write_Control_PStream_LE+0x8c>
    7a76:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7a78:	80 91 e8 00 	lds	r24, 0x00E8
    7a7c:	8e 77       	andi	r24, 0x7E	; 126
    7a7e:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    7a82:	41 15       	cp	r20, r1
    7a84:	51 05       	cpc	r21, r1
    7a86:	51 f6       	brne	.-108    	; 0x7a1c <Endpoint_Write_Control_PStream_LE+0x30>
    7a88:	99 23       	and	r25, r25
    7a8a:	41 f6       	brne	.-112    	; 0x7a1c <Endpoint_Write_Control_PStream_LE+0x30>
    7a8c:	06 c0       	rjmp	.+12     	; 0x7a9a <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    7a8e:	80 91 25 09 	lds	r24, 0x0925

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    7a92:	88 23       	and	r24, r24
    7a94:	41 f0       	breq	.+16     	; 0x7aa6 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    7a96:	85 30       	cpi	r24, 0x05	; 5
    7a98:	41 f0       	breq	.+16     	; 0x7aaa <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    7a9a:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    7a9e:	82 ff       	sbrs	r24, 2
    7aa0:	f6 cf       	rjmp	.-20     	; 0x7a8e <Endpoint_Write_Control_PStream_LE+0xa2>
    7aa2:	80 e0       	ldi	r24, 0x00	; 0
    7aa4:	08 95       	ret
    7aa6:	82 e0       	ldi	r24, 0x02	; 2
    7aa8:	08 95       	ret
    7aaa:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    7aac:	08 95       	ret

00007aae <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    7aae:	bf 92       	push	r11
    7ab0:	cf 92       	push	r12
    7ab2:	df 92       	push	r13
    7ab4:	ef 92       	push	r14
    7ab6:	ff 92       	push	r15
    7ab8:	0f 93       	push	r16
    7aba:	1f 93       	push	r17
    7abc:	cf 93       	push	r28
    7abe:	df 93       	push	r29
    7ac0:	18 2f       	mov	r17, r24
    7ac2:	09 2f       	mov	r16, r25
    7ac4:	7b 01       	movw	r14, r22
    7ac6:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    7ac8:	97 dd       	rcall	.-1234   	; 0x75f8 <Endpoint_WaitUntilReady>
    7aca:	b8 2e       	mov	r11, r24
    7acc:	88 23       	and	r24, r24
    7ace:	b1 f5       	brne	.+108    	; 0x7b3c <Endpoint_Read_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    7ad0:	81 2f       	mov	r24, r17
    7ad2:	90 2f       	mov	r25, r16
    7ad4:	9c 01       	movw	r18, r24
    7ad6:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    7ad8:	c1 14       	cp	r12, r1
    7ada:	d1 04       	cpc	r13, r1
    7adc:	39 f0       	breq	.+14     	; 0x7aec <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    7ade:	f6 01       	movw	r30, r12
    7ae0:	80 81       	ld	r24, Z
    7ae2:	91 81       	ldd	r25, Z+1	; 0x01
    7ae4:	e8 1a       	sub	r14, r24
    7ae6:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    7ae8:	c8 0f       	add	r28, r24
    7aea:	d9 1f       	adc	r29, r25
    7aec:	00 e0       	ldi	r16, 0x00	; 0
    7aee:	10 e0       	ldi	r17, 0x00	; 0
    7af0:	22 c0       	rjmp	.+68     	; 0x7b36 <Endpoint_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    7af2:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    7af6:	85 fd       	sbrc	r24, 5
    7af8:	16 c0       	rjmp	.+44     	; 0x7b26 <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7afa:	80 91 e8 00 	lds	r24, 0x00E8
    7afe:	8b 77       	andi	r24, 0x7B	; 123
    7b00:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    7b04:	c1 14       	cp	r12, r1
    7b06:	d1 04       	cpc	r13, r1
    7b08:	49 f0       	breq	.+18     	; 0x7b1c <Endpoint_Read_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    7b0a:	f6 01       	movw	r30, r12
    7b0c:	80 81       	ld	r24, Z
    7b0e:	91 81       	ldd	r25, Z+1	; 0x01
    7b10:	80 0f       	add	r24, r16
    7b12:	91 1f       	adc	r25, r17
    7b14:	91 83       	std	Z+1, r25	; 0x01
    7b16:	80 83       	st	Z, r24
    7b18:	85 e0       	ldi	r24, 0x05	; 5
    7b1a:	11 c0       	rjmp	.+34     	; 0x7b3e <Endpoint_Read_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    7b1c:	f1 d1       	rcall	.+994    	; 0x7f00 <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    7b1e:	6c dd       	rcall	.-1320   	; 0x75f8 <Endpoint_WaitUntilReady>
    7b20:	88 23       	and	r24, r24
    7b22:	49 f0       	breq	.+18     	; 0x7b36 <Endpoint_Read_Stream_LE+0x88>
    7b24:	0c c0       	rjmp	.+24     	; 0x7b3e <Endpoint_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    7b26:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    7b2a:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    7b2c:	08 94       	sec
    7b2e:	e1 08       	sbc	r14, r1
    7b30:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    7b32:	0f 5f       	subi	r16, 0xFF	; 255
    7b34:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    7b36:	e1 14       	cp	r14, r1
    7b38:	f1 04       	cpc	r15, r1
    7b3a:	d9 f6       	brne	.-74     	; 0x7af2 <Endpoint_Read_Stream_LE+0x44>
    7b3c:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    7b3e:	df 91       	pop	r29
    7b40:	cf 91       	pop	r28
    7b42:	1f 91       	pop	r17
    7b44:	0f 91       	pop	r16
    7b46:	ff 90       	pop	r15
    7b48:	ef 90       	pop	r14
    7b4a:	df 90       	pop	r13
    7b4c:	cf 90       	pop	r12
    7b4e:	bf 90       	pop	r11
    7b50:	08 95       	ret

00007b52 <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    7b52:	bf 92       	push	r11
    7b54:	cf 92       	push	r12
    7b56:	df 92       	push	r13
    7b58:	ef 92       	push	r14
    7b5a:	ff 92       	push	r15
    7b5c:	0f 93       	push	r16
    7b5e:	1f 93       	push	r17
    7b60:	cf 93       	push	r28
    7b62:	df 93       	push	r29
    7b64:	18 2f       	mov	r17, r24
    7b66:	09 2f       	mov	r16, r25
    7b68:	7b 01       	movw	r14, r22
    7b6a:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    7b6c:	45 dd       	rcall	.-1398   	; 0x75f8 <Endpoint_WaitUntilReady>
    7b6e:	b8 2e       	mov	r11, r24
    7b70:	88 23       	and	r24, r24
    7b72:	b1 f5       	brne	.+108    	; 0x7be0 <Endpoint_Write_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    7b74:	81 2f       	mov	r24, r17
    7b76:	90 2f       	mov	r25, r16
    7b78:	9c 01       	movw	r18, r24
    7b7a:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    7b7c:	c1 14       	cp	r12, r1
    7b7e:	d1 04       	cpc	r13, r1
    7b80:	39 f0       	breq	.+14     	; 0x7b90 <Endpoint_Write_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    7b82:	f6 01       	movw	r30, r12
    7b84:	80 81       	ld	r24, Z
    7b86:	91 81       	ldd	r25, Z+1	; 0x01
    7b88:	e8 1a       	sub	r14, r24
    7b8a:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    7b8c:	c8 0f       	add	r28, r24
    7b8e:	d9 1f       	adc	r29, r25
    7b90:	00 e0       	ldi	r16, 0x00	; 0
    7b92:	10 e0       	ldi	r17, 0x00	; 0
    7b94:	22 c0       	rjmp	.+68     	; 0x7bda <Endpoint_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    7b96:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    7b9a:	85 fd       	sbrc	r24, 5
    7b9c:	16 c0       	rjmp	.+44     	; 0x7bca <Endpoint_Write_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7b9e:	80 91 e8 00 	lds	r24, 0x00E8
    7ba2:	8e 77       	andi	r24, 0x7E	; 126
    7ba4:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			if (BytesProcessed != NULL)
    7ba8:	c1 14       	cp	r12, r1
    7baa:	d1 04       	cpc	r13, r1
    7bac:	49 f0       	breq	.+18     	; 0x7bc0 <Endpoint_Write_Stream_LE+0x6e>
			{
				*BytesProcessed += BytesInTransfer;
    7bae:	f6 01       	movw	r30, r12
    7bb0:	80 81       	ld	r24, Z
    7bb2:	91 81       	ldd	r25, Z+1	; 0x01
    7bb4:	80 0f       	add	r24, r16
    7bb6:	91 1f       	adc	r25, r17
    7bb8:	91 83       	std	Z+1, r25	; 0x01
    7bba:	80 83       	st	Z, r24
    7bbc:	85 e0       	ldi	r24, 0x05	; 5
    7bbe:	11 c0       	rjmp	.+34     	; 0x7be2 <Endpoint_Write_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    7bc0:	9f d1       	rcall	.+830    	; 0x7f00 <USB_USBTask>
			#endif

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    7bc2:	1a dd       	rcall	.-1484   	; 0x75f8 <Endpoint_WaitUntilReady>
    7bc4:	88 23       	and	r24, r24
    7bc6:	49 f0       	breq	.+18     	; 0x7bda <Endpoint_Write_Stream_LE+0x88>
    7bc8:	0c c0       	rjmp	.+24     	; 0x7be2 <Endpoint_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    7bca:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7bcc:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    7bd0:	08 94       	sec
    7bd2:	e1 08       	sbc	r14, r1
    7bd4:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    7bd6:	0f 5f       	subi	r16, 0xFF	; 255
    7bd8:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    7bda:	e1 14       	cp	r14, r1
    7bdc:	f1 04       	cpc	r15, r1
    7bde:	d9 f6       	brne	.-74     	; 0x7b96 <Endpoint_Write_Stream_LE+0x44>
    7be0:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    7be2:	df 91       	pop	r29
    7be4:	cf 91       	pop	r28
    7be6:	1f 91       	pop	r17
    7be8:	0f 91       	pop	r16
    7bea:	ff 90       	pop	r15
    7bec:	ef 90       	pop	r14
    7bee:	df 90       	pop	r13
    7bf0:	cf 90       	pop	r12
    7bf2:	bf 90       	pop	r11
    7bf4:	08 95       	ret

00007bf6 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    7bf6:	0f 93       	push	r16
    7bf8:	1f 93       	push	r17
    7bfa:	df 93       	push	r29
    7bfc:	cf 93       	push	r28
    7bfe:	cd b7       	in	r28, 0x3d	; 61
    7c00:	de b7       	in	r29, 0x3e	; 62
    7c02:	ac 97       	sbiw	r28, 0x2c	; 44
    7c04:	0f b6       	in	r0, 0x3f	; 63
    7c06:	f8 94       	cli
    7c08:	de bf       	out	0x3e, r29	; 62
    7c0a:	0f be       	out	0x3f, r0	; 63
    7c0c:	cd bf       	out	0x3d, r28	; 61
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    7c0e:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bmRequestType = Endpoint_Read_8();
    7c12:	80 93 26 09 	sts	0x0926, r24
    7c16:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
    7c1a:	80 93 27 09 	sts	0x0927, r24
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    7c1e:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    7c22:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
    7c26:	e8 e2       	ldi	r30, 0x28	; 40
    7c28:	f9 e0       	ldi	r31, 0x09	; 9
    7c2a:	80 93 28 09 	sts	0x0928, r24
    7c2e:	90 93 29 09 	sts	0x0929, r25
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    7c32:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    7c36:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
    7c3a:	80 93 2a 09 	sts	0x092A, r24
    7c3e:	93 83       	std	Z+3, r25	; 0x03
				{
					uint16_t Value;
					uint8_t  Bytes[2];
				} Data;

				Data.Bytes[0] = UEDATX;
    7c40:	80 91 f1 00 	lds	r24, 0x00F1
				Data.Bytes[1] = UEDATX;
    7c44:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
    7c48:	80 93 2c 09 	sts	0x092C, r24
    7c4c:	95 83       	std	Z+5, r25	; 0x05

	EVENT_USB_Device_ControlRequest();
    7c4e:	0e 94 ed 02 	call	0x5da	; 0x5da <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7c52:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    7c56:	83 ff       	sbrs	r24, 3
    7c58:	39 c1       	rjmp	.+626    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    7c5a:	80 91 26 09 	lds	r24, 0x0926

		switch (USB_ControlRequest.bRequest)
    7c5e:	30 91 27 09 	lds	r19, 0x0927
    7c62:	35 30       	cpi	r19, 0x05	; 5
    7c64:	09 f4       	brne	.+2      	; 0x7c68 <USB_Device_ProcessControlRequest+0x72>
    7c66:	87 c0       	rjmp	.+270    	; 0x7d76 <USB_Device_ProcessControlRequest+0x180>
    7c68:	36 30       	cpi	r19, 0x06	; 6
    7c6a:	40 f4       	brcc	.+16     	; 0x7c7c <USB_Device_ProcessControlRequest+0x86>
    7c6c:	31 30       	cpi	r19, 0x01	; 1
    7c6e:	c9 f1       	breq	.+114    	; 0x7ce2 <USB_Device_ProcessControlRequest+0xec>
    7c70:	31 30       	cpi	r19, 0x01	; 1
    7c72:	70 f0       	brcs	.+28     	; 0x7c90 <USB_Device_ProcessControlRequest+0x9a>
    7c74:	33 30       	cpi	r19, 0x03	; 3
    7c76:	09 f0       	breq	.+2      	; 0x7c7a <USB_Device_ProcessControlRequest+0x84>
    7c78:	29 c1       	rjmp	.+594    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
    7c7a:	33 c0       	rjmp	.+102    	; 0x7ce2 <USB_Device_ProcessControlRequest+0xec>
    7c7c:	38 30       	cpi	r19, 0x08	; 8
    7c7e:	09 f4       	brne	.+2      	; 0x7c82 <USB_Device_ProcessControlRequest+0x8c>
    7c80:	f6 c0       	rjmp	.+492    	; 0x7e6e <USB_Device_ProcessControlRequest+0x278>
    7c82:	39 30       	cpi	r19, 0x09	; 9
    7c84:	09 f4       	brne	.+2      	; 0x7c88 <USB_Device_ProcessControlRequest+0x92>
    7c86:	05 c1       	rjmp	.+522    	; 0x7e92 <USB_Device_ProcessControlRequest+0x29c>
    7c88:	36 30       	cpi	r19, 0x06	; 6
    7c8a:	09 f0       	breq	.+2      	; 0x7c8e <USB_Device_ProcessControlRequest+0x98>
    7c8c:	1f c1       	rjmp	.+574    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
    7c8e:	97 c0       	rjmp	.+302    	; 0x7dbe <USB_Device_ProcessControlRequest+0x1c8>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7c90:	80 38       	cpi	r24, 0x80	; 128
    7c92:	21 f0       	breq	.+8      	; 0x7c9c <USB_Device_ProcessControlRequest+0xa6>
    7c94:	82 38       	cpi	r24, 0x82	; 130
    7c96:	09 f0       	breq	.+2      	; 0x7c9a <USB_Device_ProcessControlRequest+0xa4>
    7c98:	19 c1       	rjmp	.+562    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
    7c9a:	08 c0       	rjmp	.+16     	; 0x7cac <USB_Device_ProcessControlRequest+0xb6>
    7c9c:	90 91 21 09 	lds	r25, 0x0921
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_RemoteWakeupEnabled)
    7ca0:	80 91 22 09 	lds	r24, 0x0922
    7ca4:	88 23       	and	r24, r24
    7ca6:	99 f0       	breq	.+38     	; 0x7cce <USB_Device_ProcessControlRequest+0xd8>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    7ca8:	92 60       	ori	r25, 0x02	; 2
    7caa:	11 c0       	rjmp	.+34     	; 0x7cce <USB_Device_ProcessControlRequest+0xd8>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    7cac:	80 91 2a 09 	lds	r24, 0x092A
    7cb0:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7cb2:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    7cb6:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    7cba:	90 e0       	ldi	r25, 0x00	; 0
    7cbc:	25 e0       	ldi	r18, 0x05	; 5
    7cbe:	96 95       	lsr	r25
    7cc0:	87 95       	ror	r24
    7cc2:	2a 95       	dec	r18
    7cc4:	e1 f7       	brne	.-8      	; 0x7cbe <USB_Device_ProcessControlRequest+0xc8>
    7cc6:	98 2f       	mov	r25, r24
    7cc8:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7cca:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7cce:	80 91 e8 00 	lds	r24, 0x00E8
    7cd2:	87 7f       	andi	r24, 0xF7	; 247
    7cd4:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    7cd8:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    7cdc:	10 92 f1 00 	sts	0x00F1, r1
    7ce0:	d1 c0       	rjmp	.+418    	; 0x7e84 <USB_Device_ProcessControlRequest+0x28e>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7ce2:	88 23       	and	r24, r24
    7ce4:	19 f0       	breq	.+6      	; 0x7cec <USB_Device_ProcessControlRequest+0xf6>
    7ce6:	82 30       	cpi	r24, 0x02	; 2
    7ce8:	09 f0       	breq	.+2      	; 0x7cec <USB_Device_ProcessControlRequest+0xf6>
    7cea:	f0 c0       	rjmp	.+480    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    7cec:	90 e0       	ldi	r25, 0x00	; 0
    7cee:	8f 71       	andi	r24, 0x1F	; 31
    7cf0:	90 70       	andi	r25, 0x00	; 0
    7cf2:	00 97       	sbiw	r24, 0x00	; 0
    7cf4:	21 f0       	breq	.+8      	; 0x7cfe <USB_Device_ProcessControlRequest+0x108>
    7cf6:	02 97       	sbiw	r24, 0x02	; 2
    7cf8:	09 f0       	breq	.+2      	; 0x7cfc <USB_Device_ProcessControlRequest+0x106>
    7cfa:	e8 c0       	rjmp	.+464    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
    7cfc:	0c c0       	rjmp	.+24     	; 0x7d16 <USB_Device_ProcessControlRequest+0x120>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    7cfe:	80 91 28 09 	lds	r24, 0x0928
    7d02:	81 30       	cpi	r24, 0x01	; 1
    7d04:	09 f0       	breq	.+2      	; 0x7d08 <USB_Device_ProcessControlRequest+0x112>
    7d06:	e2 c0       	rjmp	.+452    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    7d08:	10 92 22 09 	sts	0x0922, r1
    7d0c:	33 30       	cpi	r19, 0x03	; 3
    7d0e:	69 f5       	brne	.+90     	; 0x7d6a <USB_Device_ProcessControlRequest+0x174>
    7d10:	80 93 22 09 	sts	0x0922, r24
    7d14:	2a c0       	rjmp	.+84     	; 0x7d6a <USB_Device_ProcessControlRequest+0x174>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    7d16:	80 91 28 09 	lds	r24, 0x0928
    7d1a:	88 23       	and	r24, r24
    7d1c:	31 f5       	brne	.+76     	; 0x7d6a <USB_Device_ProcessControlRequest+0x174>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    7d1e:	20 91 2a 09 	lds	r18, 0x092A
    7d22:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    7d24:	09 f4       	brne	.+2      	; 0x7d28 <USB_Device_ProcessControlRequest+0x132>
    7d26:	d2 c0       	rjmp	.+420    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7d28:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    7d2c:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    7d30:	80 ff       	sbrs	r24, 0
    7d32:	1b c0       	rjmp	.+54     	; 0x7d6a <USB_Device_ProcessControlRequest+0x174>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    7d34:	33 30       	cpi	r19, 0x03	; 3
    7d36:	21 f4       	brne	.+8      	; 0x7d40 <USB_Device_ProcessControlRequest+0x14a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    7d38:	80 91 eb 00 	lds	r24, 0x00EB
    7d3c:	80 62       	ori	r24, 0x20	; 32
    7d3e:	13 c0       	rjmp	.+38     	; 0x7d66 <USB_Device_ProcessControlRequest+0x170>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    7d40:	80 91 eb 00 	lds	r24, 0x00EB
    7d44:	80 61       	ori	r24, 0x10	; 16
    7d46:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    7d4a:	81 e0       	ldi	r24, 0x01	; 1
    7d4c:	90 e0       	ldi	r25, 0x00	; 0
    7d4e:	02 c0       	rjmp	.+4      	; 0x7d54 <USB_Device_ProcessControlRequest+0x15e>
    7d50:	88 0f       	add	r24, r24
    7d52:	99 1f       	adc	r25, r25
    7d54:	2a 95       	dec	r18
    7d56:	e2 f7       	brpl	.-8      	; 0x7d50 <USB_Device_ProcessControlRequest+0x15a>
    7d58:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    7d5c:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    7d60:	80 91 eb 00 	lds	r24, 0x00EB
    7d64:	88 60       	ori	r24, 0x08	; 8
    7d66:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7d6a:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7d6e:	80 91 e8 00 	lds	r24, 0x00E8
    7d72:	87 7f       	andi	r24, 0xF7	; 247
    7d74:	8a c0       	rjmp	.+276    	; 0x7e8a <USB_Device_ProcessControlRequest+0x294>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7d76:	88 23       	and	r24, r24
    7d78:	09 f0       	breq	.+2      	; 0x7d7c <USB_Device_ProcessControlRequest+0x186>
    7d7a:	a8 c0       	rjmp	.+336    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    7d7c:	10 91 28 09 	lds	r17, 0x0928
    7d80:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    7d82:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    7d84:	f8 94       	cli
    7d86:	80 91 e8 00 	lds	r24, 0x00E8
    7d8a:	87 7f       	andi	r24, 0xF7	; 247
    7d8c:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    7d90:	12 dc       	rcall	.-2012   	; 0x75b6 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    7d92:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    7d96:	80 ff       	sbrs	r24, 0
    7d98:	fc cf       	rjmp	.-8      	; 0x7d92 <USB_Device_ProcessControlRequest+0x19c>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    7d9a:	80 91 e3 00 	lds	r24, 0x00E3
    7d9e:	80 78       	andi	r24, 0x80	; 128
    7da0:	81 2b       	or	r24, r17

				UDADDR = Temp;
    7da2:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    7da6:	80 68       	ori	r24, 0x80	; 128
    7da8:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    7dac:	11 23       	and	r17, r17
    7dae:	11 f4       	brne	.+4      	; 0x7db4 <USB_Device_ProcessControlRequest+0x1be>
    7db0:	82 e0       	ldi	r24, 0x02	; 2
    7db2:	01 c0       	rjmp	.+2      	; 0x7db6 <USB_Device_ProcessControlRequest+0x1c0>
    7db4:	83 e0       	ldi	r24, 0x03	; 3
    7db6:	80 93 25 09 	sts	0x0925, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    7dba:	0f bf       	out	0x3f, r16	; 63
				  __builtin_ssrf(AVR32_SR_GM_OFFSET);
				else
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#endif
				
				GCC_MEMORY_BARRIER();
    7dbc:	87 c0       	rjmp	.+270    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7dbe:	80 58       	subi	r24, 0x80	; 128
    7dc0:	82 30       	cpi	r24, 0x02	; 2
    7dc2:	08 f0       	brcs	.+2      	; 0x7dc6 <USB_Device_ProcessControlRequest+0x1d0>
    7dc4:	83 c0       	rjmp	.+262    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    7dc6:	80 91 28 09 	lds	r24, 0x0928
    7dca:	90 91 29 09 	lds	r25, 0x0929
    7dce:	23 e0       	ldi	r18, 0x03	; 3
    7dd0:	8c 3d       	cpi	r24, 0xDC	; 220
    7dd2:	92 07       	cpc	r25, r18
    7dd4:	09 f0       	breq	.+2      	; 0x7dd8 <USB_Device_ProcessControlRequest+0x1e2>
    7dd6:	33 c0       	rjmp	.+102    	; 0x7e3e <USB_Device_ProcessControlRequest+0x248>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    7dd8:	83 e0       	ldi	r24, 0x03	; 3
    7dda:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    7ddc:	8a e2       	ldi	r24, 0x2A	; 42
    7dde:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    7de0:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    7de2:	f8 94       	cli
				#elif (ARCH == ARCH_UC3)
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#endif

				GCC_MEMORY_BARRIER();
    7de4:	de 01       	movw	r26, r28
    7de6:	15 96       	adiw	r26, 0x05	; 5
    7de8:	6e e0       	ldi	r22, 0x0E	; 14
    7dea:	40 e0       	ldi	r20, 0x00	; 0
    7dec:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    7dee:	11 e2       	ldi	r17, 0x21	; 33
    7df0:	e6 2f       	mov	r30, r22
    7df2:	f0 e0       	ldi	r31, 0x00	; 0
    7df4:	10 93 57 00 	sts	0x0057, r17
    7df8:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    7dfa:	40 ff       	sbrs	r20, 0
    7dfc:	03 c0       	rjmp	.+6      	; 0x7e04 <USB_Device_ProcessControlRequest+0x20e>
					{
						SerialByte >>= 4;
    7dfe:	82 95       	swap	r24
    7e00:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    7e02:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    7e04:	8f 70       	andi	r24, 0x0F	; 15
    7e06:	28 2f       	mov	r18, r24
    7e08:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    7e0a:	8a 30       	cpi	r24, 0x0A	; 10
    7e0c:	18 f0       	brcs	.+6      	; 0x7e14 <USB_Device_ProcessControlRequest+0x21e>
    7e0e:	c9 01       	movw	r24, r18
    7e10:	c7 96       	adiw	r24, 0x37	; 55
    7e12:	02 c0       	rjmp	.+4      	; 0x7e18 <USB_Device_ProcessControlRequest+0x222>
    7e14:	c9 01       	movw	r24, r18
    7e16:	c0 96       	adiw	r24, 0x30	; 48
    7e18:	8d 93       	st	X+, r24
    7e1a:	9d 93       	st	X+, r25
    7e1c:	4f 5f       	subi	r20, 0xFF	; 255
    7e1e:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    7e20:	44 31       	cpi	r20, 0x14	; 20
    7e22:	51 05       	cpc	r21, r1
    7e24:	29 f7       	brne	.-54     	; 0x7df0 <USB_Device_ProcessControlRequest+0x1fa>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    7e26:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7e28:	80 91 e8 00 	lds	r24, 0x00E8
    7e2c:	87 7f       	andi	r24, 0xF7	; 247
    7e2e:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    7e32:	ce 01       	movw	r24, r28
    7e34:	03 96       	adiw	r24, 0x03	; 3
    7e36:	6a e2       	ldi	r22, 0x2A	; 42
    7e38:	70 e0       	ldi	r23, 0x00	; 0
    7e3a:	39 dd       	rcall	.-1422   	; 0x78ae <Endpoint_Write_Control_Stream_LE>
    7e3c:	12 c0       	rjmp	.+36     	; 0x7e62 <USB_Device_ProcessControlRequest+0x26c>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    7e3e:	60 91 2a 09 	lds	r22, 0x092A
    7e42:	ae 01       	movw	r20, r28
    7e44:	4f 5f       	subi	r20, 0xFF	; 255
    7e46:	5f 4f       	sbci	r21, 0xFF	; 255
    7e48:	2f db       	rcall	.-2466   	; 0x74a8 <CALLBACK_USB_GetDescriptor>
    7e4a:	bc 01       	movw	r22, r24
    7e4c:	00 97       	sbiw	r24, 0x00	; 0
    7e4e:	09 f4       	brne	.+2      	; 0x7e52 <USB_Device_ProcessControlRequest+0x25c>
    7e50:	3d c0       	rjmp	.+122    	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
    7e52:	80 91 e8 00 	lds	r24, 0x00E8
    7e56:	87 7f       	andi	r24, 0xF7	; 247
    7e58:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    7e5c:	89 81       	ldd	r24, Y+1	; 0x01
    7e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    7e60:	c5 dd       	rcall	.-1142   	; 0x79ec <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7e62:	80 91 e8 00 	lds	r24, 0x00E8
    7e66:	8b 77       	andi	r24, 0x7B	; 123
    7e68:	80 93 e8 00 	sts	0x00E8, r24
    7e6c:	2f c0       	rjmp	.+94     	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    7e6e:	80 38       	cpi	r24, 0x80	; 128
    7e70:	69 f5       	brne	.+90     	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7e72:	80 91 e8 00 	lds	r24, 0x00E8
    7e76:	87 7f       	andi	r24, 0xF7	; 247
    7e78:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_ConfigurationNumber);
    7e7c:	80 91 23 09 	lds	r24, 0x0923
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7e80:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7e84:	80 91 e8 00 	lds	r24, 0x00E8
    7e88:	8e 77       	andi	r24, 0x7E	; 126
    7e8a:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    7e8e:	93 db       	rcall	.-2266   	; 0x75b6 <Endpoint_ClearStatusStage>
    7e90:	1d c0       	rjmp	.+58     	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7e92:	88 23       	and	r24, r24
    7e94:	d9 f4       	brne	.+54     	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    7e96:	90 91 28 09 	lds	r25, 0x0928
    7e9a:	92 30       	cpi	r25, 0x02	; 2
    7e9c:	b8 f4       	brcc	.+46     	; 0x7ecc <USB_Device_ProcessControlRequest+0x2d6>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7e9e:	80 91 e8 00 	lds	r24, 0x00E8
    7ea2:	87 7f       	andi	r24, 0xF7	; 247
    7ea4:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    7ea8:	90 93 23 09 	sts	0x0923, r25

	Endpoint_ClearStatusStage();
    7eac:	84 db       	rcall	.-2296   	; 0x75b6 <Endpoint_ClearStatusStage>

	if (USB_ConfigurationNumber)
    7eae:	80 91 23 09 	lds	r24, 0x0923
    7eb2:	88 23       	and	r24, r24
    7eb4:	31 f4       	brne	.+12     	; 0x7ec2 <USB_Device_ProcessControlRequest+0x2cc>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    7eb6:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    7eba:	87 fd       	sbrc	r24, 7
    7ebc:	02 c0       	rjmp	.+4      	; 0x7ec2 <USB_Device_ProcessControlRequest+0x2cc>
    7ebe:	81 e0       	ldi	r24, 0x01	; 1
    7ec0:	01 c0       	rjmp	.+2      	; 0x7ec4 <USB_Device_ProcessControlRequest+0x2ce>
    7ec2:	84 e0       	ldi	r24, 0x04	; 4
    7ec4:	80 93 25 09 	sts	0x0925, r24

	EVENT_USB_Device_ConfigurationChanged();
    7ec8:	0e 94 5d 03 	call	0x6ba	; 0x6ba <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7ecc:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    7ed0:	83 ff       	sbrs	r24, 3
    7ed2:	0a c0       	rjmp	.+20     	; 0x7ee8 <USB_Device_ProcessControlRequest+0x2f2>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    7ed4:	80 91 eb 00 	lds	r24, 0x00EB
    7ed8:	80 62       	ori	r24, 0x20	; 32
    7eda:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7ede:	80 91 e8 00 	lds	r24, 0x00E8
    7ee2:	87 7f       	andi	r24, 0xF7	; 247
    7ee4:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    7ee8:	ac 96       	adiw	r28, 0x2c	; 44
    7eea:	0f b6       	in	r0, 0x3f	; 63
    7eec:	f8 94       	cli
    7eee:	de bf       	out	0x3e, r29	; 62
    7ef0:	0f be       	out	0x3f, r0	; 63
    7ef2:	cd bf       	out	0x3d, r28	; 61
    7ef4:	cf 91       	pop	r28
    7ef6:	df 91       	pop	r29
    7ef8:	1f 91       	pop	r17
    7efa:	0f 91       	pop	r16
    7efc:	08 95       	ret

00007efe <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    7efe:	08 95       	ret

00007f00 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    7f00:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    7f02:	80 91 25 09 	lds	r24, 0x0925
    7f06:	88 23       	and	r24, r24
    7f08:	61 f0       	breq	.+24     	; 0x7f22 <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    7f0a:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7f0e:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7f12:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    7f16:	83 ff       	sbrs	r24, 3
    7f18:	01 c0       	rjmp	.+2      	; 0x7f1c <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    7f1a:	6d de       	rcall	.-806    	; 0x7bf6 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    7f1c:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    7f1e:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    7f22:	1f 91       	pop	r17
    7f24:	08 95       	ret

00007f26 <__subsf3>:
    7f26:	50 58       	subi	r21, 0x80	; 128

00007f28 <__addsf3>:
    7f28:	bb 27       	eor	r27, r27
    7f2a:	aa 27       	eor	r26, r26
    7f2c:	0e d0       	rcall	.+28     	; 0x7f4a <__addsf3x>
    7f2e:	9a c1       	rjmp	.+820    	; 0x8264 <__fp_round>
    7f30:	8b d1       	rcall	.+790    	; 0x8248 <__fp_pscA>
    7f32:	30 f0       	brcs	.+12     	; 0x7f40 <__addsf3+0x18>
    7f34:	90 d1       	rcall	.+800    	; 0x8256 <__fp_pscB>
    7f36:	20 f0       	brcs	.+8      	; 0x7f40 <__addsf3+0x18>
    7f38:	31 f4       	brne	.+12     	; 0x7f46 <__addsf3+0x1e>
    7f3a:	9f 3f       	cpi	r25, 0xFF	; 255
    7f3c:	11 f4       	brne	.+4      	; 0x7f42 <__addsf3+0x1a>
    7f3e:	1e f4       	brtc	.+6      	; 0x7f46 <__addsf3+0x1e>
    7f40:	5b c1       	rjmp	.+694    	; 0x81f8 <__fp_nan>
    7f42:	0e f4       	brtc	.+2      	; 0x7f46 <__addsf3+0x1e>
    7f44:	e0 95       	com	r30
    7f46:	e7 fb       	bst	r30, 7
    7f48:	51 c1       	rjmp	.+674    	; 0x81ec <__fp_inf>

00007f4a <__addsf3x>:
    7f4a:	e9 2f       	mov	r30, r25
    7f4c:	9c d1       	rcall	.+824    	; 0x8286 <__fp_split3>
    7f4e:	80 f3       	brcs	.-32     	; 0x7f30 <__addsf3+0x8>
    7f50:	ba 17       	cp	r27, r26
    7f52:	62 07       	cpc	r22, r18
    7f54:	73 07       	cpc	r23, r19
    7f56:	84 07       	cpc	r24, r20
    7f58:	95 07       	cpc	r25, r21
    7f5a:	18 f0       	brcs	.+6      	; 0x7f62 <__addsf3x+0x18>
    7f5c:	71 f4       	brne	.+28     	; 0x7f7a <__addsf3x+0x30>
    7f5e:	9e f5       	brtc	.+102    	; 0x7fc6 <__addsf3x+0x7c>
    7f60:	b4 c1       	rjmp	.+872    	; 0x82ca <__fp_zero>
    7f62:	0e f4       	brtc	.+2      	; 0x7f66 <__addsf3x+0x1c>
    7f64:	e0 95       	com	r30
    7f66:	0b 2e       	mov	r0, r27
    7f68:	ba 2f       	mov	r27, r26
    7f6a:	a0 2d       	mov	r26, r0
    7f6c:	0b 01       	movw	r0, r22
    7f6e:	b9 01       	movw	r22, r18
    7f70:	90 01       	movw	r18, r0
    7f72:	0c 01       	movw	r0, r24
    7f74:	ca 01       	movw	r24, r20
    7f76:	a0 01       	movw	r20, r0
    7f78:	11 24       	eor	r1, r1
    7f7a:	ff 27       	eor	r31, r31
    7f7c:	59 1b       	sub	r21, r25
    7f7e:	99 f0       	breq	.+38     	; 0x7fa6 <__addsf3x+0x5c>
    7f80:	59 3f       	cpi	r21, 0xF9	; 249
    7f82:	50 f4       	brcc	.+20     	; 0x7f98 <__addsf3x+0x4e>
    7f84:	50 3e       	cpi	r21, 0xE0	; 224
    7f86:	68 f1       	brcs	.+90     	; 0x7fe2 <__addsf3x+0x98>
    7f88:	1a 16       	cp	r1, r26
    7f8a:	f0 40       	sbci	r31, 0x00	; 0
    7f8c:	a2 2f       	mov	r26, r18
    7f8e:	23 2f       	mov	r18, r19
    7f90:	34 2f       	mov	r19, r20
    7f92:	44 27       	eor	r20, r20
    7f94:	58 5f       	subi	r21, 0xF8	; 248
    7f96:	f3 cf       	rjmp	.-26     	; 0x7f7e <__addsf3x+0x34>
    7f98:	46 95       	lsr	r20
    7f9a:	37 95       	ror	r19
    7f9c:	27 95       	ror	r18
    7f9e:	a7 95       	ror	r26
    7fa0:	f0 40       	sbci	r31, 0x00	; 0
    7fa2:	53 95       	inc	r21
    7fa4:	c9 f7       	brne	.-14     	; 0x7f98 <__addsf3x+0x4e>
    7fa6:	7e f4       	brtc	.+30     	; 0x7fc6 <__addsf3x+0x7c>
    7fa8:	1f 16       	cp	r1, r31
    7faa:	ba 0b       	sbc	r27, r26
    7fac:	62 0b       	sbc	r22, r18
    7fae:	73 0b       	sbc	r23, r19
    7fb0:	84 0b       	sbc	r24, r20
    7fb2:	ba f0       	brmi	.+46     	; 0x7fe2 <__addsf3x+0x98>
    7fb4:	91 50       	subi	r25, 0x01	; 1
    7fb6:	a1 f0       	breq	.+40     	; 0x7fe0 <__addsf3x+0x96>
    7fb8:	ff 0f       	add	r31, r31
    7fba:	bb 1f       	adc	r27, r27
    7fbc:	66 1f       	adc	r22, r22
    7fbe:	77 1f       	adc	r23, r23
    7fc0:	88 1f       	adc	r24, r24
    7fc2:	c2 f7       	brpl	.-16     	; 0x7fb4 <__addsf3x+0x6a>
    7fc4:	0e c0       	rjmp	.+28     	; 0x7fe2 <__addsf3x+0x98>
    7fc6:	ba 0f       	add	r27, r26
    7fc8:	62 1f       	adc	r22, r18
    7fca:	73 1f       	adc	r23, r19
    7fcc:	84 1f       	adc	r24, r20
    7fce:	48 f4       	brcc	.+18     	; 0x7fe2 <__addsf3x+0x98>
    7fd0:	87 95       	ror	r24
    7fd2:	77 95       	ror	r23
    7fd4:	67 95       	ror	r22
    7fd6:	b7 95       	ror	r27
    7fd8:	f7 95       	ror	r31
    7fda:	9e 3f       	cpi	r25, 0xFE	; 254
    7fdc:	08 f0       	brcs	.+2      	; 0x7fe0 <__addsf3x+0x96>
    7fde:	b3 cf       	rjmp	.-154    	; 0x7f46 <__addsf3+0x1e>
    7fe0:	93 95       	inc	r25
    7fe2:	88 0f       	add	r24, r24
    7fe4:	08 f0       	brcs	.+2      	; 0x7fe8 <__addsf3x+0x9e>
    7fe6:	99 27       	eor	r25, r25
    7fe8:	ee 0f       	add	r30, r30
    7fea:	97 95       	ror	r25
    7fec:	87 95       	ror	r24
    7fee:	08 95       	ret

00007ff0 <atan>:
    7ff0:	df 93       	push	r29
    7ff2:	dd 27       	eor	r29, r29
    7ff4:	b9 2f       	mov	r27, r25
    7ff6:	bf 77       	andi	r27, 0x7F	; 127
    7ff8:	40 e8       	ldi	r20, 0x80	; 128
    7ffa:	5f e3       	ldi	r21, 0x3F	; 63
    7ffc:	16 16       	cp	r1, r22
    7ffe:	17 06       	cpc	r1, r23
    8000:	48 07       	cpc	r20, r24
    8002:	5b 07       	cpc	r21, r27
    8004:	10 f4       	brcc	.+4      	; 0x800a <atan+0x1a>
    8006:	d9 2f       	mov	r29, r25
    8008:	67 d1       	rcall	.+718    	; 0x82d8 <inverse>
    800a:	9f 93       	push	r25
    800c:	8f 93       	push	r24
    800e:	7f 93       	push	r23
    8010:	6f 93       	push	r22
    8012:	5a d2       	rcall	.+1204   	; 0x84c8 <square>
    8014:	e8 e9       	ldi	r30, 0x98	; 152
    8016:	f0 e0       	ldi	r31, 0x00	; 0
    8018:	f2 d0       	rcall	.+484    	; 0x81fe <__fp_powser>
    801a:	24 d1       	rcall	.+584    	; 0x8264 <__fp_round>
    801c:	2f 91       	pop	r18
    801e:	3f 91       	pop	r19
    8020:	4f 91       	pop	r20
    8022:	5f 91       	pop	r21
    8024:	6c d1       	rcall	.+728    	; 0x82fe <__mulsf3x>
    8026:	dd 23       	and	r29, r29
    8028:	49 f0       	breq	.+18     	; 0x803c <atan+0x4c>
    802a:	90 58       	subi	r25, 0x80	; 128
    802c:	a2 ea       	ldi	r26, 0xA2	; 162
    802e:	2a ed       	ldi	r18, 0xDA	; 218
    8030:	3f e0       	ldi	r19, 0x0F	; 15
    8032:	49 ec       	ldi	r20, 0xC9	; 201
    8034:	5f e3       	ldi	r21, 0x3F	; 63
    8036:	d0 78       	andi	r29, 0x80	; 128
    8038:	5d 27       	eor	r21, r29
    803a:	87 df       	rcall	.-242    	; 0x7f4a <__addsf3x>
    803c:	df 91       	pop	r29
    803e:	12 c1       	rjmp	.+548    	; 0x8264 <__fp_round>

00008040 <__divsf3>:
    8040:	0c d0       	rcall	.+24     	; 0x805a <__divsf3x>
    8042:	10 c1       	rjmp	.+544    	; 0x8264 <__fp_round>
    8044:	08 d1       	rcall	.+528    	; 0x8256 <__fp_pscB>
    8046:	40 f0       	brcs	.+16     	; 0x8058 <__divsf3+0x18>
    8048:	ff d0       	rcall	.+510    	; 0x8248 <__fp_pscA>
    804a:	30 f0       	brcs	.+12     	; 0x8058 <__divsf3+0x18>
    804c:	21 f4       	brne	.+8      	; 0x8056 <__divsf3+0x16>
    804e:	5f 3f       	cpi	r21, 0xFF	; 255
    8050:	19 f0       	breq	.+6      	; 0x8058 <__divsf3+0x18>
    8052:	cc c0       	rjmp	.+408    	; 0x81ec <__fp_inf>
    8054:	51 11       	cpse	r21, r1
    8056:	3a c1       	rjmp	.+628    	; 0x82cc <__fp_szero>
    8058:	cf c0       	rjmp	.+414    	; 0x81f8 <__fp_nan>

0000805a <__divsf3x>:
    805a:	15 d1       	rcall	.+554    	; 0x8286 <__fp_split3>
    805c:	98 f3       	brcs	.-26     	; 0x8044 <__divsf3+0x4>

0000805e <__divsf3_pse>:
    805e:	99 23       	and	r25, r25
    8060:	c9 f3       	breq	.-14     	; 0x8054 <__divsf3+0x14>
    8062:	55 23       	and	r21, r21
    8064:	b1 f3       	breq	.-20     	; 0x8052 <__divsf3+0x12>
    8066:	95 1b       	sub	r25, r21
    8068:	55 0b       	sbc	r21, r21
    806a:	bb 27       	eor	r27, r27
    806c:	aa 27       	eor	r26, r26
    806e:	62 17       	cp	r22, r18
    8070:	73 07       	cpc	r23, r19
    8072:	84 07       	cpc	r24, r20
    8074:	38 f0       	brcs	.+14     	; 0x8084 <__divsf3_pse+0x26>
    8076:	9f 5f       	subi	r25, 0xFF	; 255
    8078:	5f 4f       	sbci	r21, 0xFF	; 255
    807a:	22 0f       	add	r18, r18
    807c:	33 1f       	adc	r19, r19
    807e:	44 1f       	adc	r20, r20
    8080:	aa 1f       	adc	r26, r26
    8082:	a9 f3       	breq	.-22     	; 0x806e <__divsf3_pse+0x10>
    8084:	33 d0       	rcall	.+102    	; 0x80ec <__divsf3_pse+0x8e>
    8086:	0e 2e       	mov	r0, r30
    8088:	3a f0       	brmi	.+14     	; 0x8098 <__divsf3_pse+0x3a>
    808a:	e0 e8       	ldi	r30, 0x80	; 128
    808c:	30 d0       	rcall	.+96     	; 0x80ee <__divsf3_pse+0x90>
    808e:	91 50       	subi	r25, 0x01	; 1
    8090:	50 40       	sbci	r21, 0x00	; 0
    8092:	e6 95       	lsr	r30
    8094:	00 1c       	adc	r0, r0
    8096:	ca f7       	brpl	.-14     	; 0x808a <__divsf3_pse+0x2c>
    8098:	29 d0       	rcall	.+82     	; 0x80ec <__divsf3_pse+0x8e>
    809a:	fe 2f       	mov	r31, r30
    809c:	27 d0       	rcall	.+78     	; 0x80ec <__divsf3_pse+0x8e>
    809e:	66 0f       	add	r22, r22
    80a0:	77 1f       	adc	r23, r23
    80a2:	88 1f       	adc	r24, r24
    80a4:	bb 1f       	adc	r27, r27
    80a6:	26 17       	cp	r18, r22
    80a8:	37 07       	cpc	r19, r23
    80aa:	48 07       	cpc	r20, r24
    80ac:	ab 07       	cpc	r26, r27
    80ae:	b0 e8       	ldi	r27, 0x80	; 128
    80b0:	09 f0       	breq	.+2      	; 0x80b4 <__divsf3_pse+0x56>
    80b2:	bb 0b       	sbc	r27, r27
    80b4:	80 2d       	mov	r24, r0
    80b6:	bf 01       	movw	r22, r30
    80b8:	ff 27       	eor	r31, r31
    80ba:	93 58       	subi	r25, 0x83	; 131
    80bc:	5f 4f       	sbci	r21, 0xFF	; 255
    80be:	2a f0       	brmi	.+10     	; 0x80ca <__divsf3_pse+0x6c>
    80c0:	9e 3f       	cpi	r25, 0xFE	; 254
    80c2:	51 05       	cpc	r21, r1
    80c4:	68 f0       	brcs	.+26     	; 0x80e0 <__divsf3_pse+0x82>
    80c6:	92 c0       	rjmp	.+292    	; 0x81ec <__fp_inf>
    80c8:	01 c1       	rjmp	.+514    	; 0x82cc <__fp_szero>
    80ca:	5f 3f       	cpi	r21, 0xFF	; 255
    80cc:	ec f3       	brlt	.-6      	; 0x80c8 <__divsf3_pse+0x6a>
    80ce:	98 3e       	cpi	r25, 0xE8	; 232
    80d0:	dc f3       	brlt	.-10     	; 0x80c8 <__divsf3_pse+0x6a>
    80d2:	86 95       	lsr	r24
    80d4:	77 95       	ror	r23
    80d6:	67 95       	ror	r22
    80d8:	b7 95       	ror	r27
    80da:	f7 95       	ror	r31
    80dc:	9f 5f       	subi	r25, 0xFF	; 255
    80de:	c9 f7       	brne	.-14     	; 0x80d2 <__divsf3_pse+0x74>
    80e0:	88 0f       	add	r24, r24
    80e2:	91 1d       	adc	r25, r1
    80e4:	96 95       	lsr	r25
    80e6:	87 95       	ror	r24
    80e8:	97 f9       	bld	r25, 7
    80ea:	08 95       	ret
    80ec:	e1 e0       	ldi	r30, 0x01	; 1
    80ee:	66 0f       	add	r22, r22
    80f0:	77 1f       	adc	r23, r23
    80f2:	88 1f       	adc	r24, r24
    80f4:	bb 1f       	adc	r27, r27
    80f6:	62 17       	cp	r22, r18
    80f8:	73 07       	cpc	r23, r19
    80fa:	84 07       	cpc	r24, r20
    80fc:	ba 07       	cpc	r27, r26
    80fe:	20 f0       	brcs	.+8      	; 0x8108 <__divsf3_pse+0xaa>
    8100:	62 1b       	sub	r22, r18
    8102:	73 0b       	sbc	r23, r19
    8104:	84 0b       	sbc	r24, r20
    8106:	ba 0b       	sbc	r27, r26
    8108:	ee 1f       	adc	r30, r30
    810a:	88 f7       	brcc	.-30     	; 0x80ee <__divsf3_pse+0x90>
    810c:	e0 95       	com	r30
    810e:	08 95       	ret

00008110 <__fixsfsi>:
    8110:	04 d0       	rcall	.+8      	; 0x811a <__fixunssfsi>
    8112:	68 94       	set
    8114:	b1 11       	cpse	r27, r1
    8116:	da c0       	rjmp	.+436    	; 0x82cc <__fp_szero>
    8118:	08 95       	ret

0000811a <__fixunssfsi>:
    811a:	bd d0       	rcall	.+378    	; 0x8296 <__fp_splitA>
    811c:	88 f0       	brcs	.+34     	; 0x8140 <__fixunssfsi+0x26>
    811e:	9f 57       	subi	r25, 0x7F	; 127
    8120:	90 f0       	brcs	.+36     	; 0x8146 <__fixunssfsi+0x2c>
    8122:	b9 2f       	mov	r27, r25
    8124:	99 27       	eor	r25, r25
    8126:	b7 51       	subi	r27, 0x17	; 23
    8128:	a0 f0       	brcs	.+40     	; 0x8152 <__fixunssfsi+0x38>
    812a:	d1 f0       	breq	.+52     	; 0x8160 <__fixunssfsi+0x46>
    812c:	66 0f       	add	r22, r22
    812e:	77 1f       	adc	r23, r23
    8130:	88 1f       	adc	r24, r24
    8132:	99 1f       	adc	r25, r25
    8134:	1a f0       	brmi	.+6      	; 0x813c <__fixunssfsi+0x22>
    8136:	ba 95       	dec	r27
    8138:	c9 f7       	brne	.-14     	; 0x812c <__fixunssfsi+0x12>
    813a:	12 c0       	rjmp	.+36     	; 0x8160 <__fixunssfsi+0x46>
    813c:	b1 30       	cpi	r27, 0x01	; 1
    813e:	81 f0       	breq	.+32     	; 0x8160 <__fixunssfsi+0x46>
    8140:	c4 d0       	rcall	.+392    	; 0x82ca <__fp_zero>
    8142:	b1 e0       	ldi	r27, 0x01	; 1
    8144:	08 95       	ret
    8146:	c1 c0       	rjmp	.+386    	; 0x82ca <__fp_zero>
    8148:	67 2f       	mov	r22, r23
    814a:	78 2f       	mov	r23, r24
    814c:	88 27       	eor	r24, r24
    814e:	b8 5f       	subi	r27, 0xF8	; 248
    8150:	39 f0       	breq	.+14     	; 0x8160 <__fixunssfsi+0x46>
    8152:	b9 3f       	cpi	r27, 0xF9	; 249
    8154:	cc f3       	brlt	.-14     	; 0x8148 <__fixunssfsi+0x2e>
    8156:	86 95       	lsr	r24
    8158:	77 95       	ror	r23
    815a:	67 95       	ror	r22
    815c:	b3 95       	inc	r27
    815e:	d9 f7       	brne	.-10     	; 0x8156 <__fixunssfsi+0x3c>
    8160:	3e f4       	brtc	.+14     	; 0x8170 <__fixunssfsi+0x56>
    8162:	90 95       	com	r25
    8164:	80 95       	com	r24
    8166:	70 95       	com	r23
    8168:	61 95       	neg	r22
    816a:	7f 4f       	sbci	r23, 0xFF	; 255
    816c:	8f 4f       	sbci	r24, 0xFF	; 255
    816e:	9f 4f       	sbci	r25, 0xFF	; 255
    8170:	08 95       	ret

00008172 <__floatunsisf>:
    8172:	e8 94       	clt
    8174:	09 c0       	rjmp	.+18     	; 0x8188 <__floatsisf+0x12>

00008176 <__floatsisf>:
    8176:	97 fb       	bst	r25, 7
    8178:	3e f4       	brtc	.+14     	; 0x8188 <__floatsisf+0x12>
    817a:	90 95       	com	r25
    817c:	80 95       	com	r24
    817e:	70 95       	com	r23
    8180:	61 95       	neg	r22
    8182:	7f 4f       	sbci	r23, 0xFF	; 255
    8184:	8f 4f       	sbci	r24, 0xFF	; 255
    8186:	9f 4f       	sbci	r25, 0xFF	; 255
    8188:	99 23       	and	r25, r25
    818a:	a9 f0       	breq	.+42     	; 0x81b6 <__floatsisf+0x40>
    818c:	f9 2f       	mov	r31, r25
    818e:	96 e9       	ldi	r25, 0x96	; 150
    8190:	bb 27       	eor	r27, r27
    8192:	93 95       	inc	r25
    8194:	f6 95       	lsr	r31
    8196:	87 95       	ror	r24
    8198:	77 95       	ror	r23
    819a:	67 95       	ror	r22
    819c:	b7 95       	ror	r27
    819e:	f1 11       	cpse	r31, r1
    81a0:	f8 cf       	rjmp	.-16     	; 0x8192 <__floatsisf+0x1c>
    81a2:	fa f4       	brpl	.+62     	; 0x81e2 <__floatsisf+0x6c>
    81a4:	bb 0f       	add	r27, r27
    81a6:	11 f4       	brne	.+4      	; 0x81ac <__floatsisf+0x36>
    81a8:	60 ff       	sbrs	r22, 0
    81aa:	1b c0       	rjmp	.+54     	; 0x81e2 <__floatsisf+0x6c>
    81ac:	6f 5f       	subi	r22, 0xFF	; 255
    81ae:	7f 4f       	sbci	r23, 0xFF	; 255
    81b0:	8f 4f       	sbci	r24, 0xFF	; 255
    81b2:	9f 4f       	sbci	r25, 0xFF	; 255
    81b4:	16 c0       	rjmp	.+44     	; 0x81e2 <__floatsisf+0x6c>
    81b6:	88 23       	and	r24, r24
    81b8:	11 f0       	breq	.+4      	; 0x81be <__floatsisf+0x48>
    81ba:	96 e9       	ldi	r25, 0x96	; 150
    81bc:	11 c0       	rjmp	.+34     	; 0x81e0 <__floatsisf+0x6a>
    81be:	77 23       	and	r23, r23
    81c0:	21 f0       	breq	.+8      	; 0x81ca <__floatsisf+0x54>
    81c2:	9e e8       	ldi	r25, 0x8E	; 142
    81c4:	87 2f       	mov	r24, r23
    81c6:	76 2f       	mov	r23, r22
    81c8:	05 c0       	rjmp	.+10     	; 0x81d4 <__floatsisf+0x5e>
    81ca:	66 23       	and	r22, r22
    81cc:	71 f0       	breq	.+28     	; 0x81ea <__floatsisf+0x74>
    81ce:	96 e8       	ldi	r25, 0x86	; 134
    81d0:	86 2f       	mov	r24, r22
    81d2:	70 e0       	ldi	r23, 0x00	; 0
    81d4:	60 e0       	ldi	r22, 0x00	; 0
    81d6:	2a f0       	brmi	.+10     	; 0x81e2 <__floatsisf+0x6c>
    81d8:	9a 95       	dec	r25
    81da:	66 0f       	add	r22, r22
    81dc:	77 1f       	adc	r23, r23
    81de:	88 1f       	adc	r24, r24
    81e0:	da f7       	brpl	.-10     	; 0x81d8 <__floatsisf+0x62>
    81e2:	88 0f       	add	r24, r24
    81e4:	96 95       	lsr	r25
    81e6:	87 95       	ror	r24
    81e8:	97 f9       	bld	r25, 7
    81ea:	08 95       	ret

000081ec <__fp_inf>:
    81ec:	97 f9       	bld	r25, 7
    81ee:	9f 67       	ori	r25, 0x7F	; 127
    81f0:	80 e8       	ldi	r24, 0x80	; 128
    81f2:	70 e0       	ldi	r23, 0x00	; 0
    81f4:	60 e0       	ldi	r22, 0x00	; 0
    81f6:	08 95       	ret

000081f8 <__fp_nan>:
    81f8:	9f ef       	ldi	r25, 0xFF	; 255
    81fa:	80 ec       	ldi	r24, 0xC0	; 192
    81fc:	08 95       	ret

000081fe <__fp_powser>:
    81fe:	df 93       	push	r29
    8200:	cf 93       	push	r28
    8202:	1f 93       	push	r17
    8204:	0f 93       	push	r16
    8206:	ff 92       	push	r15
    8208:	ef 92       	push	r14
    820a:	df 92       	push	r13
    820c:	7b 01       	movw	r14, r22
    820e:	8c 01       	movw	r16, r24
    8210:	68 94       	set
    8212:	05 c0       	rjmp	.+10     	; 0x821e <__fp_powser+0x20>
    8214:	da 2e       	mov	r13, r26
    8216:	ef 01       	movw	r28, r30
    8218:	72 d0       	rcall	.+228    	; 0x82fe <__mulsf3x>
    821a:	fe 01       	movw	r30, r28
    821c:	e8 94       	clt
    821e:	a5 91       	lpm	r26, Z+
    8220:	25 91       	lpm	r18, Z+
    8222:	35 91       	lpm	r19, Z+
    8224:	45 91       	lpm	r20, Z+
    8226:	55 91       	lpm	r21, Z+
    8228:	ae f3       	brts	.-22     	; 0x8214 <__fp_powser+0x16>
    822a:	ef 01       	movw	r28, r30
    822c:	8e de       	rcall	.-740    	; 0x7f4a <__addsf3x>
    822e:	fe 01       	movw	r30, r28
    8230:	97 01       	movw	r18, r14
    8232:	a8 01       	movw	r20, r16
    8234:	da 94       	dec	r13
    8236:	79 f7       	brne	.-34     	; 0x8216 <__fp_powser+0x18>
    8238:	df 90       	pop	r13
    823a:	ef 90       	pop	r14
    823c:	ff 90       	pop	r15
    823e:	0f 91       	pop	r16
    8240:	1f 91       	pop	r17
    8242:	cf 91       	pop	r28
    8244:	df 91       	pop	r29
    8246:	08 95       	ret

00008248 <__fp_pscA>:
    8248:	00 24       	eor	r0, r0
    824a:	0a 94       	dec	r0
    824c:	16 16       	cp	r1, r22
    824e:	17 06       	cpc	r1, r23
    8250:	18 06       	cpc	r1, r24
    8252:	09 06       	cpc	r0, r25
    8254:	08 95       	ret

00008256 <__fp_pscB>:
    8256:	00 24       	eor	r0, r0
    8258:	0a 94       	dec	r0
    825a:	12 16       	cp	r1, r18
    825c:	13 06       	cpc	r1, r19
    825e:	14 06       	cpc	r1, r20
    8260:	05 06       	cpc	r0, r21
    8262:	08 95       	ret

00008264 <__fp_round>:
    8264:	09 2e       	mov	r0, r25
    8266:	03 94       	inc	r0
    8268:	00 0c       	add	r0, r0
    826a:	11 f4       	brne	.+4      	; 0x8270 <__fp_round+0xc>
    826c:	88 23       	and	r24, r24
    826e:	52 f0       	brmi	.+20     	; 0x8284 <__fp_round+0x20>
    8270:	bb 0f       	add	r27, r27
    8272:	40 f4       	brcc	.+16     	; 0x8284 <__fp_round+0x20>
    8274:	bf 2b       	or	r27, r31
    8276:	11 f4       	brne	.+4      	; 0x827c <__fp_round+0x18>
    8278:	60 ff       	sbrs	r22, 0
    827a:	04 c0       	rjmp	.+8      	; 0x8284 <__fp_round+0x20>
    827c:	6f 5f       	subi	r22, 0xFF	; 255
    827e:	7f 4f       	sbci	r23, 0xFF	; 255
    8280:	8f 4f       	sbci	r24, 0xFF	; 255
    8282:	9f 4f       	sbci	r25, 0xFF	; 255
    8284:	08 95       	ret

00008286 <__fp_split3>:
    8286:	57 fd       	sbrc	r21, 7
    8288:	90 58       	subi	r25, 0x80	; 128
    828a:	44 0f       	add	r20, r20
    828c:	55 1f       	adc	r21, r21
    828e:	59 f0       	breq	.+22     	; 0x82a6 <__fp_splitA+0x10>
    8290:	5f 3f       	cpi	r21, 0xFF	; 255
    8292:	71 f0       	breq	.+28     	; 0x82b0 <__fp_splitA+0x1a>
    8294:	47 95       	ror	r20

00008296 <__fp_splitA>:
    8296:	88 0f       	add	r24, r24
    8298:	97 fb       	bst	r25, 7
    829a:	99 1f       	adc	r25, r25
    829c:	61 f0       	breq	.+24     	; 0x82b6 <__fp_splitA+0x20>
    829e:	9f 3f       	cpi	r25, 0xFF	; 255
    82a0:	79 f0       	breq	.+30     	; 0x82c0 <__fp_splitA+0x2a>
    82a2:	87 95       	ror	r24
    82a4:	08 95       	ret
    82a6:	12 16       	cp	r1, r18
    82a8:	13 06       	cpc	r1, r19
    82aa:	14 06       	cpc	r1, r20
    82ac:	55 1f       	adc	r21, r21
    82ae:	f2 cf       	rjmp	.-28     	; 0x8294 <__fp_split3+0xe>
    82b0:	46 95       	lsr	r20
    82b2:	f1 df       	rcall	.-30     	; 0x8296 <__fp_splitA>
    82b4:	08 c0       	rjmp	.+16     	; 0x82c6 <__fp_splitA+0x30>
    82b6:	16 16       	cp	r1, r22
    82b8:	17 06       	cpc	r1, r23
    82ba:	18 06       	cpc	r1, r24
    82bc:	99 1f       	adc	r25, r25
    82be:	f1 cf       	rjmp	.-30     	; 0x82a2 <__fp_splitA+0xc>
    82c0:	86 95       	lsr	r24
    82c2:	71 05       	cpc	r23, r1
    82c4:	61 05       	cpc	r22, r1
    82c6:	08 94       	sec
    82c8:	08 95       	ret

000082ca <__fp_zero>:
    82ca:	e8 94       	clt

000082cc <__fp_szero>:
    82cc:	bb 27       	eor	r27, r27
    82ce:	66 27       	eor	r22, r22
    82d0:	77 27       	eor	r23, r23
    82d2:	cb 01       	movw	r24, r22
    82d4:	97 f9       	bld	r25, 7
    82d6:	08 95       	ret

000082d8 <inverse>:
    82d8:	9b 01       	movw	r18, r22
    82da:	ac 01       	movw	r20, r24
    82dc:	60 e0       	ldi	r22, 0x00	; 0
    82de:	70 e0       	ldi	r23, 0x00	; 0
    82e0:	80 e8       	ldi	r24, 0x80	; 128
    82e2:	9f e3       	ldi	r25, 0x3F	; 63
    82e4:	ad ce       	rjmp	.-678    	; 0x8040 <__divsf3>

000082e6 <__mulsf3>:
    82e6:	0b d0       	rcall	.+22     	; 0x82fe <__mulsf3x>
    82e8:	bd cf       	rjmp	.-134    	; 0x8264 <__fp_round>
    82ea:	ae df       	rcall	.-164    	; 0x8248 <__fp_pscA>
    82ec:	28 f0       	brcs	.+10     	; 0x82f8 <__mulsf3+0x12>
    82ee:	b3 df       	rcall	.-154    	; 0x8256 <__fp_pscB>
    82f0:	18 f0       	brcs	.+6      	; 0x82f8 <__mulsf3+0x12>
    82f2:	95 23       	and	r25, r21
    82f4:	09 f0       	breq	.+2      	; 0x82f8 <__mulsf3+0x12>
    82f6:	7a cf       	rjmp	.-268    	; 0x81ec <__fp_inf>
    82f8:	7f cf       	rjmp	.-258    	; 0x81f8 <__fp_nan>
    82fa:	11 24       	eor	r1, r1
    82fc:	e7 cf       	rjmp	.-50     	; 0x82cc <__fp_szero>

000082fe <__mulsf3x>:
    82fe:	c3 df       	rcall	.-122    	; 0x8286 <__fp_split3>
    8300:	a0 f3       	brcs	.-24     	; 0x82ea <__mulsf3+0x4>

00008302 <__mulsf3_pse>:
    8302:	95 9f       	mul	r25, r21
    8304:	d1 f3       	breq	.-12     	; 0x82fa <__mulsf3+0x14>
    8306:	95 0f       	add	r25, r21
    8308:	50 e0       	ldi	r21, 0x00	; 0
    830a:	55 1f       	adc	r21, r21
    830c:	62 9f       	mul	r22, r18
    830e:	f0 01       	movw	r30, r0
    8310:	72 9f       	mul	r23, r18
    8312:	bb 27       	eor	r27, r27
    8314:	f0 0d       	add	r31, r0
    8316:	b1 1d       	adc	r27, r1
    8318:	63 9f       	mul	r22, r19
    831a:	aa 27       	eor	r26, r26
    831c:	f0 0d       	add	r31, r0
    831e:	b1 1d       	adc	r27, r1
    8320:	aa 1f       	adc	r26, r26
    8322:	64 9f       	mul	r22, r20
    8324:	66 27       	eor	r22, r22
    8326:	b0 0d       	add	r27, r0
    8328:	a1 1d       	adc	r26, r1
    832a:	66 1f       	adc	r22, r22
    832c:	82 9f       	mul	r24, r18
    832e:	22 27       	eor	r18, r18
    8330:	b0 0d       	add	r27, r0
    8332:	a1 1d       	adc	r26, r1
    8334:	62 1f       	adc	r22, r18
    8336:	73 9f       	mul	r23, r19
    8338:	b0 0d       	add	r27, r0
    833a:	a1 1d       	adc	r26, r1
    833c:	62 1f       	adc	r22, r18
    833e:	83 9f       	mul	r24, r19
    8340:	a0 0d       	add	r26, r0
    8342:	61 1d       	adc	r22, r1
    8344:	22 1f       	adc	r18, r18
    8346:	74 9f       	mul	r23, r20
    8348:	33 27       	eor	r19, r19
    834a:	a0 0d       	add	r26, r0
    834c:	61 1d       	adc	r22, r1
    834e:	23 1f       	adc	r18, r19
    8350:	84 9f       	mul	r24, r20
    8352:	60 0d       	add	r22, r0
    8354:	21 1d       	adc	r18, r1
    8356:	82 2f       	mov	r24, r18
    8358:	76 2f       	mov	r23, r22
    835a:	6a 2f       	mov	r22, r26
    835c:	11 24       	eor	r1, r1
    835e:	9f 57       	subi	r25, 0x7F	; 127
    8360:	50 40       	sbci	r21, 0x00	; 0
    8362:	8a f0       	brmi	.+34     	; 0x8386 <__mulsf3_pse+0x84>
    8364:	e1 f0       	breq	.+56     	; 0x839e <__mulsf3_pse+0x9c>
    8366:	88 23       	and	r24, r24
    8368:	4a f0       	brmi	.+18     	; 0x837c <__mulsf3_pse+0x7a>
    836a:	ee 0f       	add	r30, r30
    836c:	ff 1f       	adc	r31, r31
    836e:	bb 1f       	adc	r27, r27
    8370:	66 1f       	adc	r22, r22
    8372:	77 1f       	adc	r23, r23
    8374:	88 1f       	adc	r24, r24
    8376:	91 50       	subi	r25, 0x01	; 1
    8378:	50 40       	sbci	r21, 0x00	; 0
    837a:	a9 f7       	brne	.-22     	; 0x8366 <__mulsf3_pse+0x64>
    837c:	9e 3f       	cpi	r25, 0xFE	; 254
    837e:	51 05       	cpc	r21, r1
    8380:	70 f0       	brcs	.+28     	; 0x839e <__mulsf3_pse+0x9c>
    8382:	34 cf       	rjmp	.-408    	; 0x81ec <__fp_inf>
    8384:	a3 cf       	rjmp	.-186    	; 0x82cc <__fp_szero>
    8386:	5f 3f       	cpi	r21, 0xFF	; 255
    8388:	ec f3       	brlt	.-6      	; 0x8384 <__mulsf3_pse+0x82>
    838a:	98 3e       	cpi	r25, 0xE8	; 232
    838c:	dc f3       	brlt	.-10     	; 0x8384 <__mulsf3_pse+0x82>
    838e:	86 95       	lsr	r24
    8390:	77 95       	ror	r23
    8392:	67 95       	ror	r22
    8394:	b7 95       	ror	r27
    8396:	f7 95       	ror	r31
    8398:	e7 95       	ror	r30
    839a:	9f 5f       	subi	r25, 0xFF	; 255
    839c:	c1 f7       	brne	.-16     	; 0x838e <__mulsf3_pse+0x8c>
    839e:	fe 2b       	or	r31, r30
    83a0:	88 0f       	add	r24, r24
    83a2:	91 1d       	adc	r25, r1
    83a4:	96 95       	lsr	r25
    83a6:	87 95       	ror	r24
    83a8:	97 f9       	bld	r25, 7
    83aa:	08 95       	ret

000083ac <pow>:
    83ac:	fa 01       	movw	r30, r20
    83ae:	ee 0f       	add	r30, r30
    83b0:	ff 1f       	adc	r31, r31
    83b2:	30 96       	adiw	r30, 0x00	; 0
    83b4:	21 05       	cpc	r18, r1
    83b6:	31 05       	cpc	r19, r1
    83b8:	99 f1       	breq	.+102    	; 0x8420 <pow+0x74>
    83ba:	61 15       	cp	r22, r1
    83bc:	71 05       	cpc	r23, r1
    83be:	61 f4       	brne	.+24     	; 0x83d8 <pow+0x2c>
    83c0:	80 38       	cpi	r24, 0x80	; 128
    83c2:	bf e3       	ldi	r27, 0x3F	; 63
    83c4:	9b 07       	cpc	r25, r27
    83c6:	49 f1       	breq	.+82     	; 0x841a <pow+0x6e>
    83c8:	68 94       	set
    83ca:	90 38       	cpi	r25, 0x80	; 128
    83cc:	81 05       	cpc	r24, r1
    83ce:	61 f0       	breq	.+24     	; 0x83e8 <pow+0x3c>
    83d0:	80 38       	cpi	r24, 0x80	; 128
    83d2:	bf ef       	ldi	r27, 0xFF	; 255
    83d4:	9b 07       	cpc	r25, r27
    83d6:	41 f0       	breq	.+16     	; 0x83e8 <pow+0x3c>
    83d8:	99 23       	and	r25, r25
    83da:	42 f5       	brpl	.+80     	; 0x842c <pow+0x80>
    83dc:	ff 3f       	cpi	r31, 0xFF	; 255
    83de:	e1 05       	cpc	r30, r1
    83e0:	31 05       	cpc	r19, r1
    83e2:	21 05       	cpc	r18, r1
    83e4:	11 f1       	breq	.+68     	; 0x842a <pow+0x7e>
    83e6:	e8 94       	clt
    83e8:	08 94       	sec
    83ea:	e7 95       	ror	r30
    83ec:	d9 01       	movw	r26, r18
    83ee:	aa 23       	and	r26, r26
    83f0:	29 f4       	brne	.+10     	; 0x83fc <pow+0x50>
    83f2:	ab 2f       	mov	r26, r27
    83f4:	be 2f       	mov	r27, r30
    83f6:	f8 5f       	subi	r31, 0xF8	; 248
    83f8:	d0 f3       	brcs	.-12     	; 0x83ee <pow+0x42>
    83fa:	10 c0       	rjmp	.+32     	; 0x841c <pow+0x70>
    83fc:	ff 5f       	subi	r31, 0xFF	; 255
    83fe:	70 f4       	brcc	.+28     	; 0x841c <pow+0x70>
    8400:	a6 95       	lsr	r26
    8402:	e0 f7       	brcc	.-8      	; 0x83fc <pow+0x50>
    8404:	f7 39       	cpi	r31, 0x97	; 151
    8406:	50 f0       	brcs	.+20     	; 0x841c <pow+0x70>
    8408:	19 f0       	breq	.+6      	; 0x8410 <pow+0x64>
    840a:	ff 3a       	cpi	r31, 0xAF	; 175
    840c:	38 f4       	brcc	.+14     	; 0x841c <pow+0x70>
    840e:	9f 77       	andi	r25, 0x7F	; 127
    8410:	9f 93       	push	r25
    8412:	0c d0       	rcall	.+24     	; 0x842c <pow+0x80>
    8414:	0f 90       	pop	r0
    8416:	07 fc       	sbrc	r0, 7
    8418:	90 58       	subi	r25, 0x80	; 128
    841a:	08 95       	ret
    841c:	3e f0       	brts	.+14     	; 0x842c <pow+0x80>
    841e:	ec ce       	rjmp	.-552    	; 0x81f8 <__fp_nan>
    8420:	60 e0       	ldi	r22, 0x00	; 0
    8422:	70 e0       	ldi	r23, 0x00	; 0
    8424:	80 e8       	ldi	r24, 0x80	; 128
    8426:	9f e3       	ldi	r25, 0x3F	; 63
    8428:	08 95       	ret
    842a:	4f e7       	ldi	r20, 0x7F	; 127
    842c:	9f 77       	andi	r25, 0x7F	; 127
    842e:	5f 93       	push	r21
    8430:	4f 93       	push	r20
    8432:	3f 93       	push	r19
    8434:	2f 93       	push	r18
    8436:	cc d0       	rcall	.+408    	; 0x85d0 <log>
    8438:	2f 91       	pop	r18
    843a:	3f 91       	pop	r19
    843c:	4f 91       	pop	r20
    843e:	5f 91       	pop	r21
    8440:	52 df       	rcall	.-348    	; 0x82e6 <__mulsf3>
    8442:	4a c0       	rjmp	.+148    	; 0x84d8 <exp>
    8444:	11 f4       	brne	.+4      	; 0x844a <pow+0x9e>
    8446:	0e f4       	brtc	.+2      	; 0x844a <pow+0x9e>
    8448:	d7 ce       	rjmp	.-594    	; 0x81f8 <__fp_nan>
    844a:	72 c0       	rjmp	.+228    	; 0x8530 <__fp_mpack>

0000844c <sqrt>:
    844c:	24 df       	rcall	.-440    	; 0x8296 <__fp_splitA>
    844e:	d0 f3       	brcs	.-12     	; 0x8444 <pow+0x98>
    8450:	99 23       	and	r25, r25
    8452:	d9 f3       	breq	.-10     	; 0x844a <pow+0x9e>
    8454:	ce f3       	brts	.-14     	; 0x8448 <pow+0x9c>
    8456:	9f 57       	subi	r25, 0x7F	; 127
    8458:	55 0b       	sbc	r21, r21
    845a:	87 ff       	sbrs	r24, 7
    845c:	77 d0       	rcall	.+238    	; 0x854c <__fp_norm2>
    845e:	00 24       	eor	r0, r0
    8460:	a0 e6       	ldi	r26, 0x60	; 96
    8462:	40 ea       	ldi	r20, 0xA0	; 160
    8464:	90 01       	movw	r18, r0
    8466:	80 58       	subi	r24, 0x80	; 128
    8468:	56 95       	lsr	r21
    846a:	97 95       	ror	r25
    846c:	28 f4       	brcc	.+10     	; 0x8478 <sqrt+0x2c>
    846e:	80 5c       	subi	r24, 0xC0	; 192
    8470:	66 0f       	add	r22, r22
    8472:	77 1f       	adc	r23, r23
    8474:	88 1f       	adc	r24, r24
    8476:	20 f0       	brcs	.+8      	; 0x8480 <sqrt+0x34>
    8478:	26 17       	cp	r18, r22
    847a:	37 07       	cpc	r19, r23
    847c:	48 07       	cpc	r20, r24
    847e:	30 f4       	brcc	.+12     	; 0x848c <sqrt+0x40>
    8480:	62 1b       	sub	r22, r18
    8482:	73 0b       	sbc	r23, r19
    8484:	84 0b       	sbc	r24, r20
    8486:	20 29       	or	r18, r0
    8488:	31 29       	or	r19, r1
    848a:	4a 2b       	or	r20, r26
    848c:	a6 95       	lsr	r26
    848e:	17 94       	ror	r1
    8490:	07 94       	ror	r0
    8492:	20 25       	eor	r18, r0
    8494:	31 25       	eor	r19, r1
    8496:	4a 27       	eor	r20, r26
    8498:	58 f7       	brcc	.-42     	; 0x8470 <sqrt+0x24>
    849a:	66 0f       	add	r22, r22
    849c:	77 1f       	adc	r23, r23
    849e:	88 1f       	adc	r24, r24
    84a0:	20 f0       	brcs	.+8      	; 0x84aa <sqrt+0x5e>
    84a2:	26 17       	cp	r18, r22
    84a4:	37 07       	cpc	r19, r23
    84a6:	48 07       	cpc	r20, r24
    84a8:	30 f4       	brcc	.+12     	; 0x84b6 <sqrt+0x6a>
    84aa:	62 0b       	sbc	r22, r18
    84ac:	73 0b       	sbc	r23, r19
    84ae:	84 0b       	sbc	r24, r20
    84b0:	20 0d       	add	r18, r0
    84b2:	31 1d       	adc	r19, r1
    84b4:	41 1d       	adc	r20, r1
    84b6:	a0 95       	com	r26
    84b8:	81 f7       	brne	.-32     	; 0x849a <sqrt+0x4e>
    84ba:	b9 01       	movw	r22, r18
    84bc:	84 2f       	mov	r24, r20
    84be:	91 58       	subi	r25, 0x81	; 129
    84c0:	88 0f       	add	r24, r24
    84c2:	96 95       	lsr	r25
    84c4:	87 95       	ror	r24
    84c6:	08 95       	ret

000084c8 <square>:
    84c8:	9b 01       	movw	r18, r22
    84ca:	ac 01       	movw	r20, r24
    84cc:	0c cf       	rjmp	.-488    	; 0x82e6 <__mulsf3>
    84ce:	19 f4       	brne	.+6      	; 0x84d6 <square+0xe>
    84d0:	0e f0       	brts	.+2      	; 0x84d4 <square+0xc>
    84d2:	8c ce       	rjmp	.-744    	; 0x81ec <__fp_inf>
    84d4:	fa ce       	rjmp	.-524    	; 0x82ca <__fp_zero>
    84d6:	90 ce       	rjmp	.-736    	; 0x81f8 <__fp_nan>

000084d8 <exp>:
    84d8:	de de       	rcall	.-580    	; 0x8296 <__fp_splitA>
    84da:	c8 f3       	brcs	.-14     	; 0x84ce <square+0x6>
    84dc:	96 38       	cpi	r25, 0x86	; 134
    84de:	c0 f7       	brcc	.-16     	; 0x84d0 <square+0x8>
    84e0:	07 f8       	bld	r0, 7
    84e2:	0f 92       	push	r0
    84e4:	e8 94       	clt
    84e6:	2b e3       	ldi	r18, 0x3B	; 59
    84e8:	3a ea       	ldi	r19, 0xAA	; 170
    84ea:	48 eb       	ldi	r20, 0xB8	; 184
    84ec:	5f e7       	ldi	r21, 0x7F	; 127
    84ee:	09 df       	rcall	.-494    	; 0x8302 <__mulsf3_pse>
    84f0:	0f 92       	push	r0
    84f2:	0f 92       	push	r0
    84f4:	0f 92       	push	r0
    84f6:	4d b7       	in	r20, 0x3d	; 61
    84f8:	5e b7       	in	r21, 0x3e	; 62
    84fa:	0f 92       	push	r0
    84fc:	a9 d0       	rcall	.+338    	; 0x8650 <modf>
    84fe:	e5 ec       	ldi	r30, 0xC5	; 197
    8500:	f0 e0       	ldi	r31, 0x00	; 0
    8502:	7d de       	rcall	.-774    	; 0x81fe <__fp_powser>
    8504:	4f 91       	pop	r20
    8506:	5f 91       	pop	r21
    8508:	ef 91       	pop	r30
    850a:	ff 91       	pop	r31
    850c:	e5 95       	asr	r30
    850e:	ee 1f       	adc	r30, r30
    8510:	ff 1f       	adc	r31, r31
    8512:	49 f0       	breq	.+18     	; 0x8526 <exp+0x4e>
    8514:	fe 57       	subi	r31, 0x7E	; 126
    8516:	e0 68       	ori	r30, 0x80	; 128
    8518:	44 27       	eor	r20, r20
    851a:	ee 0f       	add	r30, r30
    851c:	44 1f       	adc	r20, r20
    851e:	fa 95       	dec	r31
    8520:	e1 f7       	brne	.-8      	; 0x851a <exp+0x42>
    8522:	41 95       	neg	r20
    8524:	55 0b       	sbc	r21, r21
    8526:	1b d0       	rcall	.+54     	; 0x855e <ldexp>
    8528:	0f 90       	pop	r0
    852a:	07 fe       	sbrs	r0, 7
    852c:	d5 ce       	rjmp	.-598    	; 0x82d8 <inverse>
    852e:	08 95       	ret

00008530 <__fp_mpack>:
    8530:	9f 3f       	cpi	r25, 0xFF	; 255
    8532:	31 f0       	breq	.+12     	; 0x8540 <__fp_mpack_finite+0xc>

00008534 <__fp_mpack_finite>:
    8534:	91 50       	subi	r25, 0x01	; 1
    8536:	20 f4       	brcc	.+8      	; 0x8540 <__fp_mpack_finite+0xc>
    8538:	87 95       	ror	r24
    853a:	77 95       	ror	r23
    853c:	67 95       	ror	r22
    853e:	b7 95       	ror	r27
    8540:	88 0f       	add	r24, r24
    8542:	91 1d       	adc	r25, r1
    8544:	96 95       	lsr	r25
    8546:	87 95       	ror	r24
    8548:	97 f9       	bld	r25, 7
    854a:	08 95       	ret

0000854c <__fp_norm2>:
    854c:	91 50       	subi	r25, 0x01	; 1
    854e:	50 40       	sbci	r21, 0x00	; 0
    8550:	66 0f       	add	r22, r22
    8552:	77 1f       	adc	r23, r23
    8554:	88 1f       	adc	r24, r24
    8556:	d2 f7       	brpl	.-12     	; 0x854c <__fp_norm2>
    8558:	08 95       	ret
    855a:	48 ce       	rjmp	.-880    	; 0x81ec <__fp_inf>
    855c:	e9 cf       	rjmp	.-46     	; 0x8530 <__fp_mpack>

0000855e <ldexp>:
    855e:	9b de       	rcall	.-714    	; 0x8296 <__fp_splitA>
    8560:	e8 f3       	brcs	.-6      	; 0x855c <__fp_norm2+0x10>
    8562:	99 23       	and	r25, r25
    8564:	d9 f3       	breq	.-10     	; 0x855c <__fp_norm2+0x10>
    8566:	94 0f       	add	r25, r20
    8568:	51 1d       	adc	r21, r1
    856a:	bb f3       	brvs	.-18     	; 0x855a <__fp_norm2+0xe>
    856c:	91 50       	subi	r25, 0x01	; 1
    856e:	50 40       	sbci	r21, 0x00	; 0
    8570:	94 f0       	brlt	.+36     	; 0x8596 <ldexp+0x38>
    8572:	59 f0       	breq	.+22     	; 0x858a <ldexp+0x2c>
    8574:	88 23       	and	r24, r24
    8576:	32 f0       	brmi	.+12     	; 0x8584 <ldexp+0x26>
    8578:	66 0f       	add	r22, r22
    857a:	77 1f       	adc	r23, r23
    857c:	88 1f       	adc	r24, r24
    857e:	91 50       	subi	r25, 0x01	; 1
    8580:	50 40       	sbci	r21, 0x00	; 0
    8582:	c1 f7       	brne	.-16     	; 0x8574 <ldexp+0x16>
    8584:	9e 3f       	cpi	r25, 0xFE	; 254
    8586:	51 05       	cpc	r21, r1
    8588:	44 f7       	brge	.-48     	; 0x855a <__fp_norm2+0xe>
    858a:	88 0f       	add	r24, r24
    858c:	91 1d       	adc	r25, r1
    858e:	96 95       	lsr	r25
    8590:	87 95       	ror	r24
    8592:	97 f9       	bld	r25, 7
    8594:	08 95       	ret
    8596:	5f 3f       	cpi	r21, 0xFF	; 255
    8598:	ac f0       	brlt	.+42     	; 0x85c4 <ldexp+0x66>
    859a:	98 3e       	cpi	r25, 0xE8	; 232
    859c:	9c f0       	brlt	.+38     	; 0x85c4 <ldexp+0x66>
    859e:	bb 27       	eor	r27, r27
    85a0:	86 95       	lsr	r24
    85a2:	77 95       	ror	r23
    85a4:	67 95       	ror	r22
    85a6:	b7 95       	ror	r27
    85a8:	08 f4       	brcc	.+2      	; 0x85ac <ldexp+0x4e>
    85aa:	b1 60       	ori	r27, 0x01	; 1
    85ac:	93 95       	inc	r25
    85ae:	c1 f7       	brne	.-16     	; 0x85a0 <ldexp+0x42>
    85b0:	bb 0f       	add	r27, r27
    85b2:	58 f7       	brcc	.-42     	; 0x858a <ldexp+0x2c>
    85b4:	11 f4       	brne	.+4      	; 0x85ba <ldexp+0x5c>
    85b6:	60 ff       	sbrs	r22, 0
    85b8:	e8 cf       	rjmp	.-48     	; 0x858a <ldexp+0x2c>
    85ba:	6f 5f       	subi	r22, 0xFF	; 255
    85bc:	7f 4f       	sbci	r23, 0xFF	; 255
    85be:	8f 4f       	sbci	r24, 0xFF	; 255
    85c0:	9f 4f       	sbci	r25, 0xFF	; 255
    85c2:	e3 cf       	rjmp	.-58     	; 0x858a <ldexp+0x2c>
    85c4:	83 ce       	rjmp	.-762    	; 0x82cc <__fp_szero>
    85c6:	0e f0       	brts	.+2      	; 0x85ca <ldexp+0x6c>
    85c8:	b3 cf       	rjmp	.-154    	; 0x8530 <__fp_mpack>
    85ca:	16 ce       	rjmp	.-980    	; 0x81f8 <__fp_nan>
    85cc:	68 94       	set
    85ce:	0e ce       	rjmp	.-996    	; 0x81ec <__fp_inf>

000085d0 <log>:
    85d0:	62 de       	rcall	.-828    	; 0x8296 <__fp_splitA>
    85d2:	c8 f3       	brcs	.-14     	; 0x85c6 <ldexp+0x68>
    85d4:	99 23       	and	r25, r25
    85d6:	d1 f3       	breq	.-12     	; 0x85cc <ldexp+0x6e>
    85d8:	c6 f3       	brts	.-16     	; 0x85ca <ldexp+0x6c>
    85da:	df 93       	push	r29
    85dc:	cf 93       	push	r28
    85de:	1f 93       	push	r17
    85e0:	0f 93       	push	r16
    85e2:	ff 92       	push	r15
    85e4:	c9 2f       	mov	r28, r25
    85e6:	dd 27       	eor	r29, r29
    85e8:	88 23       	and	r24, r24
    85ea:	2a f0       	brmi	.+10     	; 0x85f6 <log+0x26>
    85ec:	21 97       	sbiw	r28, 0x01	; 1
    85ee:	66 0f       	add	r22, r22
    85f0:	77 1f       	adc	r23, r23
    85f2:	88 1f       	adc	r24, r24
    85f4:	da f7       	brpl	.-10     	; 0x85ec <log+0x1c>
    85f6:	20 e0       	ldi	r18, 0x00	; 0
    85f8:	30 e0       	ldi	r19, 0x00	; 0
    85fa:	40 e8       	ldi	r20, 0x80	; 128
    85fc:	5f eb       	ldi	r21, 0xBF	; 191
    85fe:	9f e3       	ldi	r25, 0x3F	; 63
    8600:	88 39       	cpi	r24, 0x98	; 152
    8602:	20 f0       	brcs	.+8      	; 0x860c <log+0x3c>
    8604:	80 3e       	cpi	r24, 0xE0	; 224
    8606:	30 f0       	brcs	.+12     	; 0x8614 <log+0x44>
    8608:	21 96       	adiw	r28, 0x01	; 1
    860a:	8f 77       	andi	r24, 0x7F	; 127
    860c:	8d dc       	rcall	.-1766   	; 0x7f28 <__addsf3>
    860e:	ed ee       	ldi	r30, 0xED	; 237
    8610:	f0 e0       	ldi	r31, 0x00	; 0
    8612:	03 c0       	rjmp	.+6      	; 0x861a <log+0x4a>
    8614:	89 dc       	rcall	.-1774   	; 0x7f28 <__addsf3>
    8616:	ea e1       	ldi	r30, 0x1A	; 26
    8618:	f1 e0       	ldi	r31, 0x01	; 1
    861a:	f1 dd       	rcall	.-1054   	; 0x81fe <__fp_powser>
    861c:	8b 01       	movw	r16, r22
    861e:	be 01       	movw	r22, r28
    8620:	ec 01       	movw	r28, r24
    8622:	fb 2e       	mov	r15, r27
    8624:	6f 57       	subi	r22, 0x7F	; 127
    8626:	71 09       	sbc	r23, r1
    8628:	75 95       	asr	r23
    862a:	77 1f       	adc	r23, r23
    862c:	88 0b       	sbc	r24, r24
    862e:	99 0b       	sbc	r25, r25
    8630:	a2 dd       	rcall	.-1212   	; 0x8176 <__floatsisf>
    8632:	28 e1       	ldi	r18, 0x18	; 24
    8634:	32 e7       	ldi	r19, 0x72	; 114
    8636:	41 e3       	ldi	r20, 0x31	; 49
    8638:	5f e3       	ldi	r21, 0x3F	; 63
    863a:	61 de       	rcall	.-830    	; 0x82fe <__mulsf3x>
    863c:	af 2d       	mov	r26, r15
    863e:	98 01       	movw	r18, r16
    8640:	ae 01       	movw	r20, r28
    8642:	ff 90       	pop	r15
    8644:	0f 91       	pop	r16
    8646:	1f 91       	pop	r17
    8648:	cf 91       	pop	r28
    864a:	df 91       	pop	r29
    864c:	7e dc       	rcall	.-1796   	; 0x7f4a <__addsf3x>
    864e:	0a ce       	rjmp	.-1004   	; 0x8264 <__fp_round>

00008650 <modf>:
    8650:	fa 01       	movw	r30, r20
    8652:	dc 01       	movw	r26, r24
    8654:	aa 0f       	add	r26, r26
    8656:	bb 1f       	adc	r27, r27
    8658:	9b 01       	movw	r18, r22
    865a:	ac 01       	movw	r20, r24
    865c:	bf 57       	subi	r27, 0x7F	; 127
    865e:	28 f4       	brcc	.+10     	; 0x866a <modf+0x1a>
    8660:	22 27       	eor	r18, r18
    8662:	33 27       	eor	r19, r19
    8664:	44 27       	eor	r20, r20
    8666:	50 78       	andi	r21, 0x80	; 128
    8668:	1f c0       	rjmp	.+62     	; 0x86a8 <modf+0x58>
    866a:	b7 51       	subi	r27, 0x17	; 23
    866c:	88 f4       	brcc	.+34     	; 0x8690 <modf+0x40>
    866e:	ab 2f       	mov	r26, r27
    8670:	00 24       	eor	r0, r0
    8672:	46 95       	lsr	r20
    8674:	37 95       	ror	r19
    8676:	27 95       	ror	r18
    8678:	01 1c       	adc	r0, r1
    867a:	a3 95       	inc	r26
    867c:	d2 f3       	brmi	.-12     	; 0x8672 <modf+0x22>
    867e:	00 20       	and	r0, r0
    8680:	69 f0       	breq	.+26     	; 0x869c <modf+0x4c>
    8682:	22 0f       	add	r18, r18
    8684:	33 1f       	adc	r19, r19
    8686:	44 1f       	adc	r20, r20
    8688:	b3 95       	inc	r27
    868a:	da f3       	brmi	.-10     	; 0x8682 <modf+0x32>
    868c:	0d d0       	rcall	.+26     	; 0x86a8 <modf+0x58>
    868e:	4b cc       	rjmp	.-1898   	; 0x7f26 <__subsf3>
    8690:	61 30       	cpi	r22, 0x01	; 1
    8692:	71 05       	cpc	r23, r1
    8694:	a0 e8       	ldi	r26, 0x80	; 128
    8696:	8a 07       	cpc	r24, r26
    8698:	b9 46       	sbci	r27, 0x69	; 105
    869a:	30 f4       	brcc	.+12     	; 0x86a8 <modf+0x58>
    869c:	9b 01       	movw	r18, r22
    869e:	ac 01       	movw	r20, r24
    86a0:	66 27       	eor	r22, r22
    86a2:	77 27       	eor	r23, r23
    86a4:	88 27       	eor	r24, r24
    86a6:	90 78       	andi	r25, 0x80	; 128
    86a8:	30 96       	adiw	r30, 0x00	; 0
    86aa:	21 f0       	breq	.+8      	; 0x86b4 <modf+0x64>
    86ac:	20 83       	st	Z, r18
    86ae:	31 83       	std	Z+1, r19	; 0x01
    86b0:	42 83       	std	Z+2, r20	; 0x02
    86b2:	53 83       	std	Z+3, r21	; 0x03
    86b4:	08 95       	ret

000086b6 <__mulsi3>:
    86b6:	62 9f       	mul	r22, r18
    86b8:	d0 01       	movw	r26, r0
    86ba:	73 9f       	mul	r23, r19
    86bc:	f0 01       	movw	r30, r0
    86be:	82 9f       	mul	r24, r18
    86c0:	e0 0d       	add	r30, r0
    86c2:	f1 1d       	adc	r31, r1
    86c4:	64 9f       	mul	r22, r20
    86c6:	e0 0d       	add	r30, r0
    86c8:	f1 1d       	adc	r31, r1
    86ca:	92 9f       	mul	r25, r18
    86cc:	f0 0d       	add	r31, r0
    86ce:	83 9f       	mul	r24, r19
    86d0:	f0 0d       	add	r31, r0
    86d2:	74 9f       	mul	r23, r20
    86d4:	f0 0d       	add	r31, r0
    86d6:	65 9f       	mul	r22, r21
    86d8:	f0 0d       	add	r31, r0
    86da:	99 27       	eor	r25, r25
    86dc:	72 9f       	mul	r23, r18
    86de:	b0 0d       	add	r27, r0
    86e0:	e1 1d       	adc	r30, r1
    86e2:	f9 1f       	adc	r31, r25
    86e4:	63 9f       	mul	r22, r19
    86e6:	b0 0d       	add	r27, r0
    86e8:	e1 1d       	adc	r30, r1
    86ea:	f9 1f       	adc	r31, r25
    86ec:	bd 01       	movw	r22, r26
    86ee:	cf 01       	movw	r24, r30
    86f0:	11 24       	eor	r1, r1
    86f2:	08 95       	ret

000086f4 <__divmodhi4>:
    86f4:	97 fb       	bst	r25, 7
    86f6:	09 2e       	mov	r0, r25
    86f8:	07 26       	eor	r0, r23
    86fa:	0a d0       	rcall	.+20     	; 0x8710 <__divmodhi4_neg1>
    86fc:	77 fd       	sbrc	r23, 7
    86fe:	04 d0       	rcall	.+8      	; 0x8708 <__divmodhi4_neg2>
    8700:	49 d0       	rcall	.+146    	; 0x8794 <__udivmodhi4>
    8702:	06 d0       	rcall	.+12     	; 0x8710 <__divmodhi4_neg1>
    8704:	00 20       	and	r0, r0
    8706:	1a f4       	brpl	.+6      	; 0x870e <__divmodhi4_exit>

00008708 <__divmodhi4_neg2>:
    8708:	70 95       	com	r23
    870a:	61 95       	neg	r22
    870c:	7f 4f       	sbci	r23, 0xFF	; 255

0000870e <__divmodhi4_exit>:
    870e:	08 95       	ret

00008710 <__divmodhi4_neg1>:
    8710:	f6 f7       	brtc	.-4      	; 0x870e <__divmodhi4_exit>
    8712:	90 95       	com	r25
    8714:	81 95       	neg	r24
    8716:	9f 4f       	sbci	r25, 0xFF	; 255
    8718:	08 95       	ret

0000871a <__udivmodsi4>:
    871a:	a1 e2       	ldi	r26, 0x21	; 33
    871c:	1a 2e       	mov	r1, r26
    871e:	aa 1b       	sub	r26, r26
    8720:	bb 1b       	sub	r27, r27
    8722:	fd 01       	movw	r30, r26
    8724:	0d c0       	rjmp	.+26     	; 0x8740 <__udivmodsi4_ep>

00008726 <__udivmodsi4_loop>:
    8726:	aa 1f       	adc	r26, r26
    8728:	bb 1f       	adc	r27, r27
    872a:	ee 1f       	adc	r30, r30
    872c:	ff 1f       	adc	r31, r31
    872e:	a2 17       	cp	r26, r18
    8730:	b3 07       	cpc	r27, r19
    8732:	e4 07       	cpc	r30, r20
    8734:	f5 07       	cpc	r31, r21
    8736:	20 f0       	brcs	.+8      	; 0x8740 <__udivmodsi4_ep>
    8738:	a2 1b       	sub	r26, r18
    873a:	b3 0b       	sbc	r27, r19
    873c:	e4 0b       	sbc	r30, r20
    873e:	f5 0b       	sbc	r31, r21

00008740 <__udivmodsi4_ep>:
    8740:	66 1f       	adc	r22, r22
    8742:	77 1f       	adc	r23, r23
    8744:	88 1f       	adc	r24, r24
    8746:	99 1f       	adc	r25, r25
    8748:	1a 94       	dec	r1
    874a:	69 f7       	brne	.-38     	; 0x8726 <__udivmodsi4_loop>
    874c:	60 95       	com	r22
    874e:	70 95       	com	r23
    8750:	80 95       	com	r24
    8752:	90 95       	com	r25
    8754:	9b 01       	movw	r18, r22
    8756:	ac 01       	movw	r20, r24
    8758:	bd 01       	movw	r22, r26
    875a:	cf 01       	movw	r24, r30
    875c:	08 95       	ret

0000875e <__divmodsi4>:
    875e:	97 fb       	bst	r25, 7
    8760:	09 2e       	mov	r0, r25
    8762:	05 26       	eor	r0, r21
    8764:	0e d0       	rcall	.+28     	; 0x8782 <__divmodsi4_neg1>
    8766:	57 fd       	sbrc	r21, 7
    8768:	04 d0       	rcall	.+8      	; 0x8772 <__divmodsi4_neg2>
    876a:	d7 df       	rcall	.-82     	; 0x871a <__udivmodsi4>
    876c:	0a d0       	rcall	.+20     	; 0x8782 <__divmodsi4_neg1>
    876e:	00 1c       	adc	r0, r0
    8770:	38 f4       	brcc	.+14     	; 0x8780 <__divmodsi4_exit>

00008772 <__divmodsi4_neg2>:
    8772:	50 95       	com	r21
    8774:	40 95       	com	r20
    8776:	30 95       	com	r19
    8778:	21 95       	neg	r18
    877a:	3f 4f       	sbci	r19, 0xFF	; 255
    877c:	4f 4f       	sbci	r20, 0xFF	; 255
    877e:	5f 4f       	sbci	r21, 0xFF	; 255

00008780 <__divmodsi4_exit>:
    8780:	08 95       	ret

00008782 <__divmodsi4_neg1>:
    8782:	f6 f7       	brtc	.-4      	; 0x8780 <__divmodsi4_exit>
    8784:	90 95       	com	r25
    8786:	80 95       	com	r24
    8788:	70 95       	com	r23
    878a:	61 95       	neg	r22
    878c:	7f 4f       	sbci	r23, 0xFF	; 255
    878e:	8f 4f       	sbci	r24, 0xFF	; 255
    8790:	9f 4f       	sbci	r25, 0xFF	; 255
    8792:	08 95       	ret

00008794 <__udivmodhi4>:
    8794:	aa 1b       	sub	r26, r26
    8796:	bb 1b       	sub	r27, r27
    8798:	51 e1       	ldi	r21, 0x11	; 17
    879a:	07 c0       	rjmp	.+14     	; 0x87aa <__udivmodhi4_ep>

0000879c <__udivmodhi4_loop>:
    879c:	aa 1f       	adc	r26, r26
    879e:	bb 1f       	adc	r27, r27
    87a0:	a6 17       	cp	r26, r22
    87a2:	b7 07       	cpc	r27, r23
    87a4:	10 f0       	brcs	.+4      	; 0x87aa <__udivmodhi4_ep>
    87a6:	a6 1b       	sub	r26, r22
    87a8:	b7 0b       	sbc	r27, r23

000087aa <__udivmodhi4_ep>:
    87aa:	88 1f       	adc	r24, r24
    87ac:	99 1f       	adc	r25, r25
    87ae:	5a 95       	dec	r21
    87b0:	a9 f7       	brne	.-22     	; 0x879c <__udivmodhi4_loop>
    87b2:	80 95       	com	r24
    87b4:	90 95       	com	r25
    87b6:	bc 01       	movw	r22, r24
    87b8:	cd 01       	movw	r24, r26
    87ba:	08 95       	ret

000087bc <__tablejump2__>:
    87bc:	ee 0f       	add	r30, r30
    87be:	ff 1f       	adc	r31, r31

000087c0 <__tablejump__>:
    87c0:	05 90       	lpm	r0, Z+
    87c2:	f4 91       	lpm	r31, Z+
    87c4:	e0 2d       	mov	r30, r0
    87c6:	09 94       	ijmp

000087c8 <itoa>:
    87c8:	fb 01       	movw	r30, r22
    87ca:	9f 01       	movw	r18, r30
    87cc:	e8 94       	clt
    87ce:	42 30       	cpi	r20, 0x02	; 2
    87d0:	bc f0       	brlt	.+46     	; 0x8800 <itoa+0x38>
    87d2:	45 32       	cpi	r20, 0x25	; 37
    87d4:	ac f4       	brge	.+42     	; 0x8800 <itoa+0x38>
    87d6:	4a 30       	cpi	r20, 0x0A	; 10
    87d8:	29 f4       	brne	.+10     	; 0x87e4 <itoa+0x1c>
    87da:	97 fb       	bst	r25, 7
    87dc:	1e f4       	brtc	.+6      	; 0x87e4 <itoa+0x1c>
    87de:	90 95       	com	r25
    87e0:	81 95       	neg	r24
    87e2:	9f 4f       	sbci	r25, 0xFF	; 255
    87e4:	64 2f       	mov	r22, r20
    87e6:	77 27       	eor	r23, r23
    87e8:	d5 df       	rcall	.-86     	; 0x8794 <__udivmodhi4>
    87ea:	80 5d       	subi	r24, 0xD0	; 208
    87ec:	8a 33       	cpi	r24, 0x3A	; 58
    87ee:	0c f0       	brlt	.+2      	; 0x87f2 <itoa+0x2a>
    87f0:	89 5d       	subi	r24, 0xD9	; 217
    87f2:	81 93       	st	Z+, r24
    87f4:	cb 01       	movw	r24, r22
    87f6:	00 97       	sbiw	r24, 0x00	; 0
    87f8:	a9 f7       	brne	.-22     	; 0x87e4 <itoa+0x1c>
    87fa:	16 f4       	brtc	.+4      	; 0x8800 <itoa+0x38>
    87fc:	5d e2       	ldi	r21, 0x2D	; 45
    87fe:	51 93       	st	Z+, r21
    8800:	10 82       	st	Z, r1
    8802:	c9 01       	movw	r24, r18
    8804:	55 c0       	rjmp	.+170    	; 0x88b0 <strrev>

00008806 <ltoa>:
    8806:	fa 01       	movw	r30, r20
    8808:	cf 93       	push	r28
    880a:	ff 93       	push	r31
    880c:	ef 93       	push	r30
    880e:	22 30       	cpi	r18, 0x02	; 2
    8810:	3c f1       	brlt	.+78     	; 0x8860 <ltoa+0x5a>
    8812:	25 32       	cpi	r18, 0x25	; 37
    8814:	2c f5       	brge	.+74     	; 0x8860 <ltoa+0x5a>
    8816:	c2 2f       	mov	r28, r18
    8818:	e8 94       	clt
    881a:	ca 30       	cpi	r28, 0x0A	; 10
    881c:	49 f4       	brne	.+18     	; 0x8830 <ltoa+0x2a>
    881e:	97 fb       	bst	r25, 7
    8820:	3e f4       	brtc	.+14     	; 0x8830 <ltoa+0x2a>
    8822:	90 95       	com	r25
    8824:	80 95       	com	r24
    8826:	70 95       	com	r23
    8828:	61 95       	neg	r22
    882a:	7f 4f       	sbci	r23, 0xFF	; 255
    882c:	8f 4f       	sbci	r24, 0xFF	; 255
    882e:	9f 4f       	sbci	r25, 0xFF	; 255
    8830:	2c 2f       	mov	r18, r28
    8832:	33 27       	eor	r19, r19
    8834:	44 27       	eor	r20, r20
    8836:	55 27       	eor	r21, r21
    8838:	ff 93       	push	r31
    883a:	ef 93       	push	r30
    883c:	6e df       	rcall	.-292    	; 0x871a <__udivmodsi4>
    883e:	ef 91       	pop	r30
    8840:	ff 91       	pop	r31
    8842:	60 5d       	subi	r22, 0xD0	; 208
    8844:	6a 33       	cpi	r22, 0x3A	; 58
    8846:	0c f0       	brlt	.+2      	; 0x884a <ltoa+0x44>
    8848:	69 5d       	subi	r22, 0xD9	; 217
    884a:	61 93       	st	Z+, r22
    884c:	b9 01       	movw	r22, r18
    884e:	ca 01       	movw	r24, r20
    8850:	60 50       	subi	r22, 0x00	; 0
    8852:	70 40       	sbci	r23, 0x00	; 0
    8854:	80 40       	sbci	r24, 0x00	; 0
    8856:	90 40       	sbci	r25, 0x00	; 0
    8858:	59 f7       	brne	.-42     	; 0x8830 <ltoa+0x2a>
    885a:	16 f4       	brtc	.+4      	; 0x8860 <ltoa+0x5a>
    885c:	cd e2       	ldi	r28, 0x2D	; 45
    885e:	c1 93       	st	Z+, r28
    8860:	10 82       	st	Z, r1
    8862:	8f 91       	pop	r24
    8864:	9f 91       	pop	r25
    8866:	cf 91       	pop	r28
    8868:	23 c0       	rjmp	.+70     	; 0x88b0 <strrev>

0000886a <ultoa>:
    886a:	fa 01       	movw	r30, r20
    886c:	cf 93       	push	r28
    886e:	ff 93       	push	r31
    8870:	ef 93       	push	r30
    8872:	22 30       	cpi	r18, 0x02	; 2
    8874:	c4 f0       	brlt	.+48     	; 0x88a6 <ultoa+0x3c>
    8876:	25 32       	cpi	r18, 0x25	; 37
    8878:	b4 f4       	brge	.+44     	; 0x88a6 <ultoa+0x3c>
    887a:	c2 2f       	mov	r28, r18
    887c:	2c 2f       	mov	r18, r28
    887e:	33 27       	eor	r19, r19
    8880:	44 27       	eor	r20, r20
    8882:	55 27       	eor	r21, r21
    8884:	ff 93       	push	r31
    8886:	ef 93       	push	r30
    8888:	48 df       	rcall	.-368    	; 0x871a <__udivmodsi4>
    888a:	ef 91       	pop	r30
    888c:	ff 91       	pop	r31
    888e:	60 5d       	subi	r22, 0xD0	; 208
    8890:	6a 33       	cpi	r22, 0x3A	; 58
    8892:	0c f0       	brlt	.+2      	; 0x8896 <ultoa+0x2c>
    8894:	69 5d       	subi	r22, 0xD9	; 217
    8896:	61 93       	st	Z+, r22
    8898:	b9 01       	movw	r22, r18
    889a:	ca 01       	movw	r24, r20
    889c:	60 50       	subi	r22, 0x00	; 0
    889e:	70 40       	sbci	r23, 0x00	; 0
    88a0:	80 40       	sbci	r24, 0x00	; 0
    88a2:	90 40       	sbci	r25, 0x00	; 0
    88a4:	59 f7       	brne	.-42     	; 0x887c <ultoa+0x12>
    88a6:	10 82       	st	Z, r1
    88a8:	8f 91       	pop	r24
    88aa:	9f 91       	pop	r25
    88ac:	cf 91       	pop	r28
    88ae:	00 c0       	rjmp	.+0      	; 0x88b0 <strrev>

000088b0 <strrev>:
    88b0:	dc 01       	movw	r26, r24
    88b2:	fc 01       	movw	r30, r24
    88b4:	67 2f       	mov	r22, r23
    88b6:	71 91       	ld	r23, Z+
    88b8:	77 23       	and	r23, r23
    88ba:	e1 f7       	brne	.-8      	; 0x88b4 <strrev+0x4>
    88bc:	32 97       	sbiw	r30, 0x02	; 2
    88be:	04 c0       	rjmp	.+8      	; 0x88c8 <strrev+0x18>
    88c0:	7c 91       	ld	r23, X
    88c2:	6d 93       	st	X+, r22
    88c4:	70 83       	st	Z, r23
    88c6:	62 91       	ld	r22, -Z
    88c8:	ae 17       	cp	r26, r30
    88ca:	bf 07       	cpc	r27, r31
    88cc:	c8 f3       	brcs	.-14     	; 0x88c0 <strrev+0x10>
    88ce:	08 95       	ret

000088d0 <_exit>:
    88d0:	f8 94       	cli

000088d2 <__stop_program>:
    88d2:	ff cf       	rjmp	.-2      	; 0x88d2 <__stop_program>
